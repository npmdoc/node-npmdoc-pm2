<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://pm2.keymetrics.io/"

    >pm2 (v2.4.4)</a>
</h1>
<h4>Production process manager for Node.JS applications with a built-in load balancer.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2">module pm2</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">pm2.</span>daemon_mode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">pm2.</span>gl_is_km_linked</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom">
            function <span class="apidocSignatureSpan">pm2.</span>custom
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>Client</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>_conf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>custom.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>gl_interact_infos</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>machine_name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>public_key</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>secret_key</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">pm2.</span>cwd</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">pm2.</span>pm2_home</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2.custom">module pm2.custom</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.custom">
            function <span class="apidocSignatureSpan">pm2.</span>custom
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2.custom.prototype">module pm2.custom.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype._handleAttributeUpdate">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_handleAttributeUpdate
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype._operate">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_operate
            <span class="apidocSignatureSpan">(action_name, process_name, envs, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype._pre_interact">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_pre_interact
            <span class="apidocSignatureSpan">(cmd, public_key, machine, info_node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype._pull">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_pull
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype._pullCommitId">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_pullCommitId
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype._startJson">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_startJson
            <span class="apidocSignatureSpan">(file, opts, action, pipe, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype._startScript">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_startScript
            <span class="apidocSignatureSpan">(script, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.actionFromJson">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>actionFromJson
            <span class="apidocSignatureSpan">(action, file, opts, jsonVia, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.backward">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>backward
            <span class="apidocSignatureSpan">(process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.close">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.conf">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>conf
            <span class="apidocSignatureSpan">(key, value, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.connect">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>connect
            <span class="apidocSignatureSpan">(noDaemon, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.dashboard">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>dashboard
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.deepUpdate">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>deepUpdate
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.delete">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>delete
            <span class="apidocSignatureSpan">(process_name, jsonVia, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.deleteModule">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>deleteModule
            <span class="apidocSignatureSpan">(module_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.deploy">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>deploy
            <span class="apidocSignatureSpan">(file, commands, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.describe">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>describe
            <span class="apidocSignatureSpan">(pm2_id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.destroy">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>destroy
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.disconnect">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>disconnect
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.dockerMode">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>dockerMode
            <span class="apidocSignatureSpan">(script, opts, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.dump">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>dump
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.exitCli">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>exitCli
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.flush">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>flush
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.forward">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>forward
            <span class="apidocSignatureSpan">(process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.generateDockerfile">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>generateDockerfile
            <span class="apidocSignatureSpan">(script, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.generateModuleSample">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>generateModuleSample
            <span class="apidocSignatureSpan">(app_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.generateSample">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>generateSample
            <span class="apidocSignatureSpan">(mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.get">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>get
            <span class="apidocSignatureSpan">(key, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.getProcessIdByName">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>getProcessIdByName
            <span class="apidocSignatureSpan">(name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.getVersion">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>getVersion
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.gracefulReload">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>gracefulReload
            <span class="apidocSignatureSpan">(process_name, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.install">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>install
            <span class="apidocSignatureSpan">(module_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.interact">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>interact
            <span class="apidocSignatureSpan">(secret_key, public_key, machine_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.interactInfos">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>interactInfos
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.jlist">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>jlist
            <span class="apidocSignatureSpan">(debug)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.kill">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>kill
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.killAllModules">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>killAllModules
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.killDaemon">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>killDaemon
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.killInteract">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>killInteract
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.launchBus">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>launchBus
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.launchModules">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>launchModules
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.list">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>list
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.logrotate">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>logrotate
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.monit">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>monit
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.msgProcess">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>msgProcess
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.multiset">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>multiset
            <span class="apidocSignatureSpan">(serial, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.ping">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>ping
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.printLogs">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>printLogs
            <span class="apidocSignatureSpan">(id, lines, raw, timestamp, exclusive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.profilePM2">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>profilePM2
            <span class="apidocSignatureSpan">(command, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.publish">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>publish
            <span class="apidocSignatureSpan">(module_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.pullAndGracefulReload">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullAndGracefulReload
            <span class="apidocSignatureSpan">(process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.pullAndReload">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullAndReload
            <span class="apidocSignatureSpan">(process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.pullAndRestart">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullAndRestart
            <span class="apidocSignatureSpan">(process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.pullCommitId">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullCommitId
            <span class="apidocSignatureSpan">(process_name, commit_id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.reload">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>reload
            <span class="apidocSignatureSpan">(process_name, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.reloadLogs">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>reloadLogs
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.remote">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>remote
            <span class="apidocSignatureSpan">(command, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.remoteV2">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>remoteV2
            <span class="apidocSignatureSpan">(command, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.reset">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>reset
            <span class="apidocSignatureSpan">(process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.restart">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>restart
            <span class="apidocSignatureSpan">(cmd, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.resurrect">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>resurrect
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.scale">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>scale
            <span class="apidocSignatureSpan">(app_name, number, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.sendDataToProcessId">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>sendDataToProcessId
            <span class="apidocSignatureSpan">(proc_id, packet, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.sendSignalToProcessId">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>sendSignalToProcessId
            <span class="apidocSignatureSpan">(signal, process_id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.sendSignalToProcessName">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>sendSignalToProcessName
            <span class="apidocSignatureSpan">(signal, process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.serve">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>serve
            <span class="apidocSignatureSpan">(target_path, port, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.set">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>set
            <span class="apidocSignatureSpan">(key, value, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.snapshotPM2">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>snapshotPM2
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.speedList">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>speedList
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.start">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>start
            <span class="apidocSignatureSpan">(cmd, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.startup">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>startup
            <span class="apidocSignatureSpan">(platform, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.stop">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>stop
            <span class="apidocSignatureSpan">(process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.streamLogs">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>streamLogs
            <span class="apidocSignatureSpan">(id, lines, raw, timestamp, exclusive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.trigger">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>trigger
            <span class="apidocSignatureSpan">(pm_id, action_name, params, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.uninstall">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>uninstall
            <span class="apidocSignatureSpan">(module_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.uninstallStartup">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>uninstallStartup
            <span class="apidocSignatureSpan">(platform, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.unset">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>unset
            <span class="apidocSignatureSpan">(key, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.update">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>update
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.web">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>web
            <span class="apidocSignatureSpan">(port, cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2" id="apidoc.module.pm2">module pm2</a></h1>






    <h2>
        <a href="#apidoc.element.pm2.custom" id="apidoc.element.pm2.custom">
        function <span class="apidocSignatureSpan">pm2.</span>custom
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">custom = function (opts) {
  if (!opts) opts = {};
  var that = this;

  this.daemon_mode = typeof(opts.daemon_mode) == &#x27;undefined&#x27; ? true : opts.daemon_mode;
  this.pm2_home    = conf.PM2_ROOT_PATH;
  this.public_key   = process.env.KEYMETRICS_SECRET || opts.public_key || null;
  this.secret_key   = process.env.KEYMETRICS_PUBLIC || opts.secret_key || null;
  this.machine_name = process.env.INSTANCE_NAME || opts.machine_name || null

<span class="apidocCodeCommentSpan">  /**
   * CWD resolution
   */
</span>  this.cwd         = process.cwd();
  if (opts.cwd) {
    this.cwd = path.resolve(opts.cwd);
  }

  /**
   * PM2 HOME resolution
   */
  if (opts.pm2_home &#x26;&#x26; opts.independent == true)
    throw new Error(&#x27;You cannot set a pm2_home and independent instance in same time&#x27;);

  if (opts.pm2_home) {
    // Override default conf file
    this.pm2_home        = opts.pm2_home;
    conf = util._extend(conf, path_structure(this.pm2_home));
  }
  else if (opts.independent == true &#x26;&#x26; conf.IS_WINDOWS === false) {
    // Create an unique pm2 instance
    var crypto = require(&#x27;crypto&#x27;);
    var random_file = crypto.randomBytes(8).toString(&#x27;hex&#x27;);
    this.pm2_home = path.join(&#x27;/tmp&#x27;, random_file);

    // If we dont explicitly tell to have a daemon
    // It will go as in proc
    if (typeof(opts.daemon_mode) == &#x27;undefined&#x27;)
      this.daemon_mode = false;
    conf = util._extend(conf, path_structure(this.pm2_home));
  }

  this._conf = conf;

  if (conf.IS_WINDOWS) {
    // Weird fix, may need to be dropped
    // @todo windows connoisseur double check
    if (process.stdout._handle &#x26;&#x26; process.stdout._handle.setBlocking)
      process.stdout._handle.setBlocking(true);
  }

  this.Client = new Client({
    pm2_home : that.pm2_home,
    conf     : this._conf,
    secret_key : this.secret_key,
    public_key : this.public_key,
    daemon_mode : this.daemon_mode,
    machine_name : this.machine_name
  });

  this.gl_interact_infos = null;
  this.gl_is_km_linked = false;

  try {
    var pid = fs.readFileSync(conf.INTERACTOR_PID_PATH);
    pid = parseInt(pid.toString().trim());
    process.kill(pid, 0);
    that.gl_is_km_linked = true;
  } catch(e) {
    that.gl_is_km_linked = false;
  }

  // For testing purposes
  if (this.secret_key &#x26;&#x26; process.env.NODE_ENV == &#x27;local_test&#x27;)
    that.gl_is_km_linked = true;

  KMDaemon.getInteractInfo(this._conf, function(i_err, interact) {
    that.gl_interact_infos = interact;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2.custom" id="apidoc.module.pm2.custom">module pm2.custom</a></h1>


    <h2>
        <a href="#apidoc.element.pm2.custom.custom" id="apidoc.element.pm2.custom.custom">
        function <span class="apidocSignatureSpan">pm2.</span>custom
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">custom = function (opts) {
  if (!opts) opts = {};
  var that = this;

  this.daemon_mode = typeof(opts.daemon_mode) == &#x27;undefined&#x27; ? true : opts.daemon_mode;
  this.pm2_home    = conf.PM2_ROOT_PATH;
  this.public_key   = process.env.KEYMETRICS_SECRET || opts.public_key || null;
  this.secret_key   = process.env.KEYMETRICS_PUBLIC || opts.secret_key || null;
  this.machine_name = process.env.INSTANCE_NAME || opts.machine_name || null

<span class="apidocCodeCommentSpan">  /**
   * CWD resolution
   */
</span>  this.cwd         = process.cwd();
  if (opts.cwd) {
    this.cwd = path.resolve(opts.cwd);
  }

  /**
   * PM2 HOME resolution
   */
  if (opts.pm2_home &#x26;&#x26; opts.independent == true)
    throw new Error(&#x27;You cannot set a pm2_home and independent instance in same time&#x27;);

  if (opts.pm2_home) {
    // Override default conf file
    this.pm2_home        = opts.pm2_home;
    conf = util._extend(conf, path_structure(this.pm2_home));
  }
  else if (opts.independent == true &#x26;&#x26; conf.IS_WINDOWS === false) {
    // Create an unique pm2 instance
    var crypto = require(&#x27;crypto&#x27;);
    var random_file = crypto.randomBytes(8).toString(&#x27;hex&#x27;);
    this.pm2_home = path.join(&#x27;/tmp&#x27;, random_file);

    // If we dont explicitly tell to have a daemon
    // It will go as in proc
    if (typeof(opts.daemon_mode) == &#x27;undefined&#x27;)
      this.daemon_mode = false;
    conf = util._extend(conf, path_structure(this.pm2_home));
  }

  this._conf = conf;

  if (conf.IS_WINDOWS) {
    // Weird fix, may need to be dropped
    // @todo windows connoisseur double check
    if (process.stdout._handle &#x26;&#x26; process.stdout._handle.setBlocking)
      process.stdout._handle.setBlocking(true);
  }

  this.Client = new Client({
    pm2_home : that.pm2_home,
    conf     : this._conf,
    secret_key : this.secret_key,
    public_key : this.public_key,
    daemon_mode : this.daemon_mode,
    machine_name : this.machine_name
  });

  this.gl_interact_infos = null;
  this.gl_is_km_linked = false;

  try {
    var pid = fs.readFileSync(conf.INTERACTOR_PID_PATH);
    pid = parseInt(pid.toString().trim());
    process.kill(pid, 0);
    that.gl_is_km_linked = true;
  } catch(e) {
    that.gl_is_km_linked = false;
  }

  // For testing purposes
  if (this.secret_key &#x26;&#x26; process.env.NODE_ENV == &#x27;local_test&#x27;)
    that.gl_is_km_linked = true;

  KMDaemon.getInteractInfo(this._conf, function(i_err, interact) {
    that.gl_interact_infos = interact;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2.custom.prototype" id="apidoc.module.pm2.custom.prototype">module pm2.custom.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pm2.custom.prototype._handleAttributeUpdate" id="apidoc.element.pm2.custom.prototype._handleAttributeUpdate">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_handleAttributeUpdate
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleAttributeUpdate = function (opts) {
  var conf = Config.transCMDToConf(opts);
  var that = this;

  if (typeof(conf.name) != &#x27;string&#x27;)
    delete conf.name;

  var argsIndex = 0;
  if (opts.rawArgs &#x26;&#x26; (argsIndex = opts.rawArgs.indexOf(&#x27;--&#x27;)) &#x3e;= 0) {
    conf.args = opts.rawArgs.slice(argsIndex + 1);
  }

  var appConf = Common.verifyConfs(conf)[0];

  if (appConf instanceof Error) {
    Common.printError(&#x27;Error while transforming CamelCase args to underscore&#x27;);
    return appConf;
  }

  if (argsIndex == -1)
    delete appConf.args;
  if (appConf.name == &#x27;undefined&#x27;)
    delete appConf.name;

  delete appConf.exec_mode;

  if(util.isArray(appConf.watch) &#x26;&#x26; appConf.watch.length === 0) {
    if(!~opts.rawArgs.indexOf(&#x27;--watch&#x27;))
      delete appConf.watch
  }

  return appConf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype._operate" id="apidoc.element.pm2.custom.prototype._operate">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_operate
        <span class="apidocSignatureSpan">(action_name, process_name, envs, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_operate = function (action_name, process_name, envs, cb) {
  var that = this;
  var update_env = false;
  var ret = [];

  // Make sure all options exist

  if (!envs)
    envs = {};

  if (typeof(envs) == &#x27;function&#x27;){
    cb = envs;
    envs = {};
  }

  // Set via env.update (JSON processing)
  if (envs.updateEnv === true)
    update_env = true;

  if (!process.env.PM2_JSON_PROCESSING || envs.commands) {
    envs = that._handleAttributeUpdate(envs);
  }

<span class="apidocCodeCommentSpan">  /**
   * Set current updated configuration if not passed
   */
</span>  if (!envs.current_conf) {
    var _conf = fclone(envs);
    envs = {
      current_conf : _conf
    }

    // Is KM linked?
    envs.current_conf.km_link = that.gl_is_km_linked;
  }

  /**
   * Operate action on specific process id
   */
  function processIds(ids, cb) {
    Common.printOut(conf.PREFIX_MSG + &#x27;Applying action %s on app [%s](ids: %s)&#x27;, action_name, process_name, ids);

    var concurrent_actions = conf.CONCURRENT_ACTIONS;
    if (action_name == &#x27;deleteProcessId&#x27;)
      concurrent_actions = 10;

    async.eachLimit(ids, concurrent_actions, function(id, next) {
      var opts;

      // These functions need extra param to be passed
      if (action_name == &#x27;restartProcessId&#x27; ||
          action_name == &#x27;reloadProcessId&#x27; ||
          action_name == &#x27;softReloadProcessId&#x27;) {
        var new_env = {};

        if (update_env === true) {
          if (conf.PM2_PROGRAMMATIC == true)
            new_env = Common.safeExtend({}, process.env);
          else
            new_env = util._extend({}, process.env);

          Object.keys(envs).forEach(function(k) {
            new_env[k] = envs[k];
          });
        }
        else {
          new_env = envs;
        }

        opts = {
          id  : id,
          env : new_env
        };
      }
      else {
        opts = id;
      }

      that.Client.executeRemote(action_name, opts, function(err, res) {
        if (err) {
          Common.printError(conf.PREFIX_MSG_ERR + &#x27;Process %s not found&#x27;, id);
          return next(&#x27;Process not found&#x27;);
        }

        if (action_name == &#x27;restartProcessId&#x27;) {
          that.Client.notifyGod(&#x27;restart&#x27;, id);
        } else if (action_name == &#x27;deleteProcessId&#x27;) {
          that.Client.notifyGod(&#x27;delete&#x27;, id);
        } else if (action_name == &#x27;stopProcessId&#x27;) {
          that.Client.notifyGod(&#x27;stop&#x27;, id);
        } else if (action_name == &#x27;reloadProcessId&#x27;) {
          that.Client.notifyGod(&#x27;reload&#x27;, id);
        } else if (action_name == &#x27;softReloadProcessId&#x27;) {
          that.Client.notifyGod(&#x27;graceful reload&#x27;, id);
        }

        if (!Array.isArray(res))
          res = [res];

        // Filter return
        res.forEach(function(proc) {
          Common.printOut(conf.PREFIX_MSG + &#x27;[%s](%d) \u2713&#x27;, proc.pm2_env ? proc.pm2_env.name : process_name, id);

          if (!proc.pm2_env) return false;

          ret.push({
            name         : proc.pm2_env.name,
            pm_id        : proc.pm2_env.pm_id,
            status       : proc.pm2_env.status,
            restart_time : proc.pm2_env.restart_time,
            pm2_env : {
              name         : proc.pm2_env.name,
              pm_id        : proc.pm2_env.pm_id,
              status       : proc.pm2_env.status,
              restart_time : proc.pm2_env.restart_time,
              env          : proc.pm2_env.env
            }
          });
        });

        return next();
      });
    }, function(err) {
      if (err) return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
      return cb ? cb(null, ret) : that.speedList();
    });
  }

  if (process_name == &#x27;all&#x27;) {
    that.Client.getAllProcessId(function(err, ids) {
      if (err) {
        Common.printError(err);
        return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
      }
      if (!ids || ids.length === 0) {
        Common.printError(conf.PREFIX_MSG_WARNING + &#x27;No process found&#x27;);
        return cb ? cb(new Error(&#x27;process name not found&#x27;)) : that.exitCli(conf.ERROR_EXIT);
      }

      return processIds(ids, cb);
    });
  }
  // operate using regex ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype._pre_interact" id="apidoc.element.pm2.custom.prototype._pre_interact">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_pre_interact
        <span class="apidocSignatureSpan">(cmd, public_key, machine, info_node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_pre_interact = function (cmd, public_key, machine, info_node) {
  var that = this;

  if (cmd == &#x27;stop&#x27; || cmd == &#x27;kill&#x27;) {
    console.log(chalk.cyan(&#x27;[Keymetrics.io]&#x27;) + &#x27; Stopping agent...&#x27;);
    that.killInteract(function() {
      console.log(chalk.cyan(&#x27;[Keymetrics.io]&#x27;) + &#x27; Stopped&#x27;);
      return process.exit(cst.SUCCESS_EXIT);
    });
    return false;
  }

  if (cmd == &#x27;info&#x27;) {
    console.log(chalk.cyan(&#x27;[Keymetrics.io]&#x27;) + &#x27; Getting agent information...&#x27;);
    that.interactInfos(function(err, infos) {
      if (err) {
        console.error(err.message);
        return that.exitCli(cst.ERROR_EXIT);
      }
      console.log(infos);
      return that.exitCli(cst.SUCCESS_EXIT);
    });
    return false;
  }

  if (cmd == &#x27;delete&#x27;) {
    that.killInteract(function() {
      try {
        fs.unlinkSync(cst.INTERACTION_CONF);
      } catch(e) {
        console.log(chalk.cyan(&#x27;[Keymetrics.io]&#x27;) + &#x27; No interaction config file found&#x27;);
        return process.exit(cst.SUCCESS_EXIT);
      }
      console.log(chalk.cyan(&#x27;[Keymetrics.io]&#x27;) + &#x27; Agent interaction ended&#x27;);
      return process.exit(cst.SUCCESS_EXIT);
    });
    return false;
  }

  if (cmd == &#x27;start&#x27; || cmd == &#x27;restart&#x27;) {
    KMDaemon.launchAndInteract(that._conf, {
      public_key : null,
      secret_key : null,
      machine_name : null,
      info_node : null
    }, function(err, dt) {
      if (err) {
        Common.printError(err);
        return that.exitCli(cst.ERROR_EXIT);
      }
      return that.exitCli(cst.SUCCESS_EXIT);
    });
  }

  if (cmd &#x26;&#x26; !public_key) {
    console.error(chalk.cyan(&#x27;[Keymetrics.io]&#x27;) + &#x27; Command [%s] unknown or missing public key&#x27;, cmd);
    return process.exit(cst.ERROR_EXIT);
  }

  var infos;

  if (!cmd) {
    infos = null;
  }
  else
    infos = {
      public_key : public_key,
      secret_key : cmd,
      machine_name : machine,
      info_node : info_node.infoNode || null
    }

  KMDaemon.launchAndInteract(that._conf, infos, function(err, dt) {
    if (err)
      return that.exitCli(cst.ERROR_EXIT);
    return that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype._pull" id="apidoc.element.pm2.custom.prototype._pull">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_pull
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_pull = function (opts, cb) {
  var that = this;

  var process_name = opts.process_name;
  var reload_type = opts.action;

  printOut(cst.PREFIX_MSG + &#x27;Updating repository for process name %s&#x27;, process_name);

  that.Client.getProcessByName(process_name, function(err, processes) {

    if (processes.length === 0) {
      printError(&#x27;No processes with this name: %s&#x27;, process_name);
      return cb ? cb({msg:&#x27;Process not found: &#x27;+process_name}) : that.exitCli(cst.ERROR_EXIT);
    }

    var proc = processes[0];
    if (!proc.pm2_env.versioning) {
      printOut(cst.PREFIX_MSG + &#x27;No versioning system found for process %s&#x27;, process_name);
      return cb ? cb({success:false, msg: &#x27;No versioning system found for process&#x27;}) : that.exitCli(cst.SUCCESS_EXIT);
    }
    vizion.update({
      folder: proc.pm2_env.versioning.repo_path
    }, function(err, meta) {
      if (err !== null) {
        return cb ? cb({msg:err}) : that.exitCli(cst.ERROR_EXIT);
      }

      if (meta.success === true) {
        getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function (command_list) {
          execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err, res) {
            if (err !== null) {
              printError(err);
              return cb ? cb({msg: meta.output + err}) : that.exitCli(cst.ERROR_EXIT);
            }
            else {
              printOut(cst.PREFIX_MSG + &#x27;Process successfully updated %s&#x27;, process_name);
              printOut(cst.PREFIX_MSG + &#x27;Current commit %s&#x27;, meta.current_revision);
              return that[reload_type](process_name, function(err, procs) {
                if (err &#x26;&#x26; cb) return cb(err);
                if (err) console.error(err);
                return cb ? cb(null, meta.output + res) : that.exitCli(cst.SUCCESS_EXIT);
              });
            }
          });
        });
      }
      else {
        printOut(cst.PREFIX_MSG + &#x27;Already up-to-date or an error occured for app: %s&#x27;, process_name);
        return cb ? cb({success:false, msg : &#x27;Already up to date&#x27;}) : that.exitCli(cst.SUCCESS_EXIT);
      }
      return false;
    });
    return false;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype._pullCommitId" id="apidoc.element.pm2.custom.prototype._pullCommitId">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_pullCommitId
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_pullCommitId = function (opts, cb) {
  this.pullCommitId(opts.pm2_name, opts.commit_id, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype._startJson" id="apidoc.element.pm2.custom.prototype._startJson">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_startJson
        <span class="apidocSignatureSpan">(file, opts, action, pipe, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_startJson = function (file, opts, action, pipe, cb) {
  var config     = {};
  var appConf    = {};
  var deployConf = {};
  var apps_info  = [];
  var that = this;

  if (typeof(cb) === &#x27;undefined&#x27; &#x26;&#x26; typeof(pipe) === &#x27;function&#x27;)
    cb = pipe;

  if (typeof(file) === &#x27;object&#x27;)
    config = file;
  else if (pipe == &#x27;pipe&#x27;)
    config = Common.parseConfig(file, &#x27;pipe&#x27;);
  else {
    var data = null;

    var file_path = path.isAbsolute(file) ? file : path.join(that.cwd, file);

    debug(&#x27;Resolved filepath %s&#x27;, file_path);

    try {
      data = fs.readFileSync(file_path);
    } catch(e) {
      Common.printError(conf.PREFIX_MSG_ERR + &#x27;File &#x27; + file +&#x27; not found&#x27;);
      return cb ? cb(Common.retErr(e)) : that.exitCli(conf.ERROR_EXIT);
    }

    try {
      config = Common.parseConfig(data, file);
    } catch(e) {
      Common.printError(conf.PREFIX_MSG_ERR + &#x27;File &#x27; + file + &#x27; malformated&#x27;);
      console.error(e);
      return cb ? cb(Common.retErr(e)) : that.exitCli(conf.ERROR_EXIT);
    }
  }

  if (config.deploy)
    deployConf = config.deploy;

  if (config.apps)
    appConf = config.apps;
  else
    appConf = config;

  if (!Array.isArray(appConf))
    appConf = [appConf]; //convert to array

  if ((appConf = Common.verifyConfs(appConf)) instanceof Error)
    return cb ? cb(appConf) : that.exitCli(conf.ERROR_EXIT);

  process.env.PM2_JSON_PROCESSING = true;

  // Get App list
  var apps_name = [];
  var proc_list = {};

  appConf.forEach(function(app) {
    if (opts.only &#x26;&#x26; opts.only != app.name)
      return false;
    if (!app.watch &#x26;&#x26; opts.watch &#x26;&#x26; opts.watch === true)
      app.watch = true;
    if (!app.ignore_watch &#x26;&#x26; opts.ignore_watch)
      app.ignore_watch = opts.ignore_watch;
    if (opts.instances &#x26;&#x26; typeof(opts.instances) === &#x27;number&#x27;)
      app.instances = opts.instances;
    if (app.append_env_to_name &#x26;&#x26; opts.env) {
      app.name += (&#x27;-&#x27; + opts.env);
    }
    apps_name.push(app.name);
  });

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, raw_proc_list) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
    }

<span class="apidocCodeCommentSpan">    /**
     * Uniquify in memory process list
     */
</span>    raw_proc_list.forEach(function(proc) {
      proc_list[proc.name] = proc;
    });

    /**
     * Auto detect application already started
     * and act on them depending on action
     */
    async.eachLimit(Object.keys(proc_list), conf.CONCURRENT_ACTIONS, function(proc_name, next) {
      // Skip app name (--only option)
      if (apps_name.indexOf(proc_name) == -1)
        return next();

      if (!(action == &#x27;reloadProcessId&#x27; ||
            action == &#x27;softReloadProcessId&#x27; ||
            action == &#x27;restartProcessId&#x27;))
        throw new Error(&#x27;Wrong action called&#x27;);


      // Get `env` from appConf by name
      async.filter(appConf, function(app, callback){
        callback(app.name == proc_name);
      }, function(apps){
        var envs = apps.map(function(app){
          // Binds env_diff to env and returns it.
          return Common.mergeEnvironmentVariables(app, opts.env, deployConf);
        });

        // Assigns own enumerable properties of all
        // Notice: if people use the same name in different apps,
        //         duplicated envs will be overrode by the last one
        var env = envs.reduce(function(e1, e2){
          return util._extend(e1, e2);
        });

        // When we are processing JSON, allow to keep the new env by default
        env.updateEnv = true;

        // Pass `env` option
        that._operate(action, proc_name, env, function(err, ret) {
          if (err) Common.printError(err);

          // For return
          apps_info = apps_info.concat(ret);

          that.Client.notifyGod(action, proc_name);
          // And Remove from array to spy
          apps_name.splice(apps_name.indexOf(proc_name), 1);
          return next();
        });
      });

    }, function(err) {
      if (err) return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
      if (apps_name.length &#x3e; 0 &#x26;&#x26; action != &#x27;start&#x27;) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype._startScript" id="apidoc.element.pm2.custom.prototype._startScript">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_startScript
        <span class="apidocSignatureSpan">(script, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_startScript = function (script, opts, cb) {
  if (typeof opts == &#x22;function&#x22;) {
    cb = opts;
    opts = {};
  }
  var that = this;

  var app_conf = Config.transCMDToConf(opts);
  var appConf = {};

  if (!!opts.executeCommand)
    app_conf.exec_mode = &#x27;fork&#x27;;
  else if (opts.instances !== undefined)
    app_conf.exec_mode = &#x27;cluster&#x27;;
  else
    app_conf.exec_mode = &#x27;fork&#x27;;

  if (typeof app_conf.name == &#x27;function&#x27;){
    delete app_conf.name;
  }

  delete app_conf.args;

  var argsIndex;

  if (opts.rawArgs &#x26;&#x26; (argsIndex = opts.rawArgs.indexOf(&#x27;--&#x27;)) &#x3e;= 0) {
    app_conf.args = opts.rawArgs.slice(argsIndex + 1);
  }
  else if (opts.scriptArgs) {
    app_conf.args = opts.scriptArgs;
  }

  app_conf.script = script;

  if ((appConf = Common.verifyConfs(app_conf)) instanceof Error)
    return cb ? cb(Common.retErr(appConf)) : that.exitCli(conf.ERROR_EXIT);

  app_conf = appConf[0];

<span class="apidocCodeCommentSpan">  /**
   * If -w option, write configuration to configuration.json file
   */
</span>  if (appConf.write) {
    var dst_path = path.join(process.env.PWD || process.cwd(), app_conf.name + &#x27;-pm2.json&#x27;);
    Common.printOut(conf.PREFIX_MSG + &#x27;Writing configuration to&#x27;, chalk.blue(dst_path));
    // pretty JSON
    try {
      fs.writeFileSync(dst_path, JSON.stringify(app_conf, null, 2));
    } catch (e) {
      console.error(e.stack || e);
    }
  }

  /**
   * If start &#x3c;app_name&#x3e; start/restart application
   */
  function restartExistingProcessName(cb) {
    if (!isNaN(script) ||
        (typeof script === &#x27;string&#x27; &#x26;&#x26; script.indexOf(&#x27;/&#x27;) != -1) ||
        (typeof script === &#x27;string&#x27; &#x26;&#x26; path.extname(script) !== &#x27;&#x27;))
      return cb(null);

    if (script !== &#x27;all&#x27;) {
      that.Client.getProcessIdByName(script, function(err, ids) {
        if (err &#x26;&#x26; cb) return cb(err);
        if (ids.length &#x3e; 0) {
          that._operate(&#x27;restartProcessId&#x27;, script, opts, function(err, list) {
            if (err) return cb(err);
            Common.printOut(conf.PREFIX_MSG + &#x27;Process successfully started&#x27;);
            return cb(true, list);
          });
        }
        else return cb(null);
      });
    }
    else {
      that._operate(&#x27;restartProcessId&#x27;, &#x27;all&#x27;, function(err, list) {
        if (err) return cb(err);
        Common.printOut(conf.PREFIX_MSG + &#x27;Process successfully started&#x27;);
        return cb(true, list);
      });
    }
  }

  function restartExistingProcessId(cb) {
    if (isNaN(script)) return cb(null);

    that._operate(&#x27;restartProcessId&#x27;, script, opts, function(err, list) {
      if (err) return cb(err);
      Common.printOut(conf.PREFIX_MSG + &#x27;Process successfully started&#x27;);
      return cb(true, list);
    });
  }

  /**
   * Restart a process with the same full path
   * Or start it
   */
  function restartExistingProcessPath(cb) {
    that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, procs) {
      if (err) return cb ? cb(new Error(err)) : that.exitCli(conf.ERROR_EXIT);

      var full_path = path.resolve(that.cwd, script);
      var managed_script = null;

      procs.forEach(function(proc) {
        if (proc.pm2_env.pm_exec_path == full_path &#x26;&#x26;
            proc.pm2_env.name == app_conf.name)
          managed_script = proc;
      });

      if (managed_script &#x26;&#x26;
          (managed_script.pm2_env.status == conf.STOPPED_STATUS ||
           managed_script.pm2_env.status == conf.STOPPING_STATUS ||
           managed_script.pm2_env.status == conf.ERRORED_STATUS)) {
        // Restart process if stopped
        var app_name = managed_script.pm2_env.name;

        that._operate(&#x27;restartProcessId&#x27;, app_name, opts, function(err, list) {
          if (err) return cb ? cb(new Error(err)) : that.exitCli(conf.ERROR_EXIT);
          Common.printOut(conf.PREFIX_MSG + &#x27;Process successfully started&#x27;);
          return cb(true, list);
        });
        return false;
      }
      else if (managed_script &#x26;&#x26; !opts.force) {
        Common.printError(conf.PREFIX_MSG_ERR + &#x27;Script already launched, add -f option to force re-execution&#x27;);
        return cb(new Error(&#x27;Script already launched&#x27;));
      }

      var resolved_paths = null;

      try {
        res ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.actionFromJson" id="apidoc.element.pm2.custom.prototype.actionFromJson">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>actionFromJson
        <span class="apidocSignatureSpan">(action, file, opts, jsonVia, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">actionFromJson = function (action, file, opts, jsonVia, cb) {
  var appConf = {};
  var ret_processes = [];
  var that = this;

  //accept programmatic calls
  if (typeof file == &#x27;object&#x27;) {
    cb = typeof jsonVia == &#x27;function&#x27; ? jsonVia : cb;
    appConf = file;
  }
  else if (jsonVia == &#x27;file&#x27;) {
    var data = null;

    try {
      data = fs.readFileSync(file);
    } catch(e) {
      Common.printError(conf.PREFIX_MSG_ERR + &#x27;File &#x27; + file +&#x27; not found&#x27;);
      return cb ? cb(Common.retErr(e)) : that.exitCli(conf.ERROR_EXIT);
    }

    try {
      appConf = Common.parseConfig(data, file);
    } catch(e) {
      Common.printError(conf.PREFIX_MSG_ERR + &#x27;File &#x27; + file + &#x27; malformated&#x27;);
      console.error(e);
      return cb ? cb(Common.retErr(e)) : that.exitCli(conf.ERROR_EXIT);
    }
  } else if (jsonVia == &#x27;pipe&#x27;) {
    appConf = Common.parseConfig(file, &#x27;pipe&#x27;);
  } else {
    Common.printError(&#x27;Bad call to actionFromJson, jsonVia should be one of file, pipe&#x27;);
    return that.exitCli(conf.ERROR_EXIT);
  }

  // Backward compatibility
  if (appConf.apps)
    appConf = appConf.apps;

  if (!Array.isArray(appConf))
    appConf = [appConf];

  if ((appConf = Common.verifyConfs(appConf)) instanceof Error)
    return cb ? cb(appConf) : that.exitCli(conf.ERROR_EXIT);

  async.eachLimit(appConf, conf.CONCURRENT_ACTIONS, function(proc, next1) {
    var name = &#x27;&#x27;;
    var new_env;

    if (!proc.name)
      name = path.basename(proc.script);
    else
      name = proc.name;

    if (opts.only &#x26;&#x26; opts.only != name)
      return process.nextTick(next1);

    if (opts &#x26;&#x26; opts.env)
      new_env = Common.mergeEnvironmentVariables(proc, opts.env);
    else
      new_env = Common.mergeEnvironmentVariables(proc);

    that.Client.getProcessIdByName(name, function(err, ids) {
      if (err) {
        Common.printError(err);
        return next1();
      }
      if (!ids) return next1();

      async.eachLimit(ids, conf.CONCURRENT_ACTIONS, function(id, next2) {
        var opts = {};

        //stopProcessId could accept options to?
        if (action == &#x27;restartProcessId&#x27;) {
          opts = {id : id, env : new_env};
        } else {
          opts = id;
        }

        that.Client.executeRemote(action, opts, function(err, res) {
          ret_processes.push(res);
          if (err) {
            Common.printError(err);
            return next2();
          }

          if (action == &#x27;restartProcessId&#x27;) {
            that.Client.notifyGod(&#x27;restart&#x27;, id);
          } else if (action == &#x27;deleteProcessId&#x27;) {
            that.Client.notifyGod(&#x27;delete&#x27;, id);
          } else if (action == &#x27;stopProcessId&#x27;) {
            that.Client.notifyGod(&#x27;stop&#x27;, id);
          }

          Common.printOut(conf.PREFIX_MSG + &#x27;[%s](%d) \u2713&#x27;, name, id);
          return next2();
        });
      }, function(err) {
        return next1(null, ret_processes);
      });
    });
  }, function(err) {
    if (cb) return cb(null, ret_processes);
    else return that.speedList();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.backward" id="apidoc.element.pm2.custom.prototype.backward">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>backward
        <span class="apidocSignatureSpan">(process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function (process_name, cb) {
  var that = this;
  printOut(cst.PREFIX_MSG + &#x27;Downgrading to previous commit repository for process name %s&#x27;, process_name);

  that.Client.getProcessByName(process_name, function(err, processes) {

    if (processes.length === 0) {
      printError(&#x27;No processes with this name: %s&#x27;, process_name);
      return cb ? cb({msg:&#x27;Process not found: &#x27;+process_name}) : that.exitCli(cst.ERROR_EXIT);
    }

    var proc = processes[0];

    if (proc.pm2_env.versioning === undefined ||
        proc.pm2_env.versioning === null)
      return cb({msg : &#x27;Versioning unknown&#x27;});

    vizion.prev({
      folder: proc.pm2_env.versioning.repo_path
    }, function(err, meta) {
      if (err)
        return cb ? cb({msg:err, data : meta}) : that.exitCli(cst.ERROR_EXIT);

      if (meta.success !== true) {
        printOut(cst.PREFIX_MSG + &#x27;No versioning system found for process %s&#x27;, process_name);
        return cb ? cb({msg:err, data : meta}) : that.exitCli(cst.ERROR_EXIT);;
      }

      getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function (command_list) {
        execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err, res) {
          if (err !== null) {
            vizion.next({folder: proc.pm2_env.versioning.repo_path}, function(err2, meta2) {
              printError(err);
              return cb ? cb({msg: meta.output + err}) : that.exitCli(cst.ERROR_EXIT);
            });
            return false;
          }

          printOut(cst.PREFIX_MSG + &#x27;Process successfully updated %s&#x27;, process_name);
          printOut(cst.PREFIX_MSG + &#x27;Current commit %s&#x27;, meta.current_revision);
          that.reload(process_name, function(err, procs) {
            if (err) return cb(err);
            return cb ? cb(null, meta.output + res) : that.exitCli(cst.SUCCESS_EXIT);
          });
        });
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.close" id="apidoc.element.pm2.custom.prototype.close">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  var that = this;

  if (!cb) cb = function() {};

  this.Client.close(function(err, data) {
    debug(&#x27;The session lasted %ds&#x27;, (new Date() - that.start_timer) / 1000);
    return cb(err, data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.conf" id="apidoc.element.pm2.custom.prototype.conf">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>conf
        <span class="apidocSignatureSpan">(key, value, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conf = function (key, value, cb) {
  var that = this;

  if (typeof(value) === &#x27;function&#x27;) {
    cb = value;
    value = null;
  }

  // If key + value = set
  if (key &#x26;&#x26; value) {
    that.set(key, value, function(err) {
      if (err)
        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
      return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
    });
  }
  // If only key = get
  else if (key) {
    that.get(key, function(err, data) {
      if (err)
        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
      return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
    });
  }
  else {
    displayConf(function(err, data) {
      if (err)
        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
      return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.connect" id="apidoc.element.pm2.custom.prototype.connect">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>connect
        <span class="apidocSignatureSpan">(noDaemon, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function (noDaemon, cb) {
  var that = this;
  this.start_timer = new Date();

  if (typeof(cb) == &#x27;undefined&#x27;) {
    cb = noDaemon;
    noDaemon = false;
  } else if (noDaemon === true) {
    // Backward compatibility with PM2 1.x
    this.Client.daemon_mode = false;
    this.daemon_mode = false;
  }

  this.Client.start(function(err, meta) {
    if (err)
      return cb(err);

    if (meta.new_pm2_instance == false &#x26;&#x26; that.daemon_mode === true)
      return cb(err, meta);

    // If new pm2 instance has been popped
    // Lauch all modules
    Modularizer.launchAll(that, function(err_mod) {
      return cb(err, meta);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.dashboard" id="apidoc.element.pm2.custom.prototype.dashboard">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>dashboard
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dashboard = function (cb) {
  var that = this;

  var Dashboard = require(&#x27;./Dashboard&#x27;);

  if (cb) return cb(new Error(&#x27;Dashboard cant be called programmatically&#x27;));

  Dashboard.init();

  this.Client.launchBus(function (err, bus) {
    if (err) {
        console.error(&#x27;Error launchBus: &#x27; + err);
        that.exitCli(cst.ERROR_EXIT);
    }
    bus.on(&#x27;log:*&#x27;, function(type, data) {
      Dashboard.log(type, data);
    })
  });

  process.on(&#x27;SIGINT&#x27;, function() {
    this.Client.disconnectBus(function() {
      process.exit(cst.SUCCESS_EXIT);
    });
  });

  function launchDashboard() {
    that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
      if (err) {
        console.error(&#x27;Error retrieving process list: &#x27; + err);
        that.exitCli(cst.ERROR_EXIT);
      }

      Dashboard.refresh(list);

      setTimeout(function() {
        launchDashboard();
      }, 800);
    });
  }

  launchDashboard();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.deepUpdate" id="apidoc.element.pm2.custom.prototype.deepUpdate">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>deepUpdate
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deepUpdate = function (cb) {
  var that = this;

  Common.printOut(conf.PREFIX_MSG + &#x27;Updating PM2...&#x27;);

  var exec = require(&#x27;shelljs&#x27;).exec;
  var child = exec(&#x22;npm i -g pm2@latest; pm2 update&#x22;, {async : true});

  child.stdout.on(&#x27;end&#x27;, function() {
    Common.printOut(conf.PREFIX_MSG + &#x27;PM2 successfully updated&#x27;);
    cb ? cb(null, {success:true}) : that.exitCli(conf.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.delete" id="apidoc.element.pm2.custom.prototype.delete">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>delete
        <span class="apidocSignatureSpan">(process_name, jsonVia, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (process_name, jsonVia, cb) {
  var that = this;

  if (typeof(jsonVia) === &#x22;function&#x22;) {
    cb = jsonVia;
    jsonVia = null;
  }
  if (typeof(process_name) === &#x22;number&#x22;) {
    process_name = process_name.toString();
  }

  if (jsonVia == &#x27;pipe&#x27;)
    return that.actionFromJson(&#x27;deleteProcessId&#x27;, process_name, commander, &#x27;pipe&#x27;, cb);
  if (Common.isConfigFile(process_name))
    return that.actionFromJson(&#x27;deleteProcessId&#x27;, process_name, commander, &#x27;file&#x27;, cb);
  else
    that._operate(&#x27;deleteProcessId&#x27;, process_name, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.deleteModule" id="apidoc.element.pm2.custom.prototype.deleteModule">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>deleteModule
        <span class="apidocSignatureSpan">(module_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteModule = function (module_name, cb) {
  var that = this;

  var found_proc = [];

  this.Client.getAllProcess(function(err, procs) {
    if (err) {
      Common.printError(&#x27;Error retrieving process list: &#x27; + err);
      return cb(Common.retErr(err));
    }

    procs.forEach(function(proc) {
      if (proc.pm2_env.name == module_name &#x26;&#x26; proc.pm2_env.pmx_module) {
        found_proc.push(proc.pm_id);
      }
    });

    if (found_proc.length == 0)
      return cb();

    that._operate(&#x27;deleteProcessId&#x27;, found_proc[0], function(err) {
      if (err) return cb(Common.retErr(err));
      Common.printOut(&#x27;In memory process deleted&#x27;);
      return cb();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.deploy" id="apidoc.element.pm2.custom.prototype.deploy">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>deploy
        <span class="apidocSignatureSpan">(file, commands, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deploy = function (file, commands, cb) {
  var that = this;

  if (file == &#x27;help&#x27;) {
    deployHelper();
    return cb ? cb() : that.exitCli(cst.SUCCESS_EXIT);
  }

  var args = commands.rawArgs;
  var env;

  args.splice(0, args.indexOf(&#x27;deploy&#x27;) + 1);

  // Find ecosystem file by default
  if (!Common.isConfigFile(file)) {
    env = args[0];
    file = Utility.whichFileExists([&#x27;ecosystem.config.js&#x27;, &#x27;ecosystem.json&#x27;, &#x27;ecosystem.json5&#x27;, &#x27;package.json&#x27;]);

    if (!file) {
      Common.printError(&#x27;Not any default deployment file exists&#x27;);
      return cb ? cb(&#x27;Not any default ecosystem file present&#x27;) : that.exitCli(cst.ERROR_EXIT);
    }
  }
  else
    env = args[1];

  var json_conf = null;

  try {
    json_conf = Common.parseConfig(fs.readFileSync(file), file);
  } catch (e) {
    Common.printError(e);
    return cb ? cb(e) : that.exitCli(cst.ERROR_EXIT);
  }

  if (!env) {
    deployHelper();
    return cb ? cb() : that.exitCli(cst.SUCCESS_EXIT);
  }

  if (!json_conf.deploy || !json_conf.deploy[env]) {
    Common.printError(&#x27;%s environment is not defined in %s file&#x27;, env, file);
    return cb ? cb(&#x27;%s environment is not defined in %s file&#x27;) : that.exitCli(cst.ERROR_EXIT);
  }

  if (!json_conf.deploy[env][&#x27;post-deploy&#x27;]) {
    json_conf.deploy[env][&#x27;post-deploy&#x27;] = &#x27;pm2 startOrRestart &#x27; + file + &#x27; --env &#x27; + env;
  }

  Deploy.deployForEnv(json_conf.deploy, env, args, function(err, data) {
    if (err) {
      Common.printError(&#x27;Deploy failed&#x27;);
      return cb ? cb(err) : that.exitCli(cst.ERROR_EXIT);
    }
    Common.printOut(&#x27;--&#x3e; Success&#x27;);
    return cb ? cb(null, data) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.describe" id="apidoc.element.pm2.custom.prototype.describe">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>describe
        <span class="apidocSignatureSpan">(pm2_id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">describe = function (pm2_id, cb) {
  var that = this;

  var found_proc = [];

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(&#x27;Error retrieving process list: &#x27; + err);
      that.exitCli(conf.ERROR_EXIT);
    }

    list.forEach(function(proc) {
      if ((!isNaN(pm2_id)    &#x26;&#x26; proc.pm_id == pm2_id) ||
          (typeof(pm2_id) === &#x27;string&#x27; &#x26;&#x26; proc.name  == pm2_id)) {
        found_proc.push(proc);
      }
    });

    if (found_proc.length === 0) {
      Common.printError(conf.PREFIX_MSG_WARNING + &#x27;%s doesn\&#x27;t exist&#x27;, pm2_id);
      return cb ? cb(null, []) : that.exitCli(conf.ERROR_EXIT);
    }

    if (!cb) {
      found_proc.forEach(function(proc) {
        UX.describeTable(proc);
      });
    }

    return cb ? cb(null, found_proc) : that.exitCli(conf.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.destroy" id="apidoc.element.pm2.custom.prototype.destroy">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>destroy
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (cb) {
  var exec = require(&#x27;shelljs&#x27;).exec;
  var that = this;

  debug(&#x27;Killing and deleting current deamon&#x27;);

  this.killDaemon(function() {
    var cmd = &#x27;rm -rf &#x27; + that.pm2_home;
    var test_path = path.join(that.pm2_home, &#x27;module_conf.json&#x27;);
    var test_path_2 = path.join(that.pm2_home, &#x27;pm2.pid&#x27;);

    if (that.pm2_home.indexOf(&#x27;.pm2&#x27;) &#x3e; -1)
      return cb(new Error(&#x27;Destroy is not a allowed method on .pm2&#x27;));

    if (fs.accessSync) {
      fs.access(test_path, fs.R_OK, function(err) {
        if (err) return cb(err);
        debug(&#x27;Deleting temporary folder %s&#x27;, that.pm2_home);
        exec(cmd, cb);
      });
      return false;
    }

    // Support for Node 0.10
    fs.exists(test_path, function(exist) {
      if (exist) {
        debug(&#x27;Deleting temporary folder %s&#x27;, that.pm2_home);
        exec(cmd, cb);
      }
      return cb(null);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.disconnect" id="apidoc.element.pm2.custom.prototype.disconnect">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>disconnect
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function (cb) {
  var that = this;

  if (!cb) cb = function() {};

  this.Client.close(function(err, data) {
    debug(&#x27;The session lasted %ds&#x27;, (new Date() - that.start_timer) / 1000);
    return cb(err, data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.dockerMode" id="apidoc.element.pm2.custom.prototype.dockerMode">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>dockerMode
        <span class="apidocSignatureSpan">(script, opts, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dockerMode = function (script, opts, mode) {
  var self = this;
  handleExit(self, opts, mode);

  if (mode == &#x27;distribution&#x27; &#x26;&#x26; !opts.imageName) {
    return console.error(chalk.bold.red(&#x27;--image-name [name] option is missing&#x27;));
  }

  var template;
  var app_path, main_script;
  var image_name;

  image_name   = opts.imageName || crypto.randomBytes(6).toString(&#x27;hex&#x27;);

  if (script.indexOf(&#x27;/&#x27;) &#x3e; -1) {
    app_path  = path.join(process.cwd(), path.dirname(script));
    main_script = path.basename(script);
  }
  else {
    app_path  = process.cwd();
    main_script = script;
  }

  checkDockerSetup()
    .then(function() {
      /////////////////////////
      // Generate Dockerfile //
      /////////////////////////
      return new Promise(function(resolve, reject) {
        var docker_filepath = path.join(process.cwd(), &#x27;Dockerfile&#x27;);

        fs.stat(docker_filepath, function(err, stat) {
          if (err) {
            // Dockerfile does not exists, generate one
            console.log(chalk.blue.bold(&#x27;Generating new Dockerfile&#x27;));
            return resolve(generateDockerfile(docker_filepath, main_script, mode));
          }
          return resolve(switchDockerFile(docker_filepath, main_script, mode));
        });
      });
    })
    .then(function(_template) {
      template = _template;
      return Promise.resolve();
    })
    .then(function() {
      //////////////////
      // Docker build //
      //////////////////

      var docker_build = util.format(&#x27;docker build -t %s -f %s&#x27;,
                                     image_name,
                                     template.Dockerfile_path);

      if (opts.fresh == true)
        docker_build += &#x27; --no-cache&#x27;;
      docker_build += &#x27; .&#x27;;

      console.log();
      fmt.sep();
      fmt.title(&#x27;Building Boot System&#x27;);
      fmt.field(&#x27;Type&#x27;, chalk.cyan.bold(&#x27;Docker&#x27;));
      fmt.field(&#x27;Mode&#x27;, mode);
      fmt.field(&#x27;Image name&#x27;, image_name);
      fmt.field(&#x27;Docker build command&#x27;, docker_build);
      fmt.field(&#x27;Dockerfile path&#x27;, template.Dockerfile_path);
      fmt.sep();

      return pspawn(docker_build);
    })
    .then(function() {
      ////////////////
      // Docker run //
      ////////////////

      var docker_run = &#x27;docker run --net host&#x27;;

      if (opts.daemon == true)
        docker_run += &#x27; -d&#x27;;
      if (mode != &#x27;distribution&#x27;)
        docker_run += util.format(&#x27; -v %s:/var/app -v /var/app/node_modules&#x27;, app_path);
      docker_run += &#x27; &#x27; + image_name;

      console.log();
      fmt.sep();
      fmt.title(&#x27;Booting&#x27;);
      fmt.field(&#x27;Type&#x27;, chalk.cyan.bold(&#x27;Docker&#x27;));
      fmt.field(&#x27;Mode&#x27;, mode);
      fmt.field(&#x27;Image name&#x27;, image_name);
      fmt.field(&#x27;Docker run command&#x27;, docker_run);
      fmt.field(&#x27;Docker main CMD&#x27;, template.CMD);
      fmt.field(&#x27;CWD&#x27;, app_path);
      fmt.sep();
      return pspawn(docker_run);
    })
    .then(function() {
      console.log(chalk.blue.bold(&#x27;&#x3e;&#x3e;&#x3e; Leaving Docker instance uuid=%s&#x27;), image_name);
      self.disconnect();
      return Promise.resolve();
    })
    .catch(function(err) {
      console.log();
      console.log(chalk.grey(&#x27;Raw error=&#x27;, err.message));
      self.disconnect();
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.dump" id="apidoc.element.pm2.custom.prototype.dump">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>dump
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dump = function (cb) {
  var env_arr = [];
  var that = this;


  Common.printOut(cst.PREFIX_MSG + &#x27;Saving current process list...&#x27;);

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(&#x27;Error retrieving process list: &#x27; + err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }

<span class="apidocCodeCommentSpan">    /**
     * Description
     * @method fin
     * @param {} err
     * @return
     */
</span>    function fin(err) {
      try {
        fs.writeFileSync(cst.DUMP_FILE_PATH, JSON.stringify(env_arr, &#x27;&#x27;, 2));
      } catch (e) {
        console.error(e.stack || e);
        Common.printOut(cst.PREFIX_MSG_ERR + &#x27;Failed to save dump file in %s&#x27;, cst.DUMP_FILE_PATH);
        return that.exitCli(cst.ERROR_EXIT);
      }
      if (cb) return cb(null, {success:true});

      Common.printOut(cst.PREFIX_MSG + &#x27;Successfully saved in %s&#x27;, cst.DUMP_FILE_PATH);
      return that.exitCli(cst.SUCCESS_EXIT);
    }

    (function ex(apps) {
      if (!apps[0]) return fin(null);
      delete apps[0].pm2_env.instances;
      delete apps[0].pm2_env.pm_id;
      if (!apps[0].pm2_env.pmx_module)
        env_arr.push(apps[0].pm2_env);
      apps.shift();
      return ex(apps);
    })(list);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.exitCli" id="apidoc.element.pm2.custom.prototype.exitCli">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>exitCli
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exitCli = function (code) {
  var that = this;

  // Do nothing if PM2 called programmatically (also in speedlist)
  if (conf.PM2_PROGRAMMATIC &#x26;&#x26; process.env.PM2_USAGE != &#x27;CLI&#x27;) return false;

  KMDaemon.disconnectRPC(function() {
    that.Client.close(function() {
      code = code || 0;
      // Safe exits process after all streams are drained.
      // file descriptor flag.
      var fds = 0;
      // exits process when stdout (1) and sdterr(2) are both drained.
      function tryToExit() {
        if ((fds &#x26; 1) &#x26;&#x26; (fds &#x26; 2)) {
          debug(&#x27;This command took %ds to execute&#x27;, (new Date() - that.start_timer) / 1000);
          process.exit(code);
        }
      }

      [process.stdout, process.stderr].forEach(function(std) {
        var fd = std.fd;
        if (!std.bufferSize) {
          // bufferSize equals 0 means current stream is drained.
          fds = fds | fd;
        } else {
          // Appends nothing to the std queue, but will trigger `tryToExit` event on `drain`.
          std.write &#x26;&#x26; std.write(&#x27;&#x27;, function() {
            fds = fds | fd;
            tryToExit();
          });
        }
        // Does not write anything more.
        delete std.write;
      });
      tryToExit();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.flush" id="apidoc.element.pm2.custom.prototype.flush">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>flush
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function (cb) {
  var that = this;

  Common.printOut(cst.PREFIX_MSG + &#x27;Flushing &#x27; + cst.PM2_LOG_FILE_PATH);
  fs.closeSync(fs.openSync(cst.PM2_LOG_FILE_PATH, &#x27;w&#x27;));

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }
    list.forEach(function(l) {
      Common.printOut(cst.PREFIX_MSG + &#x27;Flushing&#x27;);
      Common.printOut(cst.PREFIX_MSG + l.pm2_env.pm_out_log_path);
      Common.printOut(cst.PREFIX_MSG + l.pm2_env.pm_err_log_path);

      if (l.pm2_env.pm_log_path) {
        Common.printOut(cst.PREFIX_MSG + l.pm2_env.pm_log_path);
        fs.closeSync(fs.openSync(l.pm2_env.pm_log_path, &#x27;w&#x27;));
      }

      fs.closeSync(fs.openSync(l.pm2_env.pm_out_log_path, &#x27;w&#x27;));
      fs.closeSync(fs.openSync(l.pm2_env.pm_err_log_path, &#x27;w&#x27;));
    });
    Common.printOut(cst.PREFIX_MSG + &#x27;Logs flushed&#x27;);
    return cb ? cb(null, list) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.forward" id="apidoc.element.pm2.custom.prototype.forward">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>forward
        <span class="apidocSignatureSpan">(process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (process_name, cb) {
  var that = this;
  printOut(cst.PREFIX_MSG + &#x27;Updating to next commit repository for process name %s&#x27;, process_name);

  that.Client.getProcessByName(process_name, function(err, processes) {

    if (processes.length === 0) {
      printError(&#x27;No processes with this name: %s&#x27;, process_name);
      return cb ? cb({msg:&#x27;Process not found: &#x27;+process_name}) : that.exitCli(cst.ERROR_EXIT);
    }

    var proc = processes[0];
    if (proc.pm2_env.versioning) {
      vizion.next({folder: proc.pm2_env.versioning.repo_path}, function(err, meta) {
        if (err !== null)
          return cb ? cb({msg:err}) : that.exitCli(cst.ERROR_EXIT);
        if (meta.success === true) {
          getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function (command_list) {
            execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err, res) {
              if (err !== null)
              {
                vizion.prev({folder: proc.pm2_env.versioning.repo_path}, function(err2, meta2) {
                  printError(err);
                  return cb ? cb({msg:meta.output + err}) : that.exitCli(cst.ERROR_EXIT);
                });
              }
              else {
                printOut(cst.PREFIX_MSG + &#x27;Process successfully updated %s&#x27;, process_name);
                printOut(cst.PREFIX_MSG + &#x27;Current commit %s&#x27;, meta.current_revision);
                that.reload(process_name, function(err, procs) {
                  if (err) return cb(err);
                  return cb ? cb(null, meta.output + res) : that.exitCli(cst.SUCCESS_EXIT);
                });
              }
            });
          });
        }
        else {
          printOut(cst.PREFIX_MSG + &#x27;Already up-to-date or an error occured: %s&#x27;, process_name);
          return cb ? cb(null, {success:meta.success}) : that.exitCli(cst.SUCCESS_EXIT);
        }
      });
    }
    else {
      printOut(cst.PREFIX_MSG + &#x27;No versioning system found for process %s&#x27;, process_name);
      return cb ? cb({success:false, msg: &#x27;No versioning system found&#x27;}) : that.exitCli(cst.SUCCESS_EXIT);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.generateDockerfile" id="apidoc.element.pm2.custom.prototype.generateDockerfile">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>generateDockerfile
        <span class="apidocSignatureSpan">(script, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateDockerfile = function (script, opts) {
  var docker_filepath = path.join(process.cwd(), &#x27;Dockerfile&#x27;);
  var that = this;

  fs.stat(docker_filepath, function(err, stat) {
    if (err || opts.force == true) {
      generateDockerfile(docker_filepath, script, &#x27;development&#x27;)
        .then(function() {
          console.log(chalk.bold(&#x27;New Dockerfile generated in current folder&#x27;));
          console.log(chalk.bold(&#x27;You can now run\n$ pm2 docker:dev &#x3c;file|config&#x3e;&#x27;));
          return that.exitCli(cst.SUCCESS_EXIT);
        });
      return false;
    }
    console.log(chalk.red.bold(&#x27;Dockerfile already exists in this folder, use --force if you want to replace it&#x27;));
    that.exitCli(cst.ERROR_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.generateModuleSample" id="apidoc.element.pm2.custom.prototype.generateModuleSample">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>generateModuleSample
        <span class="apidocSignatureSpan">(app_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateModuleSample = function (app_name, cb) {
  var that = this;

  Modularizer.generateSample(app_name, function(err, data) {
    if (err)
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    return cb ? cb(null, data) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.generateSample" id="apidoc.element.pm2.custom.prototype.generateSample">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>generateSample
        <span class="apidocSignatureSpan">(mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateSample = function (mode) {
  var that = this;
  var templatePath;

  if (mode == &#x27;simple&#x27;)
    templatePath = path.join(cst.TEMPLATE_FOLDER, cst.APP_CONF_TPL_SIMPLE);
  else
    templatePath = path.join(cst.TEMPLATE_FOLDER, cst.APP_CONF_TPL);

  var sample = fs.readFileSync(templatePath);
  var dt     = sample.toString();
  var f_name = &#x27;ecosystem.config.js&#x27;;
		var pwd = process.env.PWD || process.cwd();

  try {
    fs.writeFileSync(path.join(pwd, f_name), dt);
  } catch (e) {
    console.error(e.stack || e);
    return that.exitCli(cst.ERROR_EXIT);
  }
  Common.printOut(&#x27;File %s generated&#x27;, path.join(pwd, f_name));
  that.exitCli(cst.SUCCESS_EXIT);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.get" id="apidoc.element.pm2.custom.prototype.get">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>get
        <span class="apidocSignatureSpan">(key, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (key, cb) {
  var that = this;

  if (!key || key == &#x27;all&#x27;) {
    that.displayConf(function(err, data) {
      if (err)
        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
      return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
    });
    return false;
  }
  Configuration.get(key, function(err, data) {
    if (err) {
      console.error(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }
    // pm2 conf module-name
    if (key.indexOf(&#x27;:&#x27;) === -1 &#x26;&#x26; key.indexOf(&#x27;.&#x27;) === -1) {
      displayConf(key, function() {
        return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
      });
      return false;
    }
    // pm2 conf module-name:key
    var module_name, key_name;

    if (key.indexOf(&#x27;:&#x27;) &#x3e; -1) {
      module_name = key.split(&#x27;:&#x27;)[0];
      key_name    = key.split(&#x27;:&#x27;)[1];
    } else if (key.indexOf(&#x27;.&#x27;) &#x3e; -1) {
      module_name = key.split(&#x27;.&#x27;)[0];
      key_name    = key.split(&#x27;.&#x27;)[1];
    }

    Common.printOut(&#x27;Value for module &#x27; + chalk.blue(module_name), &#x27;key &#x27; + chalk.blue(key_name) + &#x27;: &#x27; + chalk.bold.green(data));


    return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.getProcessIdByName" id="apidoc.element.pm2.custom.prototype.getProcessIdByName">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>getProcessIdByName
        <span class="apidocSignatureSpan">(name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProcessIdByName = function (name, cb) {
  var that = this;

  this.Client.getProcessIdByName(name, function(err, id) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
    }
    console.log(id);
    return cb ? cb(null, id) : that.exitCli(conf.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.getVersion" id="apidoc.element.pm2.custom.prototype.getVersion">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>getVersion
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getVersion = function (cb) {
  var that = this;

  that.Client.executeRemote(&#x27;getVersion&#x27;, {}, function(err) {
    return cb ? cb.apply(null, arguments) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.gracefulReload" id="apidoc.element.pm2.custom.prototype.gracefulReload">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>gracefulReload
        <span class="apidocSignatureSpan">(process_name, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gracefulReload = function (process_name, opts, cb) {
  var that = this;

  if (typeof(opts) == &#x22;function&#x22;) {
    cb = opts;
    opts = {};
  }

  //Common.printOut(conf.PREFIX_MSG_WARNING + chalk.bold.yellow(&#x27;Warning gracefulReload will be soon deprecated&#x27;));
  //Common.printOut(conf.PREFIX_MSG_WARNING + chalk.bold.yellow(&#x27;Use http://pm2.keymetrics.io/docs/usage/signals-clean-restart/
instead&#x27;));

  if (Common.isConfigFile(process_name))
    that._startJson(process_name, commander, &#x27;softReloadProcessId&#x27;);
  else {
    if (opts &#x26;&#x26; !opts.updateEnv)
      Common.printOut(IMMUTABLE_MSG);
    that._operate(&#x27;softReloadProcessId&#x27;, process_name, opts, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.install" id="apidoc.element.pm2.custom.prototype.install">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>install
        <span class="apidocSignatureSpan">(module_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function (module_name, cb) {
  var that = this;

  Modularizer.install(this, module_name, function(err, data) {
    if (err) {
      Common.printError(cst.PREFIX_MSG_ERR + (err.message || err));
      return cb ? cb(Common.retErr(err)) : that.speedList(cst.ERROR_EXIT);
    }

    // Check if special module with post_install display
    if (data &#x26;&#x26; data[0] &#x26;&#x26; data[0].pm2_env &#x26;&#x26; data[0].pm2_env.PM2_EXTRA_DISPLAY) {
      return postDisplay.call(that, data[0].pm2_env, cb);
    }
    return cb ? cb(null, data) : that.speedList(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.interact" id="apidoc.element.pm2.custom.prototype.interact">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>interact
        <span class="apidocSignatureSpan">(secret_key, public_key, machine_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interact = function (secret_key, public_key, machine_name, cb) {
  var that = this;

  KMDaemon.launchAndInteract(that._conf, {
    secret_key   : secret_key || null,
    public_key   : public_key || null,
    machine_name : machine_name || null
  }, function(err, dt) {
    if (err) {
      return cb ? cb(err) : that.exitCli(cst.ERROR_EXIT);
    }
    return cb ? cb(null, dt) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.interactInfos" id="apidoc.element.pm2.custom.prototype.interactInfos">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>interactInfos
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interactInfos = function (cb) {
  KMDaemon.getInteractInfo(this._conf, function(err, data) {
    if (err)
      return cb(Common.retErr(err));
    return cb(null, data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.jlist" id="apidoc.element.pm2.custom.prototype.jlist">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>jlist
        <span class="apidocSignatureSpan">(debug)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jlist = function (debug) {
  var that = this;

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(err);
      that.exitCli(conf.ERROR_EXIT);
    }

    if (debug) {
      process.stdout.write(util.inspect(list, false, null, false));
    }
    else {
      process.stdout.write(JSON.stringify(list));
    }

    that.exitCli(conf.SUCCESS_EXIT);

  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.kill" id="apidoc.element.pm2.custom.prototype.kill">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>kill
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kill = function (cb) {
  var that = this;

  var semver = require(&#x27;semver&#x27;);
  Common.printOut(conf.PREFIX_MSG + &#x27;Stopping PM2...&#x27;);

  that.Client.executeRemote(&#x27;notifyKillPM2&#x27;, {}, function() {});

  that.getVersion(function(err, data) {
    if (!err &#x26;&#x26; semver.lt(data, &#x27;1.1.0&#x27;)) {
      // Disable action command output if upgrading from &#x3c; 1.1.0 PM2
      // This is in order to avoid duplicated output
      process.env.PM2_SILENT = &#x27;true&#x27;;
      console.log(conf.PREFIX_MSG + &#x27;Killing processes...&#x27;);
    }

    that.killAllModules(function() {
      that._operate(&#x27;deleteProcessId&#x27;, &#x27;all&#x27;, function(err, list) {
        Common.printOut(conf.PREFIX_MSG + &#x27;All processes have been stopped and deleted&#x27;);
        process.env.PM2_SILENT = &#x27;false&#x27;;

        that.killInteract(function(err, data) {
          that.Client.killDaemon(function(err, res) {
            if (err) Common.printError(err);
            Common.printOut(conf.PREFIX_MSG + &#x27;PM2 stopped&#x27;);
            return cb ? cb(err, res) : that.exitCli(conf.SUCCESS_EXIT);
          });
        });
      });
    });

  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.killAllModules" id="apidoc.element.pm2.custom.prototype.killAllModules">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>killAllModules
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killAllModules = function (cb) {
  var that = this;

  this.Client.getAllModulesId(function(err, modules_id) {
    async.forEachLimit(modules_id, 1, function(id, next) {
      that._operate(&#x27;deleteProcessId&#x27;, id, next);
    }, function() {
      return cb ? cb() : false;
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.killDaemon" id="apidoc.element.pm2.custom.prototype.killDaemon">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>killDaemon
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killDaemon = function (cb) {
  var that = this;

  var semver = require(&#x27;semver&#x27;);
  Common.printOut(conf.PREFIX_MSG + &#x27;Stopping PM2...&#x27;);

  that.Client.executeRemote(&#x27;notifyKillPM2&#x27;, {}, function() {});

  that.getVersion(function(err, data) {
    if (!err &#x26;&#x26; semver.lt(data, &#x27;1.1.0&#x27;)) {
      // Disable action command output if upgrading from &#x3c; 1.1.0 PM2
      // This is in order to avoid duplicated output
      process.env.PM2_SILENT = &#x27;true&#x27;;
      console.log(conf.PREFIX_MSG + &#x27;Killing processes...&#x27;);
    }

    that.killAllModules(function() {
      that._operate(&#x27;deleteProcessId&#x27;, &#x27;all&#x27;, function(err, list) {
        Common.printOut(conf.PREFIX_MSG + &#x27;All processes have been stopped and deleted&#x27;);
        process.env.PM2_SILENT = &#x27;false&#x27;;

        that.killInteract(function(err, data) {
          that.Client.killDaemon(function(err, res) {
            if (err) Common.printError(err);
            Common.printOut(conf.PREFIX_MSG + &#x27;PM2 stopped&#x27;);
            return cb ? cb(err, res) : that.exitCli(conf.SUCCESS_EXIT);
          });
        });
      });
    });

  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.killInteract" id="apidoc.element.pm2.custom.prototype.killInteract">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>killInteract
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killInteract = function (cb) {
  var that = this;
  KMDaemon.killInteractorDaemon(that._conf, function(err) {
    return cb ? cb(Common.retErr(&#x27;Interactor not launched&#x27;)) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.launchBus" id="apidoc.element.pm2.custom.prototype.launchBus">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>launchBus
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">launchBus = function (cb) {
  this.Client.launchBus(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.launchModules" id="apidoc.element.pm2.custom.prototype.launchModules">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>launchModules
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">launchModules = function (cb) {
  Modularizer.launchAll(this, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.list" id="apidoc.element.pm2.custom.prototype.list">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>list
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">list = function (opts, cb) {
  var that = this;

  if (typeof(opts) == &#x27;function&#x27;) {
    cb = opts;
    opts = null;
  }

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
    }

    if (opts &#x26;&#x26; opts.rawArgs &#x26;&#x26; opts.rawArgs.indexOf(&#x27;--watch&#x27;) &#x3e; -1) {
      var moment = require(&#x27;moment&#x27;);
      function show() {
        process.stdout.write(&#x27;\033[2J&#x27;);
        process.stdout.write(&#x27;\033[0f&#x27;);
        console.log(&#x27;Last refresh: &#x27;, moment().format(&#x27;LTS&#x27;));
        that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
          UX.dispAsTable(list, null);
        });
      }

      show();
      setInterval(show, 900);
      return false;
    }

    return cb ? cb(null, list) : that.speedList();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.logrotate" id="apidoc.element.pm2.custom.prototype.logrotate">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>logrotate
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logrotate = function (opts, cb) {
  var that = this;

  if (process.getuid() != 0) {
    return exec(&#x27;whoami&#x27;, function(err, stdout, stderr) {
      Common.printError(cst.PREFIX_MSG + &#x27;You have to run this command as root. Execute the following command:&#x27;);
      Common.printError(cst.PREFIX_MSG + chalk.grey(&#x27;      sudo env PATH=$PATH:&#x27; + path.dirname(process.execPath) + &#x27; pm2 logrotate
 -u &#x27; + stdout.trim()));

      cb ? cb(Common.retErr(&#x27;You have to run this with elevated rights&#x27;)) : that.exitCli(cst.ERROR_EXIT);
    });
  }

  if (!fs.existsSync(&#x27;/etc/logrotate.d&#x27;)) {
    Common.printError(cst.PREFIX_MSG + &#x27;/etc/logrotate.d does not exist we can not copy the default configuration.&#x27;);
    return cb ? cb(Common.retErr(&#x27;/etc/logrotate.d does not exist&#x27;)) : that.exitCli(cst.ERROR_EXIT);
  }

  var templatePath = path.join(cst.TEMPLATE_FOLDER, cst.LOGROTATE_SCRIPT);
  Common.printOut(cst.PREFIX_MSG + &#x27;Getting logrorate template &#x27; + templatePath);
  var script = fs.readFileSync(templatePath, {encoding: &#x27;utf8&#x27;});

  var user = opts.user || &#x27;root&#x27;;

  script = script.replace(/%HOME_PATH%/g, cst.PM2_ROOT_PATH)
    .replace(/%USER%/g, user);

  try {
    fs.writeFileSync(&#x27;/etc/logrotate.d/pm2-&#x27;+user, script);
  } catch (e) {
    console.error(e.stack || e);
  }

  Common.printOut(cst.PREFIX_MSG + &#x27;Logrotate configuration added to /etc/logrotate.d/pm2&#x27;);
  return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.monit" id="apidoc.element.pm2.custom.prototype.monit">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>monit
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">monit = function (cb) {
  var that = this;

  var Monit = require(&#x27;./Monit.js&#x27;);

  if (cb) return cb(new Error(&#x27;Monit cant be called programmatically&#x27;));

  Monit.init();

  function launchMonitor() {
    that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
      if (err) {
        console.error(&#x27;Error retrieving process list: &#x27; + err);
        that.exitCli(conf.ERROR_EXIT);
      }

      Monit.refresh(list);

      setTimeout(function() {
        launchMonitor();
      }, 400);
    });
  }

  launchMonitor();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.msgProcess" id="apidoc.element.pm2.custom.prototype.msgProcess">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>msgProcess
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">msgProcess = function (opts, cb) {
  var that = this;

  that.Client.executeRemote(&#x27;msgProcess&#x27;, opts, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.multiset" id="apidoc.element.pm2.custom.prototype.multiset">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>multiset
        <span class="apidocSignatureSpan">(serial, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiset = function (serial, cb) {
  var that = this;

  Configuration.multiset(serial, function(err, data) {
    if (err)
      return cb ? cb({success:false, err:err}) : that.exitCli(cst.ERROR_EXIT);

    var values = [];
    var key = serial.match(/(?:[^ &#x22;]+|&#x22;[^&#x22;]*&#x22;)+/g)[0];

    if (key.indexOf(&#x27;.&#x27;) &#x3e; -1)
      values = key.split(&#x27;.&#x27;);

    if (key.indexOf(&#x27;:&#x27;) &#x3e; -1)
      values = key.split(&#x27;:&#x27;);

    if (values &#x26;&#x26; values.length &#x3e; 1) {
      // The first element is the app name (module_conf.json)
      var app_name = values[0];

      process.env.PM2_PROGRAMMATIC = &#x27;true&#x27;;
      that.restart(app_name, {
        updateEnv : true
      }, function(err, data) {
        process.env.PM2_PROGRAMMATIC = &#x27;false&#x27;;
        if (!err)
          Common.printOut(cst.PREFIX_MSG + &#x27;Module %s restarted&#x27;, app_name);
        displayConf(app_name, function() {
          return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
        });
      });
      return false;
    }
    displayConf(app_name, function() {
      return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
    });

  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.ping" id="apidoc.element.pm2.custom.prototype.ping">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>ping
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ping = function (cb) {
  var that = this;

  that.Client.executeRemote(&#x27;ping&#x27;, {}, function(err, res) {
    if (err) {
      Common.printError(err);
      return cb ? cb(new Error(err)) : that.exitCli(cst.ERROR_EXIT);
    }
    Common.printOut(res);
    return cb ? cb(null, res) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.printLogs" id="apidoc.element.pm2.custom.prototype.printLogs">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>printLogs
        <span class="apidocSignatureSpan">(id, lines, raw, timestamp, exclusive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">printLogs = function (id, lines, raw, timestamp, exclusive) {
  var that = this;
  var files_list = [];

  // If no argument is given, we stream logs for all running apps
  id = id || &#x27;all&#x27;;
  lines = lines !== undefined ? lines : 20;
  lines = lines &#x3c; 0 ? -(lines) : lines;

  // Avoid duplicates and check if path is different from &#x27;/dev/null&#x27;
  var pushIfUnique = function(entry) {
    var exists = false;

    if (entry.path.toLowerCase
        &#x26;&#x26; entry.path.toLowerCase() !== &#x27;/dev/null&#x27;) {

      files_list.some(function(file) {
        if (file.path === entry.path)
          exists = true;
        return exists;
      });

      if (exists)
        return;

      files_list.push(entry);
    }
  }

  // Get the list of all running apps
  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(err);
      that.exitCli(cst.ERROR_EXIT);
    }

    if (lines &#x3c;= 0) {
      return that.exitCli(cst.SUCCESS_EXIT)
    }

    Common.printOut(chalk.bold.grey(util.format.call(this, &#x27;[TAILING] Tailing last %d lines for [%s] process%s (change the value
 with --lines option)&#x27;, lines, id, id === &#x27;all&#x27; ? &#x27;es&#x27; : &#x27;&#x27;)));

    // Populate the array `files_list` with the paths of all files we need to tail
    list.forEach(function(proc) {
      if (proc.pm2_env &#x26;&#x26; (id === &#x27;all&#x27; ||
                           proc.pm2_env.name == id ||
                           proc.pm2_env.pm_id == id)) {
        if (proc.pm2_env.pm_out_log_path &#x26;&#x26; exclusive !== &#x27;err&#x27;)
          pushIfUnique({
            path     : proc.pm2_env.pm_out_log_path,
            app_name :proc.pm2_env.pm_id + &#x27;|&#x27; + proc.pm2_env.name,
            type     : &#x27;out&#x27;});
        if (proc.pm2_env.pm_err_log_path &#x26;&#x26; exclusive !== &#x27;out&#x27;)
          pushIfUnique({
            path     : proc.pm2_env.pm_err_log_path,
            app_name : proc.pm2_env.pm_id + &#x27;|&#x27; + proc.pm2_env.name,
            type     : &#x27;err&#x27;
          });
      }
    });

    if (!raw &#x26;&#x26; (id === &#x27;all&#x27; || id === &#x27;PM2&#x27;) &#x26;&#x26; exclusive === false) {
      Log.tail([{
        path     : cst.PM2_LOG_FILE_PATH,
        app_name : &#x27;PM2&#x27;,
        type     : &#x27;PM2&#x27;
      }], lines, raw, function() {
        Log.tail(files_list, lines, raw, function() {
          that.exitCli(cst.SUCCESS_EXIT);
        });
      });
    }
    else {
      Log.tail(files_list, lines, raw, function() {
        that.exitCli(cst.SUCCESS_EXIT);
      });
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.profilePM2" id="apidoc.element.pm2.custom.prototype.profilePM2">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>profilePM2
        <span class="apidocSignatureSpan">(command, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">profilePM2 = function (command, cb) {
  var that = this;
  var moment = require(&#x27;moment&#x27;);
  var file = path.join(process.cwd(), moment().format(&#x27;dd-HH:mm:ss&#x27;) + &#x27;.cpuprofile&#x27;);

  if (command == &#x27;start&#x27;) {
    that.Client.executeRemote(&#x27;profileStart&#x27;, {
    }, function(err) {
      if (err) {
        console.error(err);
        return that.exitCli(1);
      }
      console.log(&#x27;CPU profiling started, type pm2 profile stop once finished&#x27;);
      return cb ? cb.apply(null, arguments) : that.exitCli(cst.SUCCESS_EXIT);
    });
  }
  else if (command == &#x27;stop&#x27;) {
    that.Client.executeRemote(&#x27;profileStop&#x27;, {
      pwd : file
    }, function(err) {
      if (err) {
        console.error(err);
        return that.exitCli(1);
      }
      console.log(&#x27;CPU profile in %s&#x27;, file);
      return cb ? cb.apply(null, arguments) : that.exitCli(cst.SUCCESS_EXIT);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.publish" id="apidoc.element.pm2.custom.prototype.publish">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>publish
        <span class="apidocSignatureSpan">(module_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publish = function (module_name, cb) {
  var that = this;

  Modularizer.publish(function(err, data) {
    if (err)
      return cb ? cb(Common.retErr(err)) : that.speedList(cst.ERROR_EXIT);
    return cb ? cb(null, data) : that.speedList(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.pullAndGracefulReload" id="apidoc.element.pm2.custom.prototype.pullAndGracefulReload">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullAndGracefulReload
        <span class="apidocSignatureSpan">(process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pullAndGracefulReload = function (process_name, cb) {
  this._pull({process_name: process_name, action: &#x27;gracefulReload&#x27;}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.pullAndReload" id="apidoc.element.pm2.custom.prototype.pullAndReload">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullAndReload
        <span class="apidocSignatureSpan">(process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pullAndReload = function (process_name, cb) {
  this._pull({process_name: process_name, action: &#x27;reload&#x27;}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.pullAndRestart" id="apidoc.element.pm2.custom.prototype.pullAndRestart">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullAndRestart
        <span class="apidocSignatureSpan">(process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pullAndRestart = function (process_name, cb) {
  this._pull({process_name: process_name, action: &#x27;reload&#x27;}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.pullCommitId" id="apidoc.element.pm2.custom.prototype.pullCommitId">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullCommitId
        <span class="apidocSignatureSpan">(process_name, commit_id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pullCommitId = function (process_name, commit_id, cb) {
  var reload_type = &#x27;reload&#x27;;
  var that = this;

  printOut(cst.PREFIX_MSG + &#x27;Updating repository for process name %s&#x27;, process_name);

  that.Client.getProcessByName(process_name, function(err, processes) {

    if (processes.length === 0) {
      printError(&#x27;No processes with this name: %s&#x27;, process_name);
      return cb ? cb({msg:&#x27;Process not found: &#x27; + process_name}) : that.exitCli(cst.ERROR_EXIT);
    }

    var proc = processes[0];
    if (proc.pm2_env.versioning) {
      vizion.isUpToDate({folder: proc.pm2_env.versioning.repo_path}, function(err, meta) {
        if (err !== null)
          return cb ? cb({msg:err}) : that.exitCli(cst.ERROR_EXIT);
        vizion.revertTo(
          {revision: commit_id,
           folder: proc.pm2_env.versioning.repo_path},
          function(err2, meta2) {
            if (!err2 &#x26;&#x26; meta2.success) {
              getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function (command_list) {
                execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err, res) {
                  if (err !== null)
                  {
                    printError(err);
                    return cb ? cb({msg:err}) : that.exitCli(cst.ERROR_EXIT);
                  }
                  else {
                    printOut(cst.PREFIX_MSG + &#x27;Process successfully updated %s&#x27;, process_name);
                    printOut(cst.PREFIX_MSG + &#x27;Current commit %s&#x27;, commit_id);
                    return that[reload_type](process_name, cb);
                  }
                });
              });
            }
            else {
              printOut(cst.PREFIX_MSG + &#x27;Already up-to-date or an error occured: %s&#x27;, process_name);
              return cb ? cb(null, {success:meta.success}) : that.exitCli(cst.SUCCESS_EXIT);
            }
          });
      });
    }
    else {
      printOut(cst.PREFIX_MSG + &#x27;No versioning system found for process %s&#x27;, process_name);
      return cb ? cb(null, {success:false}) : that.exitCli(cst.SUCCESS_EXIT);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.reload" id="apidoc.element.pm2.custom.prototype.reload">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>reload
        <span class="apidocSignatureSpan">(process_name, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reload = function (process_name, opts, cb) {
  var that = this;

  if (typeof(opts) == &#x22;function&#x22;) {
    cb = opts;
    opts = {};
  }

  if (Common.isConfigFile(process_name))
    that._startJson(process_name, opts, &#x27;reloadProcessId&#x27;);
  else {
    if (opts &#x26;&#x26; !opts.updateEnv)
      Common.printOut(IMMUTABLE_MSG);
    that._operate(&#x27;reloadProcessId&#x27;, process_name, opts, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.reloadLogs" id="apidoc.element.pm2.custom.prototype.reloadLogs">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>reloadLogs
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reloadLogs = function (cb) {
  var that = this;

  Common.printOut(&#x27;Reloading all logs...&#x27;);
  that.Client.executeRemote(&#x27;reloadLogs&#x27;, {}, function(err, logs) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }
    Common.printOut(&#x27;All logs reloaded&#x27;);
    return cb ? cb(null, logs) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.remote" id="apidoc.element.pm2.custom.prototype.remote">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>remote
        <span class="apidocSignatureSpan">(command, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remote = function (command, opts, cb) {
  var that = this;

  that[command](opts.name, function(err_cmd, ret) {
    if (err_cmd)
      console.error(err_cmd);
    console.log(&#x27;Command %s finished&#x27;, command);
    return cb(err_cmd, ret);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.remoteV2" id="apidoc.element.pm2.custom.prototype.remoteV2">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>remoteV2
        <span class="apidocSignatureSpan">(command, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteV2 = function (command, opts, cb) {
  var that = this;

  if (that[command].length == 1)
    return that[command](cb);

  opts.args.push(cb);
  return that[command].apply(this, opts.args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.reset" id="apidoc.element.pm2.custom.prototype.reset">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>reset
        <span class="apidocSignatureSpan">(process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function (process_name, cb) {
  var that = this;

  function processIds(ids, cb) {
    async.eachLimit(ids, conf.CONCURRENT_ACTIONS, function(id, next) {
      that.Client.executeRemote(&#x27;resetMetaProcessId&#x27;, id, function(err, res) {
        if (err) console.error(err);
        Common.printOut(conf.PREFIX_MSG + &#x27;Resetting meta for process id %d&#x27;, id);
        return next();
      });
    }, function(err) {
      if (err) return cb(Common.retErr(err));
      return cb ? cb(null, {success:true}) : that.speedList();
    });
  }

  if (process_name == &#x27;all&#x27;) {
    that.Client.getAllProcessId(function(err, ids) {
      if (err) {
        Common.printError(err);
        return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
      }
      return processIds(ids, cb);
    });
  }
  else if (isNaN(process_name)) {
    that.Client.getProcessIdByName(process_name, function(err, ids) {
      if (err) {
        Common.printError(err);
        return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
      }
      if (ids.length === 0) {
        Common.printError(&#x27;Unknown process name&#x27;);
        return cb ? cb(new Error(&#x27;Unknown process name&#x27;)) : that.exitCli(conf.ERROR_EXIT);
      }
      return processIds(ids, cb);
    });
  } else {
    processIds([process_name], cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.restart" id="apidoc.element.pm2.custom.prototype.restart">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>restart
        <span class="apidocSignatureSpan">(cmd, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restart = function (cmd, opts, cb) {
  if (typeof(opts) == &#x22;function&#x22;) {
    cb = opts;
    opts = {};
  }
  var that = this;

  if (typeof(cmd) === &#x27;number&#x27;)
    cmd = cmd.toString();

  if (cmd == &#x22;-&#x22;) {
    // Restart from PIPED JSON
    process.stdin.resume();
    process.stdin.setEncoding(&#x27;utf8&#x27;);
    process.stdin.on(&#x27;data&#x27;, function (param) {
      process.stdin.pause();
      that.actionFromJson(&#x27;restartProcessId&#x27;, param, opts, &#x27;pipe&#x27;, cb);
    });
  }
  else if (Common.isConfigFile(cmd) || typeof(cmd) === &#x27;object&#x27;)
    that._startJson(cmd, opts, &#x27;restartProcessId&#x27;, cb);
  else {
    if (opts &#x26;&#x26; !opts.updateEnv)
      Common.printOut(IMMUTABLE_MSG);
    that._operate(&#x27;restartProcessId&#x27;, cmd, opts, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.resurrect" id="apidoc.element.pm2.custom.prototype.resurrect">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>resurrect
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resurrect = function (cb) {
  var apps = {};
  var that = this;

  Common.printOut(cst.PREFIX_MSG + &#x27;Restoring processes located in %s&#x27;, cst.DUMP_FILE_PATH);

  try {
    apps = fs.readFileSync(cst.DUMP_FILE_PATH);
  } catch(e) {
    Common.printError(cst.PREFIX_MSG_ERR + &#x27;No processes saved; DUMP file doesn\&#x27;t exist&#x27;);
    // if (cb) return cb(Common.retErr(e));
    // else return that.exitCli(cst.ERROR_EXIT);
    return that.speedList();
  }

  var processes = Common.parseConfig(apps, &#x27;none&#x27;);

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(err);
      return that.exitCli(1);
    }

    var current = [];
    var target = [];

    list.forEach(function(app) {
      if (!current[app.name])
        current[app.name] = 0;
      current[app.name]++;
    });

    processes.forEach(function(app) {
      if (!target[app.name])
        target[app.name] = 0;
      target[app.name]++;
    });

    var tostart = Object.keys(target).filter(function(i) {
      return Object.keys(current).indexOf(i) &#x3c; 0;
    })

    async.eachLimit(processes, cst.CONCURRENT_ACTIONS, function(app, next) {
      if (tostart.indexOf(app.name) == -1)
        return next();
      that.Client.executeRemote(&#x27;prepare&#x27;, app, function(err, dt) {
        if (err)
          Common.printError(err);
        else
          Common.printOut(cst.PREFIX_MSG + &#x27;Process %s restored&#x27;, app.pm_exec_path);
        next();
      });
    }, function(err) {
      return cb ? cb(null, apps) : that.speedList();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.scale" id="apidoc.element.pm2.custom.prototype.scale">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>scale
        <span class="apidocSignatureSpan">(app_name, number, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scale = function (app_name, number, cb) {
  var that = this;

  function addProcs(proc, value, cb) {
    (function ex(proc, number) {
      if (number-- === 0) return cb();
      Common.printOut(conf.PREFIX_MSG + &#x27;Scaling up application&#x27;);
      that.Client.executeRemote(&#x27;duplicateProcessId&#x27;, proc.pm2_env.pm_id, ex.bind(this, proc, number));
    })(proc, number);
  }

  function rmProcs(procs, value, cb) {
    var i = 0;

    (function ex(procs, number) {
      if (number++ === 0) return cb();
      that._operate(&#x27;deleteProcessId&#x27;, procs[i++].pm2_env.pm_id, ex.bind(this, procs, number));
    })(procs, number);
  }

  function end() {
    return cb ? cb(null, {success:true}) : that.speedList();
  }

  this.Client.getProcessByName(app_name, function(err, procs) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
    }

    if (!procs || procs.length === 0) {
      Common.printError(conf.PREFIX_MSG_ERR + &#x27;Application %s not found&#x27;, app_name);
      return cb ? cb(new Error(&#x27;App not found&#x27;)) : that.exitCli(conf.ERROR_EXIT);
    }

    if (procs[0].pm2_env.exec_mode !== &#x27;cluster_mode&#x27;) {
      Common.printError(conf.PREFIX_MSG_ERR + &#x27;Application %s is not in cluster mode&#x27;, app_name);
      return cb ? cb(new Error(&#x27;App not in cluster mode&#x27;)) : that.exitCli(conf.ERROR_EXIT);
    }

    var proc_number = procs.length;

    if (typeof(number) === &#x27;string&#x27; &#x26;&#x26; number.indexOf(&#x27;+&#x27;) &#x3e;= 0) {
      number = parseInt(number, 10);
      return addProcs(procs[0], number, end);
    }
    else if (typeof(number) === &#x27;string&#x27; &#x26;&#x26; number.indexOf(&#x27;-&#x27;) &#x3e;= 0) {
      number = parseInt(number, 10);
      return rmProcs(procs[0], number, end);
    }
    else {
      number = parseInt(number, 10);
      number = number - proc_number;

      if (number &#x3c; 0)
        return rmProcs(procs, number, end);
      else if (number &#x3e; 0)
        return addProcs(procs[0], number, end);
      else {
        Common.printError(conf.PREFIX_MSG_ERR + &#x27;Nothing to do&#x27;);
        return cb ? cb(new Error(&#x27;Same process number&#x27;)) : that.exitCli(conf.ERROR_EXIT);
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.sendDataToProcessId" id="apidoc.element.pm2.custom.prototype.sendDataToProcessId">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>sendDataToProcessId
        <span class="apidocSignatureSpan">(proc_id, packet, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendDataToProcessId = function (proc_id, packet, cb) {
  var that = this;

  packet.id = proc_id;

  that.Client.executeRemote(&#x27;sendDataToProcessId&#x27;, packet, function(err, res) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }
    Common.printOut(&#x27;successfully sent data to process&#x27;);
    return cb ? cb(null, res) : that.speedList();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.sendSignalToProcessId" id="apidoc.element.pm2.custom.prototype.sendSignalToProcessId">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>sendSignalToProcessId
        <span class="apidocSignatureSpan">(signal, process_id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendSignalToProcessId = function (signal, process_id, cb) {
  var that = this;

  that.Client.executeRemote(&#x27;sendSignalToProcessId&#x27;, {
    signal : signal,
    process_id : process_id
  }, function(err, list) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }
    Common.printOut(&#x27;successfully sent signal %s to process id %s&#x27;, signal, process_id);
    return cb ? cb(null, list) : that.speedList();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.sendSignalToProcessName" id="apidoc.element.pm2.custom.prototype.sendSignalToProcessName">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>sendSignalToProcessName
        <span class="apidocSignatureSpan">(signal, process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendSignalToProcessName = function (signal, process_name, cb) {
  var that = this;

  that.Client.executeRemote(&#x27;sendSignalToProcessName&#x27;, {
    signal : signal,
    process_name : process_name
  }, function(err, list) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }
    Common.printOut(&#x27;successfully sent signal %s to process name %s&#x27;, signal, process_name);
    return cb ? cb(null, list) : that.speedList();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.serve" id="apidoc.element.pm2.custom.prototype.serve">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>serve
        <span class="apidocSignatureSpan">(target_path, port, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serve = function (target_path, port, opts, cb) {
  var that = this;
  var servePort = process.env.PM2_SERVE_PORT || port || 8080;
  var servePath = path.resolve(process.env.PM2_SERVE_PATH || target_path || &#x27;.&#x27;);

  var filepath = path.resolve(path.dirname(module.filename), &#x27;./Serve.js&#x27;);

  if (!opts.name || typeof(opts.name) == &#x27;function&#x27;)
    opts.name = &#x27;static-page-server-&#x27; + servePort;
  if (!opts.env)
    opts.env = {};
  opts.env.PM2_SERVE_PORT = servePort;
  opts.env.PM2_SERVE_PATH = servePath;
  opts.cwd = servePath;

  this.start(filepath, opts,  function (err, res) {
    if (err) {
      Common.printError(cst.PREFIX_MSG_ERR + &#x27;Error while trying to serve : &#x27; + err.message || err);
      return cb ? cb(err) : that.speedList(cst.ERROR_EXIT);
    }
    Common.printOut(cst.PREFIX_MSG + &#x27;Serving &#x27; + servePath + &#x27; on port &#x27; + servePort);
    return cb ? cb(null, res) : that.speedList();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.set" id="apidoc.element.pm2.custom.prototype.set">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>set
        <span class="apidocSignatureSpan">(key, value, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (key, value, cb) {
  var that = this;

<span class="apidocCodeCommentSpan">  /**
   * Specific when setting pm2 password
   * Used for restricted remote actions
   * Also alert Interactor that password has been set
   */
</span>  if (key.indexOf(&#x27;pm2:passwd&#x27;) &#x3e; -1) {
    value = Password.generate(value);
    Configuration.set(key, value, function(err) {
      if (err)
        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
      InteractorDaemonizer.launchRPC(that._conf, function(err) {
        if (err) {
          displayConf(&#x27;pm2&#x27;, function() {
            return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
          });
          return false;
        }
        InteractorDaemonizer.rpc.passwordSet(function() {
          InteractorDaemonizer.disconnectRPC(function() {
            displayConf(&#x27;pm2&#x27;, function() {
              return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
            });
          });
        });
        return false;
      });
    });
    return false;
  }

  /**
   * Set value
   */
  Configuration.set(key, value, function(err) {
    if (err)
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);

    var values = [];

    if (key.indexOf(&#x27;.&#x27;) &#x3e; -1)
      values = key.split(&#x27;.&#x27;);

    if (key.indexOf(&#x27;:&#x27;) &#x3e; -1)
      values = key.split(&#x27;:&#x27;);

    if (values &#x26;&#x26; values.length &#x3e; 1) {
      // The first element is the app name (module_conf.json)
      var app_name = values[0];

      process.env.PM2_PROGRAMMATIC = &#x27;true&#x27;;
      that.restart(app_name, {
        updateEnv : true
      }, function(err, data) {
        process.env.PM2_PROGRAMMATIC = &#x27;false&#x27;;
        if (!err)
          Common.printOut(cst.PREFIX_MSG + &#x27;Module %s restarted&#x27;, app_name);
        displayConf(app_name, function() {
          return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
        });
      });
      return false;
    }
    displayConf(null, function() {
      return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.snapshotPM2" id="apidoc.element.pm2.custom.prototype.snapshotPM2">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>snapshotPM2
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">snapshotPM2 = function (cb) {
  var that = this;
  var moment = require(&#x27;moment&#x27;);
  var file = path.join(process.cwd(), moment().format(&#x27;dd-HH:mm:ss&#x27;) + &#x27;.heapsnapshot&#x27;);

  that.Client.executeRemote(&#x27;snapshotPM2&#x27;, {
    pwd : file
  }, function(err) {
    if (err) {
      console.error(err);
      return that.exitCli(1);
    }
    console.log(&#x27;Heapdump in %s&#x27;, file);
    return cb ? cb.apply(null, arguments) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.speedList" id="apidoc.element.pm2.custom.prototype.speedList">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>speedList
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">speedList = function (code) {
  var that = this;

  // Do nothing if PM2 called programmatically and not called from CLI (also in exitCli)
  if (conf.PM2_PROGRAMMATIC &#x26;&#x26; process.env.PM2_USAGE != &#x27;CLI&#x27;) return false;

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      if (gl_retry == 0) {
        gl_retry += 1;
        return setTimeout(that.speedList.bind(that), 1400);
      }
      console.error(&#x27;Error retrieving process list: %s.\nA process seems to be on infinite loop, retry in 5 seconds&#x27;,err);
      return that.exitCli(conf.ERROR_EXIT);
    }
    if (process.stdout.isTTY === false) {
      UX.miniDisplay(list);
    }
    else if (commander.miniList &#x26;&#x26; !commander.silent)
      UX.miniDisplay(list);
    else if (!commander.silent) {
      if (that.gl_interact_infos) {
        Common.printOut(chalk.green.bold(&#x27;&#x27;) + &#x27; Agent Online | Dashboard Access: &#x27; + chalk.bold(&#x27;https://app.keymetrics.io/#/r
/%s&#x27;) + &#x27; | Server name: %s&#x27;, that.gl_interact_infos.public_key, that.gl_interact_infos.machine_name);
      }
      UX.dispAsTable(list, that.gl_interact_infos);
      Common.printOut(chalk.white.italic(&#x27; Use `pm2 show &#x3c;id|name&#x3e;` to get more details about an app&#x27;));
    }

    if (that.Client.daemon_mode == false) {
      Common.printOut(&#x27;[--no-daemon] Continue to stream logs&#x27;);
      Common.printOut(&#x27;[--no-daemon] Exit on target PM2 exit pid=&#x27; + fs.readFileSync(conf.PM2_PID_FILE_PATH).toString());
      global._auto_exit = true;
      return that.streamLogs(&#x27;all&#x27;, 0, false, &#x27;HH:mm:ss&#x27;, false);
    }
    else if (commander.attach === true) {
      return that.streamLogs(&#x27;all&#x27;, 0, false, null, false);
    }
    else {
      return that.exitCli(code ? code : conf.SUCCESS_EXIT);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.start" id="apidoc.element.pm2.custom.prototype.start">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>start
        <span class="apidocSignatureSpan">(cmd, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (cmd, opts, cb) {
  if (typeof(opts) == &#x22;function&#x22;) {
    cb = opts;
    opts = {};
  }
  if (!opts)
    opts = {};

  var that = this;

  if (util.isArray(opts.watch) &#x26;&#x26; opts.watch.length === 0)
    opts.watch = (opts.rawArgs ? !!~opts.rawArgs.indexOf(&#x27;--watch&#x27;) : !!~process.argv.indexOf(&#x27;--watch&#x27;)) || false;

  if (Common.isConfigFile(cmd) || (typeof(cmd) === &#x27;object&#x27;))
    that._startJson(cmd, opts, &#x27;restartProcessId&#x27;, cb);
  else
    that._startScript(cmd, opts, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.startup" id="apidoc.element.pm2.custom.prototype.startup">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>startup
        <span class="apidocSignatureSpan">(platform, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startup = function (platform, opts, cb) {
  var that = this;
  var actual_platform = detectInitSystem();
  var user = (opts.user || process.env.USER);
  var service_name = &#x27;pm2-&#x27; + user;
  var launchd_service_name = &#x27;pm2.&#x27; + user;

  if (!platform)
    platform = actual_platform;
  else if (actual_platform &#x26;&#x26; actual_platform !== platform) {
    console.log(&#x27;-----------------------------------------------------------&#x27;)
    console.log(&#x27; PM2 detected &#x27; + actual_platform + &#x27; but you precised &#x27; + platform)
    console.log(&#x27; Please verify that your choice is indeed your init system&#x27;)
    console.log(&#x27; If you arent sure, just run : pm2 startup&#x27;)
    console.log(&#x27;-----------------------------------------------------------&#x27;)
  }
  if (platform == null)
    throw new Error(&#x27;Init system not found&#x27;);

  if (!cb) {
    cb = function(err, data) {
      if (err)
        return that.exitCli(cst.ERROR_EXIT);
      return that.exitCli(cst.SUCCESS_EXIT);
    }
  }

  if (process.getuid() != 0) {
    return isNotRoot(platform, opts, cb);
  }

  var destination;
  var commands;
  var template;

  function getTemplate(type) {
    return fs.readFileSync(path.join(__dirname, &#x27;..&#x27;, &#x27;templates/init-scripts&#x27;, type + &#x27;.tpl&#x27;), {encoding: &#x27;utf8&#x27;});
  }

  switch(platform) {
  case &#x27;ubuntu&#x27;:
  case &#x27;centos&#x27;:
  case &#x27;arch&#x27;:
  case &#x27;oracle&#x27;:
  case &#x27;systemd&#x27;:
    template = getTemplate(&#x27;systemd&#x27;);
    destination = &#x27;/etc/systemd/system/&#x27; + service_name + &#x27;.service&#x27;;
    commands = [
      &#x27;chmod +x &#x27; + destination,
      &#x27;systemctl enable &#x27; + service_name,
      &#x27;systemctl start &#x27; + service_name,
      &#x27;systemctl daemon-reload&#x27;,
      &#x27;systemctl status &#x27; + service_name
    ];
    break;
  case &#x27;ubuntu14&#x27;:
  case &#x27;ubuntu12&#x27;:
  case &#x27;upstart&#x27;:
    template = getTemplate(&#x27;upstart&#x27;);
    destination = &#x27;/etc/init.d/&#x27; + service_name;
    commands = [
      &#x27;chmod +x &#x27; + destination,
      &#x27;mkdir -p /var/lock/subsys&#x27;,
      &#x27;touch /var/lock/subsys/&#x27; + service_name,
      &#x27;update-rc.d &#x27; + service_name + &#x27; defaults&#x27;
    ];
    break;
  case &#x27;systemv&#x27;:
  case &#x27;amazon&#x27;:
  case &#x27;centos6&#x27;:
    template = getTemplate(&#x27;upstart&#x27;);
    destination = &#x27;/etc/init.d/&#x27; + service_name;
    commands = [
      &#x27;chmod +x &#x27; + destination,
      &#x27;mkdir -p /var/lock/subsys&#x27;,
      &#x27;touch /var/lock/subsys/&#x27; + service_name,
      &#x27;chkconfig --add &#x27; + service_name,
      &#x27;chkconfig &#x27; + service_name + &#x27; on&#x27;,
      &#x27;initctl list&#x27;
    ];
    break;
  case &#x27;macos&#x27;:
  case &#x27;darwin&#x27;:
  case &#x27;launchd&#x27;:
    template = getTemplate(&#x27;launchd&#x27;);
    destination = path.join(process.env.HOME, &#x27;Library/LaunchAgents/&#x27; + launchd_service_name + &#x27;.plist&#x27;);
    commands = [
      &#x27;launchctl load -w &#x27; + destination
    ]
    break;
  case &#x27;freebsd&#x27;:
  case &#x27;rcd&#x27;:
    template = getTemplate(&#x27;rcd&#x27;);
    destination = &#x27;/etc/rc.d/&#x27; + service_name;
    commands = [
      &#x27;chmod +x &#x27; + destination,
      &#x27;echo &#x22;pm2_enable=YES&#x22; &#x3e;&#x3e; /etc/rc.conf&#x27;
    ];
    break;
  case &#x27;openrc&#x27;:
    template = getTemplate(&#x27;openrc&#x27;);
    destination = &#x27;/etc/init.d/&#x27; + service_name;
    commands = [
      &#x27;chmod +x &#x27; + destination,
	      &#x27;rc-update add &#x27; + service_name + &#x27; default&#x27;
    ];
    break;
  default:
    throw new Error(&#x27;Unknown platform / init system name&#x27;);
  }

<span class="apidocCodeCommentSpan">  /**
   * 4# Replace template variable value
   */
</span>  template = template.replace(/%PM2_PATH%/g, process.mainModule.filename)
    .replace(/%NODE_PATH%/g, path.dirname(process.execPath))
    .replace(/%USER%/g, user)
    .replace(/%HOME_PATH%/g, opts.hp ? path.resolve(opts.hp, &#x27;.pm2&#x27;) : cst.PM2_ROOT_PATH);

  console.log(chalk.bold(&#x27;Platform&#x27;), platform);
  console.log(chalk.bold(&#x27;Template&#x27;));
  console.log(template);
  console.log(chalk.bold(&#x27;Target path&#x27;));
  console.log(destination);
  console.log(chalk.bold(&#x27;Command list&#x27;));
  console.log(commands);

  Common.printOut(cst.PREFIX_MSG + &#x27;Writing init configuration in &#x27; + destination);
  try {
    fs.writeFileSync(destination, template);
  } catch (e) {
    console.error(cst.PREFIX_MSG_ERR + &#x27;Failure when trying to write startup script&#x27;);
    console.error(e.message || e);
    return cb(e);
  }

  Common.printOut(cst. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.stop" id="apidoc.element.pm2.custom.prototype.stop">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>stop
        <span class="apidocSignatureSpan">(process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (process_name, cb) {
  var that = this;

  if (typeof(process_name) === &#x27;number&#x27;)
    process_name = process_name.toString();

  if (process_name == &#x22;-&#x22;) {
    process.stdin.resume();
    process.stdin.setEncoding(&#x27;utf8&#x27;);
    process.stdin.on(&#x27;data&#x27;, function (param) {
      process.stdin.pause();
      that.actionFromJson(&#x27;stopProcessId&#x27;, param, commander, &#x27;pipe&#x27;, cb);
    });
  }
  else if (Common.isConfigFile(process_name))
    that.actionFromJson(&#x27;stopProcessId&#x27;, process_name, commander, &#x27;file&#x27;, cb);
  else
    that._operate(&#x27;stopProcessId&#x27;, process_name, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.streamLogs" id="apidoc.element.pm2.custom.prototype.streamLogs">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>streamLogs
        <span class="apidocSignatureSpan">(id, lines, raw, timestamp, exclusive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">streamLogs = function (id, lines, raw, timestamp, exclusive) {
  var that = this;
  var files_list = [];

  // If no argument is given, we stream logs for all running apps
  id = id || &#x27;all&#x27;;
  lines = lines !== undefined ? lines : 20;
  lines = lines &#x3c; 0 ? -(lines) : lines;

  // Avoid duplicates and check if path is different from &#x27;/dev/null&#x27;
  var pushIfUnique = function(entry) {
    var exists = false;

    if (entry.path.toLowerCase
        &#x26;&#x26; entry.path.toLowerCase() !== &#x27;/dev/null&#x27;) {

      files_list.some(function(file) {
        if (file.path === entry.path)
          exists = true;
        return exists;
      });

      if (exists)
        return;

      files_list.push(entry);
    }
  }

  // Get the list of all running apps
  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(err);
      that.exitCli(cst.ERROR_EXIT);
    }

    if (lines === 0 || raw)
      return Log.stream(that.Client, id, raw, timestamp, exclusive);

    Common.printOut(chalk.bold.grey(util.format.call(this, &#x27;[TAILING] Tailing last %d lines for [%s] process%s (change the value
 with --lines option)&#x27;, lines, id, id === &#x27;all&#x27; ? &#x27;es&#x27; : &#x27;&#x27;)));

    // Populate the array `files_list` with the paths of all files we need to tail
    list.forEach(function(proc) {
      if (proc.pm2_env &#x26;&#x26; (id === &#x27;all&#x27; ||
                           proc.pm2_env.name == id ||
                           proc.pm2_env.pm_id == id)) {
        if (proc.pm2_env.pm_out_log_path &#x26;&#x26; exclusive !== &#x27;err&#x27;)
          pushIfUnique({
            path     : proc.pm2_env.pm_out_log_path,
            app_name :proc.pm2_env.pm_id + &#x27;|&#x27; + proc.pm2_env.name,
            type     : &#x27;out&#x27;});
        if (proc.pm2_env.pm_err_log_path &#x26;&#x26; exclusive !== &#x27;out&#x27;)
          pushIfUnique({
            path     : proc.pm2_env.pm_err_log_path,
            app_name : proc.pm2_env.pm_id + &#x27;|&#x27; + proc.pm2_env.name,
            type     : &#x27;err&#x27;
          });
      }
    });

    if (!raw &#x26;&#x26; (id === &#x27;all&#x27; || id === &#x27;PM2&#x27;) &#x26;&#x26; exclusive === false) {
      Log.tail([{
        path     : cst.PM2_LOG_FILE_PATH,
        app_name : &#x27;PM2&#x27;,
        type     : &#x27;PM2&#x27;
      }], lines, raw, function() {
        Log.tail(files_list, lines, raw, function() {
          Log.stream(that.Client, id, raw, timestamp, exclusive);
        });
      });
    }
    else {
      Log.tail(files_list, lines, raw, function() {
        Log.stream(that.Client, id, raw, timestamp, exclusive);
      });
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.trigger" id="apidoc.element.pm2.custom.prototype.trigger">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>trigger
        <span class="apidocSignatureSpan">(pm_id, action_name, params, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trigger = function (pm_id, action_name, params, cb) {
  if (typeof(params) === &#x27;function&#x27;) {
    cb = params;
    params = null;
  }
  var cmd = {
    msg : action_name
  };
  var counter = 0;
  var process_wait_count = 0;
  var that = this;
  var results = [];

  if (params)
    cmd.opts = params;
  if (isNaN(pm_id))
    cmd.name = pm_id;
  else
    cmd.id = pm_id;

  this.launchBus(function(err, bus) {
    bus.on(&#x27;axm:reply&#x27;, function(ret) {
      if (ret.process.name == pm_id || ret.process.pm_id == pm_id) {
        results.push(ret);
        Common.printOut(&#x27;[%s:%s]=%j&#x27;, ret.process.name, ret.process.pm_id, ret.data.return);
        if (++counter == process_wait_count)
          return cb ? cb(null, results) : that.exitCli(cst.SUCCESS_EXIT);
      }
    });

    that.msgProcess(cmd, function(err, data) {
      if (err) {
        Common.printError(err);
        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
      }
      process_wait_count = data.process_count;
      Common.printOut(chalk.bold(&#x27;%s processes have received command %s&#x27;),
                      data.process_count, action_name);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.uninstall" id="apidoc.element.pm2.custom.prototype.uninstall">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>uninstall
        <span class="apidocSignatureSpan">(module_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function (module_name, cb) {
  var that = this;

  Modularizer.uninstall(this, module_name, function(err, data) {
    if (err)
      return cb ? cb(Common.retErr(err)) : that.speedList(cst.ERROR_EXIT);
    return cb ? cb(null, data) : that.speedList(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.uninstallStartup" id="apidoc.element.pm2.custom.prototype.uninstallStartup">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>uninstallStartup
        <span class="apidocSignatureSpan">(platform, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstallStartup = function (platform, opts, cb) {
  var commands;
  var that = this;
  var actual_platform = detectInitSystem();
  var user = opts.user || process.env.USER;
  var service_name = &#x27;pm2-&#x27; + user;
  var launchd_service_name = &#x27;pm2.&#x27; + user;

  if (!platform)
    platform = actual_platform;
  else if (actual_platform &#x26;&#x26; actual_platform !== platform) {
    console.log(&#x27;-----------------------------------------------------------&#x27;)
    console.log(&#x27; PM2 detected &#x27; + actual_platform + &#x27; but you precised &#x27; + platform)
    console.log(&#x27; Please verify that your choice is indeed your init system&#x27;)
    console.log(&#x27; If you arent sure, just run : pm2 startup&#x27;)
    console.log(&#x27;-----------------------------------------------------------&#x27;)
  }
  if (platform === null)
    throw new Error(&#x27;Init system not found&#x27;)

  if (!cb) {
    cb = function(err, data) {
      if (err)
        return that.exitCli(cst.ERROR_EXIT);
      return that.exitCli(cst.SUCCESS_EXIT);
    }
  }

  if (process.getuid() != 0) {
    return isNotRoot(platform, opts, cb);
  }

  if (fs.existsSync(&#x27;/etc/init.d/pm2-init.sh&#x27;)) {
    platform = &#x27;oldsystem&#x27;;
  }

  switch(platform) {
  case &#x27;systemd&#x27;:
    commands = [
      &#x27;systemctl stop &#x27; + service_name,
      &#x27;systemctl disable &#x27; + service_name,
      &#x27;rm /etc/systemd/system/&#x27; + service_name + &#x27;.service&#x27;
    ];
    break;
  case &#x27;systemv&#x27;:
    commands = [
      &#x27;chkconfig &#x27; + service_name + &#x27; off&#x27;,
      &#x27;rm /etc/init.d/&#x27; + service_name
    ];
    break;
  case &#x27;oldsystem&#x27;:
    Common.printOut(cst.PREFIX_MSG + &#x27;Disabling and deleting old startup system&#x27;);
    commands = [
      &#x27;update-rc.d pm2-init.sh disable&#x27;,
      &#x27;update-rc.d -f pm2-init.sh remove&#x27;,
      &#x27;rm /etc/init.d/pm2-init.sh&#x27;
    ];
    break;
  case &#x27;openrc&#x27;:
    commands = [
	      &#x27;/etc/init.d/&#x27; + service_name + &#x27; stop&#x27;,
      &#x27;rc-update delete &#x27; + service_name + &#x27; default&#x27;,
      &#x27;rm /etc/init.d/&#x27; + service_name
    ];
    break;
  case &#x27;upstart&#x27;:
    commands = [
      &#x27;update-rc.d &#x27; + service_name + &#x27; disable&#x27;,
      &#x27;update-rc.d -f &#x27; + service_name + &#x27; remove&#x27;,
      &#x27;rm /etc/init.d/&#x27; + service_name
    ];
    break;
  case &#x27;launchd&#x27;:
    var destination = path.join(process.env.HOME, &#x27;Library/LaunchAgents/&#x27; + launchd_service_name + &#x27;.plist&#x27;);
    commands = [
      &#x27;launchctl remove com.&#x27; + launchd_service_name,
      &#x27;rm &#x27; + destination
    ];
  };

  shelljs.exec(commands.join(&#x27;&#x26;&#x26; &#x27;), function(code, stdout, stderr) {
    console.log(stdout);
    console.log(stderr);
    if (code == 0) {
      Common.printOut(cst.PREFIX_MSG + chalk.bold(&#x27;Init file disabled.&#x27;));
    } else {
      Common.printOut(cst.ERROR_MSG + chalk.bold(&#x27;Return code : &#x27; + code));
    }

    cb(null, {
      commands : commands,
      platform : platform
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.unset" id="apidoc.element.pm2.custom.prototype.unset">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>unset
        <span class="apidocSignatureSpan">(key, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unset = function (key, cb) {
  var that = this;

  Configuration.unset(key, function(err) {
    if (err) {
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }

    displayConf(function() {
      return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.update" id="apidoc.element.pm2.custom.prototype.update">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>update
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (cb) {
  var that = this;

  Common.printOut(&#x27;Be sure to have the latest version by doing `npm install pm2@latest -g` before doing this procedure.&#x27;);

  // Dump PM2 processes
  that.Client.executeRemote(&#x27;notifyKillPM2&#x27;, {}, function() {});

  that.dump(function(err) {
    debug(&#x27;Dumping successfull&#x27;, err);
    that.killDaemon(function() {
      debug(&#x27;------------------ Everything killed&#x27;, arguments);
      that.Client.launchDaemon({interactor:false}, function(err, child) {
        that.Client.launchRPC(function() {
          that.resurrect(function() {
            Common.printOut(chalk.blue.bold(&#x27;&#x3e;&#x3e;&#x3e;&#x3e;&#x3e;&#x3e;&#x3e;&#x3e;&#x3e;&#x3e; PM2 updated&#x27;));
            Modularizer.launchAll(that, function() {
              KMDaemon.launchAndInteract(that._conf, null, function(err, data, interactor_proc) {
                // Interactor error can be skipped here
                return cb ? cb(null, {success:true}) : that.speedList();
              });
            });
          });
        });
      });
    });
  });

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.web" id="apidoc.element.pm2.custom.prototype.web">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>web
        <span class="apidocSignatureSpan">(port, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">web = function (port, cb) {
  var that = this;

  if (typeof(port) === &#x27;function&#x27;) {
    cb = port;
    port = 9615;
  }

  var filepath = path.resolve(path.dirname(module.filename), &#x27;../HttpInterface.js&#x27;);

  that.start({
    script : filepath,
    name : &#x27;pm2-http-interface&#x27;,
    execMode : &#x27;fork_mode&#x27;,
    env : {
      PM2_WEB_PORT : port
    }
  }, function(err, proc) {
    if (err) {
      Common.printError(cst.PREFIX_MSG_ERR + &#x27;Error while launching application&#x27;, err.stack || err);
      return cb ? cb(Common.retErr(err)) : that.speedList();
    }
    Common.printOut(cst.PREFIX_MSG + &#x27;Process launched&#x27;);
    return cb ? cb(null, proc) : that.speedList();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
