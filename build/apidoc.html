<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://pm2.keymetrics.io/"

    >pm2 (v2.4.4)</a>
</h1>
<h4>Production process manager for Node.JS applications with a built-in load balancer.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2">module pm2</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">pm2.</span>daemon_mode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">pm2.</span>gl_is_km_linked</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Daemon">
            function <span class="apidocSignatureSpan">pm2.</span>Daemon
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom">
            function <span class="apidocSignatureSpan">pm2.</span>custom
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>Client</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>Client.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>Common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>Configuration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>Daemon.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>God</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>Satan</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>Utility</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>_conf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>completion</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>custom.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>gl_interact_infos</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>machine_name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>public_key</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>secret_key</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.</span>start_timer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">pm2.</span>cwd</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">pm2.</span>pm2_home</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2.Client">module pm2.Client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.Client">
            function <span class="apidocSignatureSpan">pm2.</span>Client
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2.Client.prototype">module pm2.Client.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.close">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.disconnectBus">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>disconnectBus
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.disconnectRPC">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>disconnectRPC
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.executeRemote">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>executeRemote
            <span class="apidocSignatureSpan">(method, app_conf, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.getAllModulesId">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>getAllModulesId
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.getAllProcess">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>getAllProcess
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.getAllProcessId">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>getAllProcessId
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.getExposedMethods">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>getExposedMethods
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.getProcessByName">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>getProcessByName
            <span class="apidocSignatureSpan">(name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.getProcessIdByName">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>getProcessIdByName
            <span class="apidocSignatureSpan">(name, force_all, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.initFileStructure">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>initFileStructure
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.killDaemon">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>killDaemon
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.launchBus">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>launchBus
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.launchDaemon">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>launchDaemon
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.launchRPC">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>launchRPC
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.notifyGod">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>notifyGod
            <span class="apidocSignatureSpan">(action_name, id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.pingDaemon">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>pingDaemon
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.start">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>start
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.startWatch">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>startWatch
            <span class="apidocSignatureSpan">(method, env, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.stopWatch">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>stopWatch
            <span class="apidocSignatureSpan">(method, env, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Client.prototype.toggleWatch">
            function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>toggleWatch
            <span class="apidocSignatureSpan">(method, env, fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2.Common">module pm2.Common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Common.clone">
            function <span class="apidocSignatureSpan">pm2.Common.</span>clone
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Common.deepCopy">
            function <span class="apidocSignatureSpan">pm2.Common.</span>deepCopy
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Common.extend">
            function <span class="apidocSignatureSpan">pm2.Common.</span>extend
            <span class="apidocSignatureSpan">(destination, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Common.isConfigFile">
            function <span class="apidocSignatureSpan">pm2.Common.</span>isConfigFile
            <span class="apidocSignatureSpan">(filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Common.mergeEnvironmentVariables">
            function <span class="apidocSignatureSpan">pm2.Common.</span>mergeEnvironmentVariables
            <span class="apidocSignatureSpan">(app_env, env_name, deploy_conf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Common.parseConfig">
            function <span class="apidocSignatureSpan">pm2.Common.</span>parseConfig
            <span class="apidocSignatureSpan">(confObj, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Common.prepareAppConf">
            function <span class="apidocSignatureSpan">pm2.Common.</span>prepareAppConf
            <span class="apidocSignatureSpan">(opts, app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Common.printError">
            function <span class="apidocSignatureSpan">pm2.Common.</span>printError
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Common.printOut">
            function <span class="apidocSignatureSpan">pm2.Common.</span>printOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Common.resolveAppAttributes">
            function <span class="apidocSignatureSpan">pm2.Common.</span>resolveAppAttributes
            <span class="apidocSignatureSpan">(opts, legacy_app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Common.retErr">
            function <span class="apidocSignatureSpan">pm2.Common.</span>retErr
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Common.safeExtend">
            function <span class="apidocSignatureSpan">pm2.Common.</span>safeExtend
            <span class="apidocSignatureSpan">(origin, add)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Common.serialize">
            function <span class="apidocSignatureSpan">pm2.Common.</span>serialize
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Common.verifyConfs">
            function <span class="apidocSignatureSpan">pm2.Common.</span>verifyConfs
            <span class="apidocSignatureSpan">(appConfs)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.Common.</span>sink</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2.Configuration">module pm2.Configuration</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Configuration.get">
            function <span class="apidocSignatureSpan">pm2.Configuration.</span>get
            <span class="apidocSignatureSpan">(key, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Configuration.getAll">
            function <span class="apidocSignatureSpan">pm2.Configuration.</span>getAll
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Configuration.getAllSync">
            function <span class="apidocSignatureSpan">pm2.Configuration.</span>getAllSync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Configuration.getSync">
            function <span class="apidocSignatureSpan">pm2.Configuration.</span>getSync
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Configuration.multiset">
            function <span class="apidocSignatureSpan">pm2.Configuration.</span>multiset
            <span class="apidocSignatureSpan">(serial, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Configuration.set">
            function <span class="apidocSignatureSpan">pm2.Configuration.</span>set
            <span class="apidocSignatureSpan">(key, value, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Configuration.setSync">
            function <span class="apidocSignatureSpan">pm2.Configuration.</span>setSync
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Configuration.unset">
            function <span class="apidocSignatureSpan">pm2.Configuration.</span>unset
            <span class="apidocSignatureSpan">(key, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Configuration.unsetSync">
            function <span class="apidocSignatureSpan">pm2.Configuration.</span>unsetSync
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2.Daemon">module pm2.Daemon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Daemon.Daemon">
            function <span class="apidocSignatureSpan">pm2.</span>Daemon
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2.Daemon.prototype">module pm2.Daemon.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Daemon.prototype.close">
            function <span class="apidocSignatureSpan">pm2.Daemon.prototype.</span>close
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Daemon.prototype.gracefullExit">
            function <span class="apidocSignatureSpan">pm2.Daemon.prototype.</span>gracefullExit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Daemon.prototype.handleSignals">
            function <span class="apidocSignatureSpan">pm2.Daemon.prototype.</span>handleSignals
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Daemon.prototype.innerStart">
            function <span class="apidocSignatureSpan">pm2.Daemon.prototype.</span>innerStart
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Daemon.prototype.sendReady">
            function <span class="apidocSignatureSpan">pm2.Daemon.prototype.</span>sendReady
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Daemon.prototype.start">
            function <span class="apidocSignatureSpan">pm2.Daemon.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Daemon.prototype.startLogic">
            function <span class="apidocSignatureSpan">pm2.Daemon.prototype.</span>startLogic
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2.God">module pm2.God</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.checkProcess">
            function <span class="apidocSignatureSpan">pm2.God.</span>checkProcess
            <span class="apidocSignatureSpan">(pid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.deleteProcessId">
            function <span class="apidocSignatureSpan">pm2.God.</span>deleteProcessId
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.dumpProcessList">
            function <span class="apidocSignatureSpan">pm2.God.</span>dumpProcessList
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.duplicateProcessId">
            function <span class="apidocSignatureSpan">pm2.God.</span>duplicateProcessId
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.executeApp">
            function <span class="apidocSignatureSpan">pm2.God.</span>executeApp
            <span class="apidocSignatureSpan">(env, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.finalizeProcedure">
            function <span class="apidocSignatureSpan">pm2.God.</span>finalizeProcedure
            <span class="apidocSignatureSpan">(proc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.findByName">
            function <span class="apidocSignatureSpan">pm2.God.</span>findByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.findProcessById">
            function <span class="apidocSignatureSpan">pm2.God.</span>findProcessById
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.forceGc">
            function <span class="apidocSignatureSpan">pm2.God.</span>forceGc
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.forkMode">
            function <span class="apidocSignatureSpan">pm2.God.</span>forkMode
            <span class="apidocSignatureSpan">(pm2_env, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.getFormatedProcess">
            function <span class="apidocSignatureSpan">pm2.God.</span>getFormatedProcess
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.getFormatedProcesses">
            function <span class="apidocSignatureSpan">pm2.God.</span>getFormatedProcesses
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.getMonitorData">
            function <span class="apidocSignatureSpan">pm2.God.</span>getMonitorData
            <span class="apidocSignatureSpan">(env, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.getNewId">
            function <span class="apidocSignatureSpan">pm2.God.</span>getNewId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.getProcesses">
            function <span class="apidocSignatureSpan">pm2.God.</span>getProcesses
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.getSystemData">
            function <span class="apidocSignatureSpan">pm2.God.</span>getSystemData
            <span class="apidocSignatureSpan">(env, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.getVersion">
            function <span class="apidocSignatureSpan">pm2.God.</span>getVersion
            <span class="apidocSignatureSpan">(env, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.handleExit">
            function <span class="apidocSignatureSpan">pm2.God.</span>handleExit
            <span class="apidocSignatureSpan">(clu, exit_code, kill_signal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.killProcess">
            function <span class="apidocSignatureSpan">pm2.God.</span>killProcess
            <span class="apidocSignatureSpan">(pid, pm2_env, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.logAndGenerateError">
            function <span class="apidocSignatureSpan">pm2.God.</span>logAndGenerateError
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.msgProcess">
            function <span class="apidocSignatureSpan">pm2.God.</span>msgProcess
            <span class="apidocSignatureSpan">(cmd, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.nodeApp">
            function <span class="apidocSignatureSpan">pm2.God.</span>nodeApp
            <span class="apidocSignatureSpan">(env_copy, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.notify">
            function <span class="apidocSignatureSpan">pm2.God.</span>notify
            <span class="apidocSignatureSpan">(action_name, data, manually)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.notifyByProcessId">
            function <span class="apidocSignatureSpan">pm2.God.</span>notifyByProcessId
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.notifyKillPM2">
            function <span class="apidocSignatureSpan">pm2.God.</span>notifyKillPM2
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.ping">
            function <span class="apidocSignatureSpan">pm2.God.</span>ping
            <span class="apidocSignatureSpan">(env, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.prepare">
            function <span class="apidocSignatureSpan">pm2.God.</span>prepare
            <span class="apidocSignatureSpan">(env, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.processIsDead">
            function <span class="apidocSignatureSpan">pm2.God.</span>processIsDead
            <span class="apidocSignatureSpan">(pid, pm2_env, cb, sigkill)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.reloadLogs">
            function <span class="apidocSignatureSpan">pm2.God.</span>reloadLogs
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.reloadProcessId">
            function <span class="apidocSignatureSpan">pm2.God.</span>reloadProcessId
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.resetMetaProcessId">
            function <span class="apidocSignatureSpan">pm2.God.</span>resetMetaProcessId
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.resetState">
            function <span class="apidocSignatureSpan">pm2.God.</span>resetState
            <span class="apidocSignatureSpan">(pm2_env)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.restartProcessId">
            function <span class="apidocSignatureSpan">pm2.God.</span>restartProcessId
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.restartProcessName">
            function <span class="apidocSignatureSpan">pm2.God.</span>restartProcessName
            <span class="apidocSignatureSpan">(name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.sendDataToProcessId">
            function <span class="apidocSignatureSpan">pm2.God.</span>sendDataToProcessId
            <span class="apidocSignatureSpan">(packet, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.sendSignalToProcessId">
            function <span class="apidocSignatureSpan">pm2.God.</span>sendSignalToProcessId
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.sendSignalToProcessName">
            function <span class="apidocSignatureSpan">pm2.God.</span>sendSignalToProcessName
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.softReloadProcessId">
            function <span class="apidocSignatureSpan">pm2.God.</span>softReloadProcessId
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.startProcessId">
            function <span class="apidocSignatureSpan">pm2.God.</span>startProcessId
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.startWatch">
            function <span class="apidocSignatureSpan">pm2.God.</span>startWatch
            <span class="apidocSignatureSpan">(method, value, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.stopProcessId">
            function <span class="apidocSignatureSpan">pm2.God.</span>stopProcessId
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.stopWatch">
            function <span class="apidocSignatureSpan">pm2.God.</span>stopWatch
            <span class="apidocSignatureSpan">(method, value, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.God.toggleWatch">
            function <span class="apidocSignatureSpan">pm2.God.</span>toggleWatch
            <span class="apidocSignatureSpan">(method, value, fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pm2.God.</span>next_id</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.God.</span>Worker</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.God.</span>bus</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.God.</span>clusters_db</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pm2.God.</span>watch</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2.Satan">module pm2.Satan</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.disconnectBus">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>disconnectBus
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.disconnectRPC">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>disconnectRPC
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.executeRemote">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>executeRemote
            <span class="apidocSignatureSpan">(method, env, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.getExposedMethods">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>getExposedMethods
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.killDaemon">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>killDaemon
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.launchBus">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>launchBus
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.launchDaemon">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>launchDaemon
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.launchRPC">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>launchRPC
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.notifyGod">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>notifyGod
            <span class="apidocSignatureSpan">(action_name, id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.pingDaemon">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>pingDaemon
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.printOut">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>printOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.processStateHandler">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>processStateHandler
            <span class="apidocSignatureSpan">(God)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.remoteWrapper">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>remoteWrapper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.restartWatch">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>restartWatch
            <span class="apidocSignatureSpan">(method, env, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.start">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>start
            <span class="apidocSignatureSpan">(noDaemonMode, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Satan.stopWatch">
            function <span class="apidocSignatureSpan">pm2.Satan.</span>stopWatch
            <span class="apidocSignatureSpan">(method, env, fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2.Utility">module pm2.Utility</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Utility.clone">
            function <span class="apidocSignatureSpan">pm2.Utility.</span>clone
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Utility.extend">
            function <span class="apidocSignatureSpan">pm2.Utility.</span>extend
            <span class="apidocSignatureSpan">(destination, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Utility.extendExtraConfig">
            function <span class="apidocSignatureSpan">pm2.Utility.</span>extendExtraConfig
            <span class="apidocSignatureSpan">(proc, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Utility.formatCLU">
            function <span class="apidocSignatureSpan">pm2.Utility.</span>formatCLU
            <span class="apidocSignatureSpan">(process)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Utility.getDate">
            function <span class="apidocSignatureSpan">pm2.Utility.</span>getDate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Utility.overrideConsole">
            function <span class="apidocSignatureSpan">pm2.Utility.</span>overrideConsole
            <span class="apidocSignatureSpan">(bus)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Utility.packageNameToModuleName">
            function <span class="apidocSignatureSpan">pm2.Utility.</span>packageNameToModuleName
            <span class="apidocSignatureSpan">(package_name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Utility.startLogging">
            function <span class="apidocSignatureSpan">pm2.Utility.</span>startLogging
            <span class="apidocSignatureSpan">(stds, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.Utility.whichFileExists">
            function <span class="apidocSignatureSpan">pm2.Utility.</span>whichFileExists
            <span class="apidocSignatureSpan">(file_arr)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2.completion">module pm2.completion</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.completion.complete">
            function <span class="apidocSignatureSpan">pm2.completion.</span>complete
            <span class="apidocSignatureSpan">(name, completer, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.completion.isComplete">
            function <span class="apidocSignatureSpan">pm2.completion.</span>isComplete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.completion.log">
            function <span class="apidocSignatureSpan">pm2.completion.</span>log
            <span class="apidocSignatureSpan">(arr, o, prefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.completion.parseOut">
            function <span class="apidocSignatureSpan">pm2.completion.</span>parseOut
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.completion.parseTasks">
            function <span class="apidocSignatureSpan">pm2.completion.</span>parseTasks
            <span class="apidocSignatureSpan">(str, prefix, reg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2.custom">module pm2.custom</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.custom">
            function <span class="apidocSignatureSpan">pm2.</span>custom
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pm2.custom.prototype">module pm2.custom.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype._handleAttributeUpdate">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_handleAttributeUpdate
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype._operate">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_operate
            <span class="apidocSignatureSpan">(action_name, process_name, envs, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype._pre_interact">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_pre_interact
            <span class="apidocSignatureSpan">(cmd, public_key, machine, info_node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype._pull">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_pull
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype._pullCommitId">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_pullCommitId
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype._startJson">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_startJson
            <span class="apidocSignatureSpan">(file, opts, action, pipe, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype._startScript">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_startScript
            <span class="apidocSignatureSpan">(script, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.actionFromJson">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>actionFromJson
            <span class="apidocSignatureSpan">(action, file, opts, jsonVia, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.backward">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>backward
            <span class="apidocSignatureSpan">(process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.close">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.conf">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>conf
            <span class="apidocSignatureSpan">(key, value, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.connect">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>connect
            <span class="apidocSignatureSpan">(noDaemon, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.dashboard">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>dashboard
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.deepUpdate">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>deepUpdate
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.delete">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>delete
            <span class="apidocSignatureSpan">(process_name, jsonVia, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.deleteModule">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>deleteModule
            <span class="apidocSignatureSpan">(module_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.deploy">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>deploy
            <span class="apidocSignatureSpan">(file, commands, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.describe">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>describe
            <span class="apidocSignatureSpan">(pm2_id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.destroy">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>destroy
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.disconnect">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>disconnect
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.dockerMode">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>dockerMode
            <span class="apidocSignatureSpan">(script, opts, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.dump">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>dump
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.exitCli">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>exitCli
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.flush">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>flush
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.forward">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>forward
            <span class="apidocSignatureSpan">(process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.generateDockerfile">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>generateDockerfile
            <span class="apidocSignatureSpan">(script, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.generateModuleSample">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>generateModuleSample
            <span class="apidocSignatureSpan">(app_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.generateSample">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>generateSample
            <span class="apidocSignatureSpan">(mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.get">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>get
            <span class="apidocSignatureSpan">(key, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.getProcessIdByName">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>getProcessIdByName
            <span class="apidocSignatureSpan">(name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.getVersion">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>getVersion
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.gracefulReload">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>gracefulReload
            <span class="apidocSignatureSpan">(process_name, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.install">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>install
            <span class="apidocSignatureSpan">(module_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.interact">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>interact
            <span class="apidocSignatureSpan">(secret_key, public_key, machine_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.interactInfos">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>interactInfos
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.jlist">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>jlist
            <span class="apidocSignatureSpan">(debug)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.kill">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>kill
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.killAllModules">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>killAllModules
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.killDaemon">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>killDaemon
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.killInteract">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>killInteract
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.launchBus">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>launchBus
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.launchModules">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>launchModules
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.list">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>list
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.logrotate">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>logrotate
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.monit">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>monit
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.msgProcess">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>msgProcess
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.multiset">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>multiset
            <span class="apidocSignatureSpan">(serial, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.ping">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>ping
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.printLogs">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>printLogs
            <span class="apidocSignatureSpan">(id, lines, raw, timestamp, exclusive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.profilePM2">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>profilePM2
            <span class="apidocSignatureSpan">(command, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.publish">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>publish
            <span class="apidocSignatureSpan">(module_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.pullAndGracefulReload">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullAndGracefulReload
            <span class="apidocSignatureSpan">(process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.pullAndReload">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullAndReload
            <span class="apidocSignatureSpan">(process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.pullAndRestart">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullAndRestart
            <span class="apidocSignatureSpan">(process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.pullCommitId">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullCommitId
            <span class="apidocSignatureSpan">(process_name, commit_id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.reload">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>reload
            <span class="apidocSignatureSpan">(process_name, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.reloadLogs">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>reloadLogs
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.remote">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>remote
            <span class="apidocSignatureSpan">(command, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.remoteV2">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>remoteV2
            <span class="apidocSignatureSpan">(command, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.reset">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>reset
            <span class="apidocSignatureSpan">(process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.restart">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>restart
            <span class="apidocSignatureSpan">(cmd, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.resurrect">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>resurrect
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.scale">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>scale
            <span class="apidocSignatureSpan">(app_name, number, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.sendDataToProcessId">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>sendDataToProcessId
            <span class="apidocSignatureSpan">(proc_id, packet, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.sendSignalToProcessId">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>sendSignalToProcessId
            <span class="apidocSignatureSpan">(signal, process_id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.sendSignalToProcessName">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>sendSignalToProcessName
            <span class="apidocSignatureSpan">(signal, process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.serve">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>serve
            <span class="apidocSignatureSpan">(target_path, port, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.set">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>set
            <span class="apidocSignatureSpan">(key, value, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.snapshotPM2">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>snapshotPM2
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.speedList">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>speedList
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.start">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>start
            <span class="apidocSignatureSpan">(cmd, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.startup">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>startup
            <span class="apidocSignatureSpan">(platform, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.stop">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>stop
            <span class="apidocSignatureSpan">(process_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.streamLogs">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>streamLogs
            <span class="apidocSignatureSpan">(id, lines, raw, timestamp, exclusive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.trigger">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>trigger
            <span class="apidocSignatureSpan">(pm_id, action_name, params, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.uninstall">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>uninstall
            <span class="apidocSignatureSpan">(module_name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.uninstallStartup">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>uninstallStartup
            <span class="apidocSignatureSpan">(platform, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.unset">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>unset
            <span class="apidocSignatureSpan">(key, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.update">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>update
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pm2.custom.prototype.web">
            function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>web
            <span class="apidocSignatureSpan">(port, cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2" id="apidoc.module.pm2">module pm2</a></h1>






    <h2>
        <a href="#apidoc.element.pm2.Daemon" id="apidoc.element.pm2.Daemon">
        function <span class="apidocSignatureSpan">pm2.</span>Daemon
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Daemon = function (opts) {
  if (!opts) opts = {};

  this.rpc_socket_ready = false;
  this.pub_socket_ready = false;

  this.pub_socket_file = opts.pub_socket_file || cst.DAEMON_PUB_PORT;
  this.rpc_socket_file = opts.rpc_socket_file || cst.DAEMON_RPC_PORT;

  this.pid_path        = opts.pid_file || cst.PM2_PID_FILE_PATH;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom" id="apidoc.element.pm2.custom">
        function <span class="apidocSignatureSpan">pm2.</span>custom
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">custom = function (opts) {
  if (!opts) opts = {};
  var that = this;

  this.daemon_mode = typeof(opts.daemon_mode) == &#x27;undefined&#x27; ? true : opts.daemon_mode;
  this.pm2_home    = conf.PM2_ROOT_PATH;
  this.public_key   = process.env.KEYMETRICS_SECRET || opts.public_key || null;
  this.secret_key   = process.env.KEYMETRICS_PUBLIC || opts.secret_key || null;
  this.machine_name = process.env.INSTANCE_NAME || opts.machine_name || null

<span class="apidocCodeCommentSpan">  /**
   * CWD resolution
   */
</span>  this.cwd         = process.cwd();
  if (opts.cwd) {
    this.cwd = path.resolve(opts.cwd);
  }

  /**
   * PM2 HOME resolution
   */
  if (opts.pm2_home &#x26;&#x26; opts.independent == true)
    throw new Error(&#x27;You cannot set a pm2_home and independent instance in same time&#x27;);

  if (opts.pm2_home) {
    // Override default conf file
    this.pm2_home        = opts.pm2_home;
    conf = util._extend(conf, path_structure(this.pm2_home));
  }
  else if (opts.independent == true &#x26;&#x26; conf.IS_WINDOWS === false) {
    // Create an unique pm2 instance
    var crypto = require(&#x27;crypto&#x27;);
    var random_file = crypto.randomBytes(8).toString(&#x27;hex&#x27;);
    this.pm2_home = path.join(&#x27;/tmp&#x27;, random_file);

    // If we dont explicitly tell to have a daemon
    // It will go as in proc
    if (typeof(opts.daemon_mode) == &#x27;undefined&#x27;)
      this.daemon_mode = false;
    conf = util._extend(conf, path_structure(this.pm2_home));
  }

  this._conf = conf;

  if (conf.IS_WINDOWS) {
    // Weird fix, may need to be dropped
    // @todo windows connoisseur double check
    if (process.stdout._handle &#x26;&#x26; process.stdout._handle.setBlocking)
      process.stdout._handle.setBlocking(true);
  }

  this.Client = new Client({
    pm2_home : that.pm2_home,
    conf     : this._conf,
    secret_key : this.secret_key,
    public_key : this.public_key,
    daemon_mode : this.daemon_mode,
    machine_name : this.machine_name
  });

  this.gl_interact_infos = null;
  this.gl_is_km_linked = false;

  try {
    var pid = fs.readFileSync(conf.INTERACTOR_PID_PATH);
    pid = parseInt(pid.toString().trim());
    process.kill(pid, 0);
    that.gl_is_km_linked = true;
  } catch(e) {
    that.gl_is_km_linked = false;
  }

  // For testing purposes
  if (this.secret_key &#x26;&#x26; process.env.NODE_ENV == &#x27;local_test&#x27;)
    that.gl_is_km_linked = true;

  KMDaemon.getInteractInfo(this._conf, function(i_err, interact) {
    that.gl_interact_infos = interact;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fmt       = require(&#x27;./tools/fmt.js&#x27;);
var exec      = require(&#x27;child_process&#x27;).exec;
var os        = require(&#x27;os&#x27;);

commander.version(pkg.version)
  .usage(&#x27;[cmd] app&#x27;);

var pm2 = new PM2.<span class="apidocCodeKeywordSpan">custom</span>({
  pm2_home : path.join(os.homedir ? os.homedir() : (process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE), &#x27;.
pm2-dev&#x27;)
});

pm2.connect(function() {
  commander.parse(process.argv);
});
...</pre></li>
    </ul>






































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2.Client" id="apidoc.module.pm2.Client">module pm2.Client</a></h1>


    <h2>
        <a href="#apidoc.element.pm2.Client.Client" id="apidoc.element.pm2.Client.Client">
        function <span class="apidocSignatureSpan">pm2.</span>Client
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client = function (opts) {
  if (!opts) opts = {};

  if (!opts.conf)
    this.conf = require(&#x27;../constants.js&#x27;);
  else {
    this.conf     = opts.conf;
  }

  this.daemon_mode = typeof(opts.daemon_mode) == &#x27;undefined&#x27; ? true : opts.daemon_mode;
  this.pm2_home    = this.conf.PM2_ROOT_PATH;
  this.secret_key   = opts.secret_key;
  this.public_key   = opts.public_key;
  this.machine_name = opts.machine_name;

  // Create all folders and files needed
  // Client depends to that to interact with PM2 properly
  this.initFileStructure(this.conf);

  debug(&#x27;Using RPC file %s&#x27;, this.conf.DAEMON_RPC_PORT);
  debug(&#x27;Using PUB file %s&#x27;, this.conf.DAEMON_PUB_PORT);
  this.rpc_socket_file = this.conf.DAEMON_RPC_PORT;
  this.pub_socket_file = this.conf.DAEMON_PUB_PORT;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @api public
 * @method pingDaemon
 * @param {} cb
 * @return
 */
Client.prototype.pingDaemon = function pingDaemon(cb) {
var req    = axon.socket(&#x27;req&#x27;);
var client = new rpc.<span class="apidocCodeKeywordSpan">Client</span>(req);

debug(&#x27;[PING PM2] Trying to connect to server&#x27;);

client.sock.once(&#x27;reconnect attempt&#x27;, function() {
  client.sock.close();
  debug(&#x27;Daemon not launched&#x27;);
  process.nextTick(function() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2.Client.prototype" id="apidoc.module.pm2.Client.prototype">module pm2.Client.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.close" id="apidoc.element.pm2.Client.prototype.close">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  var that = this;

  async.forEach([
    that.disconnectRPC.bind(that),
    that.disconnectBus.bind(that)
  ], function(fn, next) {
    fn(next)
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Client.prototype.pingDaemon = function pingDaemon(cb) {
var req    = axon.socket(&#x27;req&#x27;);
var client = new rpc.Client(req);

debug(&#x27;[PING PM2] Trying to connect to server&#x27;);

client.sock.once(&#x27;reconnect attempt&#x27;, function() {
  client.sock.<span class="apidocCodeKeywordSpan">close</span>();
  debug(&#x27;Daemon not launched&#x27;);
  process.nextTick(function() {
    return cb(false);
  });
});

client.sock.once(&#x27;connect&#x27;, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.disconnectBus" id="apidoc.element.pm2.Client.prototype.disconnectBus">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>disconnectBus
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disconnectBus(cb) {
  if (!cb) cb = noop;

  var that = this;

  if (!this.sub_sock || !this.sub_sock.close) {
    that.sub = null;
    return process.nextTick(function() {
      cb(null, { msg : &#x27;bus was not connected&#x27;});
    });
  }

  if (this.sub_sock.connected == false ||
      this.sub_sock.closing == true) {
    that.sub = null;
    return process.nextTick(function() {
      cb(new Error(&#x27;SUB connection is already being closed&#x27;));
    });
  }

  try {
    var timer;

    that.sub_sock.once(&#x27;close&#x27;, function() {
      that.sub = null;
      clearTimeout(timer);
      debug(&#x27;PM2 PUB cleanly closed&#x27;);
      return cb();
    });

    timer = setTimeout(function() {
      if (Client.sub_sock.destroy)
        that.sub_sock.destroy();
      return cb();
    }, 200);

    this.sub_sock.close();
  } catch(e) {
    return cb(e);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.disconnectRPC" id="apidoc.element.pm2.Client.prototype.disconnectRPC">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>disconnectRPC
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disconnectRPC(cb) {
  var that = this;
  if (!cb) cb = noop;

  if (!this.client_sock || !this.client_sock.close) {
    this.client = null;
    return process.nextTick(function() {
      cb(new Error(&#x27;SUB connection to PM2 is not launched&#x27;));
    });
  }

  if (this.client_sock.connected == false ||
      this.client_sock.closing == true) {
    this.client = null;
    return process.nextTick(function() {
      cb(new Error(&#x27;RPC already being closed&#x27;));
    });
  }

  try {
    var timer;

    that.client_sock.once(&#x27;close&#x27;, function() {
      clearTimeout(timer);
      that.client = null;
      debug(&#x27;PM2 RPC cleanly closed&#x27;);
      return cb(null, { msg : &#x27;RPC Successfully closed&#x27; });
    });

    timer = setTimeout(function() {
      if (Client.client_sock.destroy)
        that.client_sock.destroy();
      that.client = null;
      return cb(null, { msg : &#x27;RPC Successfully closed via timeout&#x27; });
    }, 200);

    that.client_sock.close();
  } catch(e) {
    debug(&#x27;Error while disconnecting RPC PM2&#x27;, e.stack || e);
    return cb(e);
  };
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {} fn
 * @return
 */
Satan.killDaemon = function killDaemon(fn) {
var timeout;

function quit() {
  Satan.<span class="apidocCodeKeywordSpan">disconnectRPC</span>(function() {
    debug(&#x27;RPC disconnected&#x27;);
    return fn ? fn(null, {success:true}) : false;
  });
}

process.once(&#x27;SIGQUIT&#x27;, function() {
  debug(&#x27;Received SIGQUIT&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.executeRemote" id="apidoc.element.pm2.Client.prototype.executeRemote">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>executeRemote
        <span class="apidocSignatureSpan">(method, app_conf, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function executeRemote(method, app_conf, fn) {
  var self = this;

  // stop watch on stop | env is the process id
  if (method.indexOf(&#x27;stop&#x27;) !== -1) {
    this.stopWatch(method, app_conf);
  }
  // stop watching when process is deleted
  else if (method.indexOf(&#x27;delete&#x27;) !== -1) {
    this.stopWatch(method, app_conf);
  }
  // stop everything on kill
  else if (method.indexOf(&#x27;kill&#x27;) !== -1) {
    this.stopWatch(&#x27;deleteAll&#x27;, app_conf);
  }
  else if (method.indexOf(&#x27;restartProcessId&#x27;) !== -1 &#x26;&#x26; process.argv.indexOf(&#x27;--watch&#x27;) &#x3e; -1) {
    delete app_conf.env.current_conf.watch;
    this.toggleWatch(method, app_conf);
  }

  if (!this.client || !this.client.call) {
    this.start(function(error) {
      if (error) {
        if (fn)
          return fn(error);
        console.error(error);
        return process.exit(0);
      }
      return self.client.call(method, app_conf, fn);
    });
    return false;
  }

  debug(&#x27;Calling daemon method pm2:%s on rpc socket:%s&#x27;, method, this.rpc_socket_file);
  return this.client.call(method, app_conf, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

debug(&#x27;Calling daemon method pm2:%s on rpc socket:%s&#x27;, method, this.rpc_socket_file);
return this.client.call(method, app_conf, fn);
};

Client.prototype.notifyGod = function(action_name, id, cb) {
this.<span class="apidocCodeKeywordSpan">executeRemote</span>(&#x27;notifyByProcessId&#x27;, {
  id : id,
  action_name : action_name,
  manually : true
}, function() {
  debug(&#x27;God notified&#x27;);
  return cb ? cb() : false;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.getAllModulesId" id="apidoc.element.pm2.Client.prototype.getAllModulesId">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>getAllModulesId
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllModulesId = function (cb) {
  var found_proc = [];

  this.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(&#x27;Error retrieving process list: &#x27; + err);
      return cb(err);
    }

    list.forEach(function(proc) {
      if (proc.pm2_env.pmx_module)
        found_proc.push(proc.pm_id);
    });

    return cb(null, found_proc);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.getAllProcess" id="apidoc.element.pm2.Client.prototype.getAllProcess">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>getAllProcess
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllProcess = function (cb) {
  var found_proc = [];

  this.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(&#x27;Error retrieving process list: &#x27; + err);
      return cb(err);
    }

    list.forEach(function(proc) {
      found_proc.push(proc);
    });

    return cb(null, found_proc);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.getAllProcessId" id="apidoc.element.pm2.Client.prototype.getAllProcessId">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>getAllProcessId
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllProcessId = function (cb) {
  var found_proc = [];

  this.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(&#x27;Error retrieving process list: &#x27; + err);
      return cb(err);
    }

    list.forEach(function(proc) {
      if (!proc.pm2_env.pmx_module)
        found_proc.push(proc.pm_id);
    });

    return cb(null, found_proc);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.getExposedMethods" id="apidoc.element.pm2.Client.prototype.getExposedMethods">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>getExposedMethods
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExposedMethods(cb) {
  this.client.methods(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.getProcessByName" id="apidoc.element.pm2.Client.prototype.getProcessByName">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>getProcessByName
        <span class="apidocSignatureSpan">(name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProcessByName = function (name, cb) {
  var found_proc = [];

  this.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(&#x27;Error retrieving process list: &#x27; + err);
      return cb(err);
    }

    list.forEach(function(proc) {
      if (proc.pm2_env.name == name ||
          proc.pm2_env.pm_exec_path == path.resolve(name)) {
        found_proc.push(proc);
      }
    });

    return cb(null, found_proc);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.getProcessIdByName" id="apidoc.element.pm2.Client.prototype.getProcessIdByName">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>getProcessIdByName
        <span class="apidocSignatureSpan">(name, force_all, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProcessIdByName = function (name, force_all, cb) {
  var found_proc   = [];
  var full_details = {};

  if (typeof(cb) === &#x27;undefined&#x27;) {
    cb = force_all;
    force_all = false;
  }

  if (typeof(name) == &#x27;number&#x27;)
    name = name.toString();

  this.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(&#x27;Error retrieving process list: &#x27; + err);
      return cb(err);
    }

    list.forEach(function(proc) {
      if ((proc.pm2_env.name == name || proc.pm2_env.pm_exec_path == path.resolve(name)) &#x26;&#x26;
          !(proc.pm2_env.pmx_module &#x26;&#x26; !force_all)) {
        found_proc.push(proc.pm_id);
        full_details[proc.pm_id] = proc;
      }
    });

    return cb(null, found_proc, full_details);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.initFileStructure" id="apidoc.element.pm2.Client.prototype.initFileStructure">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>initFileStructure
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initFileStructure = function (opts) {

  if (!fs.existsSync(opts.DEFAULT_LOG_PATH)) {
    try {
      mkdirp.sync(opts.DEFAULT_LOG_PATH);
    } catch (e) {
      console.error(e.stack || e);
    }
  }

  if (!fs.existsSync(opts.DEFAULT_PID_PATH)) {
    try {
      mkdirp.sync(opts.DEFAULT_PID_PATH);
    } catch (e) {
      console.error(e.stack || e);
    }
  }

  // No more (temporary) conf file, mainly via api now
  // @todo: implement configuration file for override
  // (before conf was only about path overrides)
  // if (!fs.existsSync(opts.PM2_CONF_FILE)) {
  //   fs
  //     .createReadStream(path.join(opts.TEMPLATE_FOLDER, opts.SAMPLE_CONF_FILE))
  //     .pipe(fs.createWriteStream(opts.PM2_CONF_FILE));
  // }

  if (!fs.existsSync(opts.PM2_MODULE_CONF_FILE)) {
    try {
      fs.writeFileSync(opts.PM2_MODULE_CONF_FILE, &#x22;{}&#x22;);
    } catch (e) {
      console.error(e.stack || e);
    }
  }

  if (!process.env.PM2_PROGRAMMATIC &#x26;&#x26; !fs.existsSync(path.join(opts.PM2_HOME, &#x27;touch&#x27;))) {
    var dt = fs.readFileSync(path.join(__dirname, opts.KEYMETRICS_BANNER));
    console.log(dt.toString());
    try {
      fs.writeFileSync(path.join(opts.PM2_HOME, &#x27;touch&#x27;), Date.now());
    } catch(e) {
      debug(e.stack || e);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.pm2_home    = this.conf.PM2_ROOT_PATH;
  this.secret_key   = opts.secret_key;
  this.public_key   = opts.public_key;
  this.machine_name = opts.machine_name;

  // Create all folders and files needed
  // Client depends to that to interact with PM2 properly
  this.<span class="apidocCodeKeywordSpan">initFileStructure</span>(this.conf);

  debug(&#x27;Using RPC file %s&#x27;, this.conf.DAEMON_RPC_PORT);
  debug(&#x27;Using PUB file %s&#x27;, this.conf.DAEMON_PUB_PORT);
  this.rpc_socket_file = this.conf.DAEMON_RPC_PORT;
  this.pub_socket_file = this.conf.DAEMON_PUB_PORT;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.killDaemon" id="apidoc.element.pm2.Client.prototype.killDaemon">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>killDaemon
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function killDaemon(fn) {
  var timeout;
  var that = this;

  function quit() {
    that.close(function() {
      return fn ? fn(null, {success:true}) : false;
    });
  }

  // under unix, we listen for signal (that is send by daemon to notify us that its shuting down)
  if (process.platform !== &#x27;win32&#x27; &#x26;&#x26; process.platform !== &#x27;win64&#x27;) {
    process.once(&#x27;SIGQUIT&#x27;, function() {
      debug(&#x27;Received SIGQUIT from pm2 daemon&#x27;);
      clearTimeout(timeout);
      quit();
    });
  }
  else {
    // if under windows, try to ping the daemon to see if it still here
    setTimeout(function() {
      that.pingDaemon(function(alive) {
        if (!alive) {
          clearTimeout(timeout);
          return quit();
        }
      });
    }, 250)
  }

  timeout = setTimeout(function() {
    quit();
  }, 3000);

  // Kill daemon
  this.executeRemote(&#x27;killMe&#x27;, {pid : process.pid});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.launchBus" id="apidoc.element.pm2.Client.prototype.launchBus">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>launchBus
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function launchEventSystem(cb) {
  var self = this;
  this.sub = axon.socket(&#x27;sub-emitter&#x27;);
  this.sub_sock = this.sub.connect(this.pub_socket_file);

  this.sub_sock.once(&#x27;connect&#x27;, function() {
    return cb(null, self.sub, self.sub_sock);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
fmt.field(&#x27;Watch and Restart&#x27;, chalk.green(&#x27;Enabled&#x27;));
fmt.field(&#x27;Ignored folder&#x27;, opts.ignore_watch || &#x27;node_modules&#x27;);
if (opts.postExec)
  fmt.field(&#x27;Post restart cmd&#x27;, opts.postExec);
fmt.sep();

setTimeout(function() {
  pm2.Client.<span class="apidocCodeKeywordSpan">launchBus</span>(function(err, bus) {
    bus.on(&#x27;process:event&#x27;, function(packet) {
      if (packet.event == &#x27;online&#x27;) {
        if (opts.postExec)
          postExecCmd(opts.postExec);
      }
    });
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.launchDaemon" id="apidoc.element.pm2.Client.prototype.launchDaemon">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>launchDaemon
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">launchDaemon = function (opts, cb) {
  if (typeof(opts) == &#x27;function&#x27;) {
    cb = opts;
    opts = {
      interactor : true
    };
  }

  var that = this
  var ClientJS = path.resolve(path.dirname(module.filename), &#x27;Daemon.js&#x27;);
  var node_args = [];
  var out, err;

  if (process.env.TRAVIS) {
    // Redirect PM2 internal err and out to STDERR STDOUT when running with Travis
    out = 1;
    err = 2;
  }
  else {
    out = fs.openSync(that.conf.PM2_LOG_FILE_PATH, &#x27;a&#x27;),
    err = fs.openSync(that.conf.PM2_LOG_FILE_PATH, &#x27;a&#x27;);
  }

  // Node.js tuning for better performance
  //node_args.push(&#x27;--expose-gc&#x27;); // Allows manual GC in the code
  //node_args.push(&#x27;--gc-global&#x27;); // Does full GC (smaller memory footprint)
  //node_args.push(&#x27;--max-old-space-size=100&#x27;);

<span class="apidocCodeCommentSpan">  /**
   * Add node [arguments] depending on PM2_NODE_OPTIONS env variable
   */
</span>  if (process.env.PM2_NODE_OPTIONS)
    node_args = node_args.concat(process.env.PM2_NODE_OPTIONS.split(&#x27; &#x27;));
  node_args.push(ClientJS);

  Common.printOut(that.conf.PREFIX_MSG + &#x27;Spawning PM2 daemon with pm2_home=&#x27; + this.pm2_home);

  var interpreter = &#x27;node&#x27;;

  if (shelljs.which(&#x27;node&#x27;) == null)
    interpreter = process.execPath;

  var child = require(&#x27;child_process&#x27;).spawn(interpreter, node_args, {
    detached   : true,
    cwd        : that.conf.cwd || process.cwd(),
    env        : util._extend({
      &#x27;SILENT&#x27;      : that.conf.DEBUG ? !that.conf.DEBUG : true,
      &#x27;PM2_HOME&#x27;   : that.pm2_home
    }, process.env),
    stdio      : [&#x27;ipc&#x27;, out, err]
  });

  function onError(e) {
    console.error(e.message || e);
    return cb ? cb(e.message || e) : false;
  }

  child.once(&#x27;error&#x27;, onError);

  child.unref();

  child.once(&#x27;message&#x27;, function(msg) {
    debug(&#x27;PM2 daemon launched with return message: &#x27;, msg);
    child.removeListener(&#x27;error&#x27;, onError);
    child.disconnect();

    if (opts &#x26;&#x26; opts.interactor == false)
      return cb(null, child);

    /**
     * Here the Keymetrics agent is launched automaticcaly if
     * it has been already configured before (via pm2 link)
     */
    KMDaemon.launchAndInteract(that.conf, {
      machine_name : that.machine_name,
      public_key   : that.public_key,
      secret_key   : that.secret_key
    }, function(err, data, interactor_proc) {
      that.interactor_process = interactor_proc;
      return cb(null, child);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  return false;
}

/**
 * Daemon mode
 */
that.<span class="apidocCodeKeywordSpan">launchDaemon</span>(function(err, child) {
  if (err) {
    Common.printError(err);
    return cb ? cb(err) : process.exit(that.conf.ERROR_EXIT);
  }
  Common.printOut(that.conf.PREFIX_MSG + &#x27;PM2 Successfully daemonized&#x27;);
  that.launchRPC(function(err, meta) {
    return cb(null, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.launchRPC" id="apidoc.element.pm2.Client.prototype.launchRPC">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>launchRPC
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function launchRPC(cb) {
  var self = this;
  debug(&#x27;Launching RPC client on socket file %s&#x27;, this.rpc_socket_file);
  var req      = axon.socket(&#x27;req&#x27;);
  this.client  = new rpc.Client(req);

  this.client.sock.once(&#x27;connect&#x27;, function() {
    // Avoid keeping the event loop busy if no more items running
    // if (req &#x26;&#x26; req.socks &#x26;&#x26; req.socks[0] &#x26;&#x26; req.socks[0].unref &#x26;&#x26;
    //     self.conf.PM2_PROGRAMMATIC)
    //   req.socks[0].unref();
    debug(&#x27;RPC Connected to Daemon&#x27;);
    //process.emit(&#x27;satan:client:ready&#x27;);
    setTimeout(function() {
      return cb ? cb(null) : false;
    }, 4);
  });

  this.client.sock.on(&#x27;error&#x27;, function(e) {
    return cb(e);
  });

  this.client_sock = req.connect(this.rpc_socket_file);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// @breaking change (noDaemonMode has been drop)
// @todo ret err
Client.prototype.start = function(cb) {
var that = this;

this.pingDaemon(function(daemonAlive) {
  if (daemonAlive == true)
    return that.<span class="apidocCodeKeywordSpan">launchRPC</span>(function(err, meta) {
      return cb(null, {
        daemon_mode      : that.conf.daemon_mode,
        new_pm2_instance : false,
        rpc_socket_file  : that.rpc_socket_file,
        pub_socket_file  : that.pub_socket_file,
        pm2_home         : that.pm2_home
      });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.notifyGod" id="apidoc.element.pm2.Client.prototype.notifyGod">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>notifyGod
        <span class="apidocSignatureSpan">(action_name, id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyGod = function (action_name, id, cb) {
  this.executeRemote(&#x27;notifyByProcessId&#x27;, {
    id : id,
    action_name : action_name,
    manually : true
  }, function() {
    debug(&#x27;God notified&#x27;);
    return cb ? cb() : false;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.pingDaemon" id="apidoc.element.pm2.Client.prototype.pingDaemon">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>pingDaemon
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pingDaemon(cb) {
  var req    = axon.socket(&#x27;req&#x27;);
  var client = new rpc.Client(req);

  debug(&#x27;[PING PM2] Trying to connect to server&#x27;);

  client.sock.once(&#x27;reconnect attempt&#x27;, function() {
    client.sock.close();
    debug(&#x27;Daemon not launched&#x27;);
    process.nextTick(function() {
      return cb(false);
    });
  });

  client.sock.once(&#x27;connect&#x27;, function() {
    client.sock.once(&#x27;close&#x27;, function() {
      return cb(true);
    });
    client.sock.close();
    debug(&#x27;Daemon alive&#x27;);
  });

  req.connect(this.rpc_socket_file);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// @breaking change (noDaemonMode has been drop)
// @todo ret err
Client.prototype.start = function(cb) {
var that = this;

this.<span class="apidocCodeKeywordSpan">pingDaemon</span>(function(daemonAlive) {
  if (daemonAlive == true)
    return that.launchRPC(function(err, meta) {
      return cb(null, {
        daemon_mode      : that.conf.daemon_mode,
        new_pm2_instance : false,
        rpc_socket_file  : that.rpc_socket_file,
        pub_socket_file  : that.pub_socket_file,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.start" id="apidoc.element.pm2.Client.prototype.start">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>start
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (cb) {
  var that = this;

  this.pingDaemon(function(daemonAlive) {
    if (daemonAlive == true)
      return that.launchRPC(function(err, meta) {
        return cb(null, {
          daemon_mode      : that.conf.daemon_mode,
          new_pm2_instance : false,
          rpc_socket_file  : that.rpc_socket_file,
          pub_socket_file  : that.pub_socket_file,
          pm2_home         : that.pm2_home
        });
      });

<span class="apidocCodeCommentSpan">    /**
     * No Daemon mode
     */
</span>    if (that.daemon_mode == false) {
      var Daemon         = require(&#x27;./Daemon.js&#x27;);

      var daemon = new Daemon({
        pub_socket_file : that.conf.DAEMON_PUB_PORT,
        rpc_socket_file : that.conf.DAEMON_RPC_PORT,
        pid_file        : that.conf.PM2_PID_FILE_PATH
      });

      console.log(&#x27;Launching in no daemon mode&#x27;);

      daemon.innerStart(function() {
        KMDaemon.launchAndInteract(that.conf, {
          machine_name : that.machine_name,
          public_key   : that.public_key,
          secret_key   : that.secret_key
        }, function(err, data, interactor_proc) {
          that.interactor_process = interactor_proc;
        });

        that.launchRPC(function(err, meta) {
          return cb(null, {
            daemon_mode      : that.conf.daemon_mode,
            new_pm2_instance : false,
            rpc_socket_file  : that.rpc_socket_file,
            pub_socket_file  : that.pub_socket_file,
            pm2_home         : that.pm2_home
          });
        });
      });
      return false;
    }

    /**
     * Daemon mode
     */
    that.launchDaemon(function(err, child) {
      if (err) {
        Common.printError(err);
        return cb ? cb(err) : process.exit(that.conf.ERROR_EXIT);
      }
      Common.printOut(that.conf.PREFIX_MSG + &#x27;PM2 Successfully daemonized&#x27;);
      that.launchRPC(function(err, meta) {
        return cb(null, {
          daemon_mode      : that.conf.daemon_mode,
          new_pm2_instance : true,
          rpc_socket_file  : that.rpc_socket_file,
          pub_socket_file  : that.pub_socket_file,
          pm2_home         : that.pm2_home
        });
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
else if (method.indexOf(&#x27;restartProcessId&#x27;) !== -1 &#x26;&#x26; process.argv.indexOf(&#x27;--watch&#x27;) &#x3e; -1) {
  delete app_conf.env.current_conf.watch;
  this.toggleWatch(method, app_conf);
}

if (!this.client || !this.client.call) {
  this.<span class="apidocCodeKeywordSpan">start</span>(function(error) {
    if (error) {
      if (fn)
        return fn(error);
      console.error(error);
      return process.exit(0);
    }
    return self.client.call(method, app_conf, fn);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.startWatch" id="apidoc.element.pm2.Client.prototype.startWatch">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>startWatch
        <span class="apidocSignatureSpan">(method, env, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function restartWatch(method, env, fn) {
  debug(&#x27;Calling startWatch&#x27;);
  this.client.call(&#x27;startWatch&#x27;, method, env, function() {
    return fn ? fn() : false;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.stopWatch" id="apidoc.element.pm2.Client.prototype.stopWatch">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>stopWatch
        <span class="apidocSignatureSpan">(method, env, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopWatch(method, env, fn) {
  debug(&#x27;Calling stopWatch&#x27;);
  this.client.call(&#x27;stopWatch&#x27;, method, env, function() {
    return fn ? fn() : false;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return
 */
Client.prototype.executeRemote = function executeRemote(method, app_conf, fn) {
var self = this;

// stop watch on stop | env is the process id
if (method.indexOf(&#x27;stop&#x27;) !== -1) {
  this.<span class="apidocCodeKeywordSpan">stopWatch</span>(method, app_conf);
}
// stop watching when process is deleted
else if (method.indexOf(&#x27;delete&#x27;) !== -1) {
  this.stopWatch(method, app_conf);
}
// stop everything on kill
else if (method.indexOf(&#x27;kill&#x27;) !== -1) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Client.prototype.toggleWatch" id="apidoc.element.pm2.Client.prototype.toggleWatch">
        function <span class="apidocSignatureSpan">pm2.Client.prototype.</span>toggleWatch
        <span class="apidocSignatureSpan">(method, env, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toggleWatch(method, env, fn) {
  debug(&#x27;Calling toggleWatch&#x27;);
  this.client.call(&#x27;toggleWatch&#x27;, method, env, function() {
    return fn ? fn() : false;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
// stop everything on kill
else if (method.indexOf(&#x27;kill&#x27;) !== -1) {
  this.stopWatch(&#x27;deleteAll&#x27;, app_conf);
}
else if (method.indexOf(&#x27;restartProcessId&#x27;) !== -1 &#x26;&#x26; process.argv.indexOf(&#x27;--watch&#x27;) &#x3e; -1) {
  delete app_conf.env.current_conf.watch;
  this.<span class="apidocCodeKeywordSpan">toggleWatch</span>(method, app_conf);
}

if (!this.client || !this.client.call) {
  this.start(function(error) {
    if (error) {
      if (fn)
        return fn(error);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2.Common" id="apidoc.module.pm2.Common">module pm2.Common</a></h1>


    <h2>
        <a href="#apidoc.element.pm2.Common.clone" id="apidoc.element.pm2.Common.clone">
        function <span class="apidocSignatureSpan">pm2.Common.</span>clone
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function (obj) {
  if (obj === null || obj === undefined) return {};
  return fclone(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  try {
    // Application Name nverride
    if (msg.data.name)
      God.clusters_db[msg.process.pm_id].pm2_env.name = msg.data.name;

    Object.keys(msg.data).forEach(function(conf_key) {
      God.clusters_db[msg.process.pm_id].pm2_env.axm_options[conf_key] = Utility.<span class="apidocCodeKeywordSpan">clone</span
>(msg.data[conf_key]);
    });
  } catch(e) {
    console.error(e.stack || e);
  }
  msg = null;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Common.deepCopy" id="apidoc.element.pm2.Common.deepCopy">
        function <span class="apidocSignatureSpan">pm2.Common.</span>deepCopy
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deepCopy = function (obj) {
  if (obj === null || obj === undefined) return {};
  return fclone(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Common.extend" id="apidoc.element.pm2.Common.extend">
        function <span class="apidocSignatureSpan">pm2.Common.</span>extend
        <span class="apidocSignatureSpan">(destination, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (destination, source){
  if (!source || typeof source != &#x27;object&#x27;) return destination;

  Object.keys(source).forEach(function(new_key) {
    if (source[new_key] != &#x27;[object Object]&#x27;)
      destination[new_key] = source[new_key];
  });

  return destination;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Mixed} env
 * @param {Function} cb
 * @return Literal
 */
God.executeApp = function executeApp(env, cb) {
var env_copy = Utility.clone(env);

Utility.<span class="apidocCodeKeywordSpan">extend</span>(env_copy, env_copy.env);

env_copy[&#x27;status&#x27;]         = cst.LAUNCHING_STATUS;
env_copy[&#x27;pm_uptime&#x27;]      = Date.now();
env_copy[&#x27;axm_actions&#x27;]    = [];
env_copy[&#x27;axm_monitor&#x27;]    = {};
env_copy[&#x27;axm_options&#x27;]    = {};
env_copy[&#x27;axm_dynamic&#x27;]    = {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Common.isConfigFile" id="apidoc.element.pm2.Common.isConfigFile">
        function <span class="apidocSignatureSpan">pm2.Common.</span>isConfigFile
        <span class="apidocSignatureSpan">(filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isConfigFile = function (filename) {
  if (typeof(filename) != &#x27;string&#x27;)
    return null;
  if (filename.indexOf(&#x27;.json&#x27;) != -1)
    return &#x27;json&#x27;;
  if (filename.indexOf(&#x27;.yml&#x27;) &#x3e; -1 || filename.indexOf(&#x27;.yaml&#x27;) &#x3e; -1)
    return &#x27;yaml&#x27;;
  if (filename.indexOf(&#x27;.config.js&#x27;) != -1)
    return &#x27;js&#x27;;
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Common.mergeEnvironmentVariables" id="apidoc.element.pm2.Common.mergeEnvironmentVariables">
        function <span class="apidocSignatureSpan">pm2.Common.</span>mergeEnvironmentVariables
        <span class="apidocSignatureSpan">(app_env, env_name, deploy_conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeEnvironmentVariables = function (app_env, env_name, deploy_conf) {
  var app = fclone(app_env);

  if (!app.env)
    app.env = {};

  if (env_name) {
    var finalEnv = {};

    // First merge variables from deploy.production.env object as least priority.
    if (deploy_conf &#x26;&#x26; deploy_conf[env_name] &#x26;&#x26; deploy_conf[env_name][&#x27;env&#x27;]) {
      util._extend(finalEnv, deploy_conf[env_name][&#x27;env&#x27;]);
    }

    // Then merge app.env object.
    util._extend(finalEnv, app.env);

    // Then, last and highest priority, merge the app.env_production object.
    if (&#x27;env_&#x27; + env_name in app) {
      util._extend(finalEnv, app[&#x27;env_&#x27; + env_name]);
    }

    app.env = finalEnv;
  }

  for (var key in app.env) {
    if (typeof app.env[key] == &#x27;object&#x27;) {
      app.env[key] = JSON.stringify(app.env[key]);
    }
  }

<span class="apidocCodeCommentSpan">  /**
   * Extra configuration update
   */
</span>  var current_conf = fclone(app);
  delete current_conf.env;
  app.env.current_conf = current_conf;

  // #2541 force resolution of node interpreter
  if (app.env.current_conf.exec_interpreter &#x26;&#x26;
      app.env.current_conf.exec_interpreter.indexOf(&#x27;@&#x27;) &#x3e; -1)
    resolveNodeInterpreter(app.env.current_conf);

  return app.env;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Common.parseConfig" id="apidoc.element.pm2.Common.parseConfig">
        function <span class="apidocSignatureSpan">pm2.Common.</span>parseConfig
        <span class="apidocSignatureSpan">(confObj, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseConfig = function (confObj, filename) {
  var yamljs = require(&#x27;yamljs&#x27;);
  var vm     = require(&#x27;vm&#x27;);

  if (!filename || filename == &#x27;pipe&#x27; || filename == &#x27;none&#x27; ||
      filename.indexOf(&#x27;.json&#x27;) &#x3e; -1) {
    var code = &#x27;(&#x27; + confObj + &#x27;)&#x27;;
    var sandbox = {};
    if (semver.satisfies(process.version, &#x27;&#x3e;= 0.12.0&#x27;)) {
      return vm.runInThisContext(code, sandbox, {
        filename: path.resolve(filename),
        displayErrors: false,
        timeout: 1000
      });
    } else {
      // Use the Node 0.10 API
      return vm.runInNewContext(code, sandbox, filename);
    }
  }
  else if (filename.indexOf(&#x27;.yml&#x27;) &#x3e; -1 ||
           filename.indexOf(&#x27;.yaml&#x27;) &#x3e; -1) {
    return yamljs.parse(confObj.toString());
  }
  else if (filename.indexOf(&#x27;.config.js&#x27;) &#x3e; -1) {
    var confPath = require.resolve(path.resolve(filename));
    delete require.cache[confPath];
    return require(confPath);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Common.prepareAppConf" id="apidoc.element.pm2.Common.prepareAppConf">
        function <span class="apidocSignatureSpan">pm2.Common.</span>prepareAppConf
        <span class="apidocSignatureSpan">(opts, app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepareAppConf = function (opts, app) {
<span class="apidocCodeCommentSpan">  /**
   * Minimum validation
   */
</span>  if (!app.script)
    return new Error(&#x27;No script path - aborting&#x27;);

  // Forbidden application name
  if (app.name == &#x27;push&#x27;)
    return new Error(&#x27;Push application name is not allowed&#x27;);

  if (app.automation == false)
    app.pmx = false;

  if (!app.node_args)
    app.node_args = [];

  if (app.port &#x26;&#x26; app.env)
    app.env.PORT = app.port;

  // CRON
  var ret;
  if ((ret = Common.sink.determineCron(app)) instanceof Error)
    return ret;

  // Resolve paths
  // app.pm_exec_path = path.join(resolveCWD(app.cwd, opts.cwd), app.script);
  // app.pm_cwd = path.dirname(app.pm_exec_path);
  // console.log(&#x27; hads&#x27;, app.pm_cwd);
  var cwd = null;

  if (app.cwd) {
    cwd = path.resolve(app.cwd);
    process.env.PWD = app.cwd;
  }

  // CWD option resolving
  cwd &#x26;&#x26; (cwd[0] != &#x27;/&#x27;) &#x26;&#x26; (cwd = path.resolve(process.cwd(), cwd));
  cwd = cwd || opts.cwd;

  // Full path script resolution
  app.pm_exec_path = path.resolve(cwd, app.script);


  // If script does not exists after resolution
  if (!fs.existsSync(app.pm_exec_path)) {
    var ckd;
    // Try resolve command available in $PATH
    if ((ckd = shelljs.which(app.script))) {
      if (typeof(ckd) !== &#x27;string&#x27;)
        ckd = ckd.toString();
      app.pm_exec_path = ckd;
    }
    else
      // Throw critical error
      return new Error(&#x27;script not found : &#x27; + app.pm_exec_path);
  }

  /**
   * Auto detect .map file and enable source map support automatically
   */
  if (app.disable_source_map_support != true) {
    try {
      if (fs.accessSync) {
        fs.accessSync(app.pm_exec_path + &#x27;.map&#x27;, fs.R_OK);
        app.source_map_support = true;
      }
      else {
        // Support for Node 0.10.x
        if (fs.existsSync(app.pm_exec_path + &#x27;.map&#x27;)) {
          app.source_map_support = true;
        }
      }
    } catch(e) {}
    delete app.disable_source_map_support;
  }

  delete app.script;

  // Set current env by first adding the process environment and then extending/replacing it
  // with env specified on command-line or JSON file.

  var env = {};

  /**
   * Do not copy internal pm2 environment variables if acting on process
   * is made from a programmatic script started by PM2
   */
  if (cst.PM2_PROGRAMMATIC)
    Common.safeExtend(env, process.env);
  else
    env = process.env;

  // Change to double check  (dropped , {pm_cwd: cwd})
  app.env = [{}, env, app.env || {}].reduce(function(e1, e2){
    return util._extend(e1, e2);
  });

  app.pm_cwd = cwd;
  // Interpreter
  Common.sink.resolveInterpreter(app);

  // Exec mode and cluster stuff
  Common.sink.determineExecMode(app);

  /**
   * Scary
   */
  var formated_app_name = app.name.replace(/[^a-zA-Z0-9\\.\\-]/g, &#x27;-&#x27;);

  [&#x27;log&#x27;, &#x27;out&#x27;, &#x27;error&#x27;, &#x27;pid&#x27;].forEach(function(f){
    var af = app[f + &#x27;_file&#x27;], ps, ext = (f == &#x27;pid&#x27; ? &#x27;pid&#x27;:&#x27;log&#x27;), isStd = !~[&#x27;log&#x27;, &#x27;pid&#x27;].indexOf(f);
    if (af) af = resolveHome(af);

    if ((f == &#x27;log&#x27; &#x26;&#x26; typeof af == &#x27;boolean&#x27; &#x26;&#x26; af) || (f != &#x27;log&#x27; &#x26;&#x26; !af)) {
      ps = [cst[&#x27;DEFAULT_&#x27; + ext.toUpperCase() + &#x27;_PATH&#x27;], formated_app_name + (isStd ? &#x27;-&#x27; + f : &#x27;&#x27;) + &#x27;.&#x27; + ext];
    } else if (f != &#x27;log&#x27; || (f == &#x27;log&#x27; &#x26;&#x26; af)) {
      ps = [cwd, af];

      var dir = path.dirname(path.resolve(cwd, af));
      if (!fs.existsSync(dir)) {
        Common.printError(cst.PREFIX_MSG_WARNING + &#x27;Folder does not exists: &#x27; + dir);
        Common.printOut(cst.PREFIX_MSG + &#x27;Creating folder: &#x27; + dir);
        mkdirp(dir, function(err) {
          if (!err) return;
          Common.printError(cst.PREFIX_MSG_ERR + &#x27;Could not create folder: &#x27; + path.dirname(af));
          throw new Error(&#x27;Could not create folder&#x27;);
        });
      }

    }
    // PM2 paths
    ps &#x26;&#x26; (app[&#x27;pm_&#x27; + (isStd ? f.substr(0, 3) + &#x27;_&#x27; : &#x27;&#x27;) + ext + &#x27;_path&#x27;] = path.resolve.apply(null, ps));
    delete app[f + &#x27;_file&#x27;];
  });

  return app;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} opts.pm2_home
 * @param {Object} appConf application configuration
 * @return app
 */
Common.resolveAppAttributes = function(opts, legacy_app) {
  var appConf = fclone(legacy_app);

  var app = Common.<span class="apidocCodeKeywordSpan">prepareAppConf</span>(opts, appConf);
  if (app instanceof Error) {
    Common.printError(cst.PREFIX_MSG_ERR + app.message);
    throw new Error(app.message);
  }
  return app;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Common.printError" id="apidoc.element.pm2.Common.printError">
        function <span class="apidocSignatureSpan">pm2.Common.</span>printError
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">printError = function (msg) {
  if (process.env.PM2_SILENT || process.env.PM2_PROGRAMMATIC === &#x27;true&#x27;) return false;
  if (msg instanceof Error)
    return console.error(msg.message);
  return console.error.apply(console, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
 * Daemon mode
 */
that.launchDaemon(function(err, child) {
  if (err) {
    Common.<span class="apidocCodeKeywordSpan">printError</span>(err);
    return cb ? cb(err) : process.exit(that.conf.ERROR_EXIT);
  }
  Common.printOut(that.conf.PREFIX_MSG + &#x27;PM2 Successfully daemonized&#x27;);
  that.launchRPC(function(err, meta) {
    return cb(null, {
      daemon_mode      : that.conf.daemon_mode,
      new_pm2_instance : true,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Common.printOut" id="apidoc.element.pm2.Common.printOut">
        function <span class="apidocSignatureSpan">pm2.Common.</span>printOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">printOut = function () {
  if (process.env.PM2_SILENT === &#x27;true&#x27; || process.env.PM2_PROGRAMMATIC === &#x27;true&#x27;) return false;
  return console.log.apply(console, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Daemon mode
 */
that.launchDaemon(function(err, child) {
  if (err) {
    Common.printError(err);
    return cb ? cb(err) : process.exit(that.conf.ERROR_EXIT);
  }
  Common.<span class="apidocCodeKeywordSpan">printOut</span>(that.conf.PREFIX_MSG + &#x27;PM2 Successfully daemonized&#x27;);
  that.launchRPC(function(err, meta) {
    return cb(null, {
      daemon_mode      : that.conf.daemon_mode,
      new_pm2_instance : true,
      rpc_socket_file  : that.rpc_socket_file,
      pub_socket_file  : that.pub_socket_file,
      pm2_home         : that.pm2_home
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Common.resolveAppAttributes" id="apidoc.element.pm2.Common.resolveAppAttributes">
        function <span class="apidocSignatureSpan">pm2.Common.</span>resolveAppAttributes
        <span class="apidocSignatureSpan">(opts, legacy_app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveAppAttributes = function (opts, legacy_app) {
  var appConf = fclone(legacy_app);

  var app = Common.prepareAppConf(opts, appConf);
  if (app instanceof Error) {
    Common.printError(cst.PREFIX_MSG_ERR + app.message);
    throw new Error(app.message);
  }
  return app;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Common.retErr" id="apidoc.element.pm2.Common.retErr">
        function <span class="apidocSignatureSpan">pm2.Common.</span>retErr
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retErr = function (e) {
  if (!e)
    return new Error(&#x27;Unidentified error&#x27;);
  if (e instanceof Error)
    return e;
  return new Error(e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Common.safeExtend" id="apidoc.element.pm2.Common.safeExtend">
        function <span class="apidocSignatureSpan">pm2.Common.</span>safeExtend
        <span class="apidocSignatureSpan">(origin, add)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">safeExtend = function (origin, add){
  if (!add || typeof add != &#x27;object&#x27;) return origin;

  //Ignore PM2&#x27;s set environment variables from the nested env
  var keysToIgnore = [&#x27;name&#x27;, &#x27;exec_mode&#x27;, &#x27;env&#x27;, &#x27;args&#x27;, &#x27;pm_cwd&#x27;, &#x27;exec_interpreter&#x27;, &#x27;pm_exec_path&#x27;, &#x27;node_args&#x27;, &#x27;pm_out_log_path
&#x27;, &#x27;pm_err_log_path&#x27;, &#x27;pm_pid_path&#x27;, &#x27;pm_id&#x27;, &#x27;status&#x27;, &#x27;pm_uptime&#x27;, &#x27;created_at&#x27;, &#x27;unstable_restarts&#x27;, &#x27;restart_time&#x27;, &#x27;axm_actions
&#x27;, &#x27;pmx_module&#x27;, &#x27;command&#x27;, &#x27;watch&#x27;, &#x27;versioning&#x27;, &#x27;vizion_runing&#x27;, &#x27;MODULE_DEBUG&#x27;, &#x27;pmx&#x27;, &#x27;axm_options&#x27;, &#x27;created_at&#x27;, &#x27;watch&#x27;, &#x27;
vizion&#x27;, &#x27;axm_dynamic&#x27;, &#x27;axm_monitor&#x27;, &#x27;instances&#x27;, &#x27;automation&#x27;, &#x27;autorestart&#x27;, &#x27;node_args&#x27;, &#x27;unstable_restart&#x27;, &#x27;treekill&#x27;, &#x27;exit_code
&#x27;];

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
  	//Only copy stuff into the env that we don&#x27;t have already.
  	if(keysToIgnore.indexOf(keys[i]) == -1 &#x26;&#x26; add[keys[i]] != &#x27;[object Object]&#x27;)
      origin[keys[i]] = add[keys[i]];
  }
  return origin;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var env = {};

/**
 * Do not copy internal pm2 environment variables if acting on process
 * is made from a programmatic script started by PM2
 */
if (cst.PM2_PROGRAMMATIC)
  Common.<span class="apidocCodeKeywordSpan">safeExtend</span>(env, process.env);
else
  env = process.env;

// Change to double check  (dropped , {pm_cwd: cwd})
app.env = [{}, env, app.env || {}].reduce(function(e1, e2){
  return util._extend(e1, e2);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Common.serialize" id="apidoc.element.pm2.Common.serialize">
        function <span class="apidocSignatureSpan">pm2.Common.</span>serialize
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialize = function (obj) {
  if (obj === null || obj === undefined) return {};
  return fclone(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Common.verifyConfs" id="apidoc.element.pm2.Common.verifyConfs">
        function <span class="apidocSignatureSpan">pm2.Common.</span>verifyConfs
        <span class="apidocSignatureSpan">(appConfs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyConfs = function (appConfs){
  if (!appConfs || appConfs.length == 0){
    return [];
  }

  // Make sure it is an Array.
  appConfs = [].concat(appConfs);

  var verifiedConf = [];

  for (var i = 0; i &#x3c; appConfs.length; i++) {
    var app = appConfs[i];

    if (app.disable_trace) {
      app.trace = false
      delete app.disable_trace;
    }

    // Warn deprecates.
    checkDeprecates(app);

    // Check Exec mode
    checkExecMode(app);

    // Render an app name if not existing.
    prepareAppName(app);

    var ret = Config.validateJSON(app);
    //debug(&#x27;After processing&#x27;, ret);
    // Show errors if existing.

    if (ret.errors &#x26;&#x26; ret.errors.length &#x3e; 0){
      ret.errors.forEach(function(err){
        warn(err);
      });
      // Return null == error
      return new Error(ret.errors);
    }
    verifiedConf.push(ret.config);
  }

  return verifiedConf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2.Configuration" id="apidoc.module.pm2.Configuration">module pm2.Configuration</a></h1>


    <h2>
        <a href="#apidoc.element.pm2.Configuration.get" id="apidoc.element.pm2.Configuration.get">
        function <span class="apidocSignatureSpan">pm2.Configuration.</span>get
        <span class="apidocSignatureSpan">(key, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (key, cb) {
  Configuration.getAll(function(err, data) {
    var climb = splitKey(key);

    climb.some(function(val) {
      if (!data[val]) {
        data = null;
        return true;
      }
      data = data[val];
      return false;
    });

    if (!data) return cb({err : &#x27;Unknown key&#x27;}, null);
    return cb(null, data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Configuration.getAll" id="apidoc.element.pm2.Configuration.getAll">
        function <span class="apidocSignatureSpan">pm2.Configuration.</span>getAll
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAll = function (cb) {
  fs.readFile(cst.PM2_MODULE_CONF_FILE, function(err, data) {
    if (err) return cb(err);
    return cb(null, JSON.parse(data));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  async.eachSeries(arrays, function(el, next) {
Configuration.set(el[0], el[1], next);
  }, cb);
};

Configuration.get = function(key, cb) {
  Configuration.<span class="apidocCodeKeywordSpan">getAll</span>(function(err, data) {
var climb = splitKey(key);

climb.some(function(val) {
  if (!data[val]) {
    data = null;
    return true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Configuration.getAllSync" id="apidoc.element.pm2.Configuration.getAllSync">
        function <span class="apidocSignatureSpan">pm2.Configuration.</span>getAllSync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllSync = function () {
  try {
    return JSON.parse(fs.readFileSync(cst.PM2_MODULE_CONF_FILE));
  } catch(e) {
    console.error(e.stack || e);
    return {};
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!data) return cb({err : &#x27;Unknown key&#x27;}, null);
  return cb(null, data);
});
};

Configuration.getSync = function(key) {
try {
  var data = Configuration.<span class="apidocCodeKeywordSpan">getAllSync</span>();
} catch(e) {
  return null;
}

var climb = splitKey(key);

climb.some(function(val) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Configuration.getSync" id="apidoc.element.pm2.Configuration.getSync">
        function <span class="apidocSignatureSpan">pm2.Configuration.</span>getSync
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSync = function (key) {
  try {
    var data = Configuration.getAllSync();
  } catch(e) {
    return null;
  }

  var climb = splitKey(key);

  climb.some(function(val) {
    if (!data[val]) {
      data = null;
      return true;
    }
    data = data[val];
    return false;
  });

  if (!data) return null;
  return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Configuration.multiset" id="apidoc.element.pm2.Configuration.multiset">
        function <span class="apidocSignatureSpan">pm2.Configuration.</span>multiset
        <span class="apidocSignatureSpan">(serial, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiset = function (serial, cb) {
  var arrays = [];
  serial = serial.match(/(?:[^ &#x22;]+|&#x22;[^&#x22;]*&#x22;)+/g);

  while (serial.length &#x3e; 0)
    arrays.push(serial.splice(0, 2));

  async.eachSeries(arrays, function(el, next) {
    Configuration.set(el[0], el[1], next);
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Configuration.set" id="apidoc.element.pm2.Configuration.set">
        function <span class="apidocSignatureSpan">pm2.Configuration.</span>set
        <span class="apidocSignatureSpan">(key, value, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (key, value, cb) {
  fs.readFile(cst.PM2_MODULE_CONF_FILE, function(err, data) {
    if (err) return cb(err);

    var json_conf = JSON.parse(data);

    var values = splitKey(key);

    if (values.length &#x3e; 0) {
      var levels = values;

      var tmp = json_conf;

      levels.forEach(function(key, index) {
        if (index == levels.length -1)
          tmp[key] = value;
        else if (!tmp[key]) {
          tmp[key] = {};
          tmp = tmp[key];
        }
        else {
          if (typeof(tmp[key]) != &#x27;object&#x27;)
            tmp[key] = {};
          tmp = tmp[key];
        }
      });

    }
    else {
      if (json_conf[key] &#x26;&#x26; typeof(json_conf[key]) === &#x27;string&#x27;)
        Common.printOut(cst.PREFIX_MSG + &#x27;Replacing current value key %s by %s&#x27;, key, value);

      json_conf[key] = value;
    }

    fs.writeFile(cst.PM2_MODULE_CONF_FILE, JSON.stringify(json_conf, null, 4), function(err, data) {
      if (err) return cb(err);

      return cb(null, json_conf);
    });
    return false;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var arrays = [];
serial = serial.match(/(?:[^ &#x22;]+|&#x22;[^&#x22;]*&#x22;)+/g);

while (serial.length &#x3e; 0)
  arrays.push(serial.splice(0, 2));

async.eachSeries(arrays, function(el, next) {
  Configuration.<span class="apidocCodeKeywordSpan">set</span>(el[0], el[1], next);
}, cb);
};

Configuration.get = function(key, cb) {
Configuration.getAll(function(err, data) {
  var climb = splitKey(key);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Configuration.setSync" id="apidoc.element.pm2.Configuration.setSync">
        function <span class="apidocSignatureSpan">pm2.Configuration.</span>setSync
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setSync = function (key, value) {
  try {
    var data = fs.readFileSync(cst.PM2_MODULE_CONF_FILE);
  } catch(e) {
    return null;
  }

  var json_conf = JSON.parse(data);

  var values = splitKey(key);

  if (values.length &#x3e; 0) {
    var levels = values;

    var tmp = json_conf;

    levels.forEach(function(key, index) {
      if (index == levels.length -1)
        tmp[key] = value;
      else if (!tmp[key]) {
        tmp[key] = {};
        tmp = tmp[key];
      }
      else {
        if (typeof(tmp[key]) != &#x27;object&#x27;)
          tmp[key] = {};
        tmp = tmp[key];
      }
    });

  }
  else {
    if (json_conf[key] &#x26;&#x26; typeof(json_conf[key]) === &#x27;string&#x27;)
      Common.printOut(cst.PREFIX_MSG + &#x27;Replacing current value key %s by %s&#x27;, key, value);

    json_conf[key] = value;
  }

  if (key === &#x27;all&#x27;)
    json_conf = {};

  try {
    fs.writeFileSync(cst.PM2_MODULE_CONF_FILE, JSON.stringify(json_conf));
    return json_conf;
  } catch(e) {
    console.error(e.message);
    return null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Configuration.unset" id="apidoc.element.pm2.Configuration.unset">
        function <span class="apidocSignatureSpan">pm2.Configuration.</span>unset
        <span class="apidocSignatureSpan">(key, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unset = function (key, cb) {
  fs.readFile(cst.PM2_MODULE_CONF_FILE, function(err, data) {
    if (err) return cb(err);

    var json_conf = JSON.parse(data);

    var values = splitKey(key);

    if (values.length &#x3e; 0) {
      var levels = values;

      var tmp = json_conf;

      levels.forEach(function(key, index) {
        if (index == levels.length -1)
          delete tmp[key];
        else if (!tmp[key]) {
          tmp[key] = {};
          tmp = tmp[key];
        }
        else {
          if (typeof(tmp[key]) != &#x27;object&#x27;)
            tmp[key] = {};
          tmp = tmp[key];
        }
      });

    }
    else
      delete json_conf[key];

    if (err) return cb(err);

    if (key === &#x27;all&#x27;)
      json_conf = {};

    fs.writeFile(cst.PM2_MODULE_CONF_FILE, JSON.stringify(json_conf), function(err, data) {
      if (err) return cb(err);

      return cb(null, json_conf);
    });
    return false;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Configuration.unsetSync" id="apidoc.element.pm2.Configuration.unsetSync">
        function <span class="apidocSignatureSpan">pm2.Configuration.</span>unsetSync
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsetSync = function (key) {
  try {
    var data = fs.readFileSync(cst.PM2_MODULE_CONF_FILE);
  } catch(e) {
    return null;
  }

  var json_conf = JSON.parse(data);

  var values = splitKey(key);

  if (values.length &#x3e; 0) {
    var levels = values;

    var tmp = json_conf;

    levels.forEach(function(key, index) {
      if (index == levels.length -1)
        delete tmp[key];
      else if (!tmp[key]) {
        tmp[key] = {};
        tmp = tmp[key];
      }
      else {
        if (typeof(tmp[key]) != &#x27;object&#x27;)
          tmp[key] = {};
        tmp = tmp[key];
      }
    });

  }
  else
    delete json_conf[key];

  if (key === &#x27;all&#x27;)
    json_conf = {};

  try {
    fs.writeFileSync(cst.PM2_MODULE_CONF_FILE, JSON.stringify(json_conf));
  } catch(e) {
    console.error(e.message);
    return null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2.Daemon" id="apidoc.module.pm2.Daemon">module pm2.Daemon</a></h1>


    <h2>
        <a href="#apidoc.element.pm2.Daemon.Daemon" id="apidoc.element.pm2.Daemon.Daemon">
        function <span class="apidocSignatureSpan">pm2.</span>Daemon
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Daemon = function (opts) {
  if (!opts) opts = {};

  this.rpc_socket_ready = false;
  this.pub_socket_ready = false;

  this.pub_socket_file = opts.pub_socket_file || cst.DAEMON_PUB_PORT;
  this.rpc_socket_file = opts.rpc_socket_file || cst.DAEMON_RPC_PORT;

  this.pid_path        = opts.pid_file || cst.PM2_PID_FILE_PATH;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2.Daemon.prototype" id="apidoc.module.pm2.Daemon.prototype">module pm2.Daemon.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pm2.Daemon.prototype.close" id="apidoc.element.pm2.Daemon.prototype.close">
        function <span class="apidocSignatureSpan">pm2.Daemon.prototype.</span>close
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (opts, cb) {
  var that = this;

  God.bus.emit(&#x27;pm2:kill&#x27;, {
    status : &#x27;killed&#x27;,
    msg    : &#x27;pm2 has been killed via CLI&#x27;
  });

  fmt.sep();
  fmt.title(&#x27;Stopping PM2&#x27;);
  fmt.field(&#x27;Time&#x27;, new Date());
  fmt.sep();

<span class="apidocCodeCommentSpan">  /**
   * Cleanly kill pm2
   */
</span>  that.rpc_socket.close(function() {
    console.log(&#x27;RPC closed&#x27;);
    that.pub_socket.close(function() {
      console.log(&#x27;PUB closed&#x27;);

      // notify cli that the daemon is shuting down (only under unix since windows doesnt handle signals)
      if (cst.IS_WINDOWS === false) {
        try {
          process.kill(parseInt(opts.pid), &#x27;SIGQUIT&#x27;);
        } catch(e) {
          console.error(&#x27;Could not send SIGQUIT to CLI&#x27;);
        }
      }

      console.log(&#x27;PM2 successfully stopped&#x27;);
      setTimeout(function() {
        process.exit(cst.SUCCESS_EXIT);
      }, 2);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Client.prototype.pingDaemon = function pingDaemon(cb) {
var req    = axon.socket(&#x27;req&#x27;);
var client = new rpc.Client(req);

debug(&#x27;[PING PM2] Trying to connect to server&#x27;);

client.sock.once(&#x27;reconnect attempt&#x27;, function() {
  client.sock.<span class="apidocCodeKeywordSpan">close</span>();
  debug(&#x27;Daemon not launched&#x27;);
  process.nextTick(function() {
    return cb(false);
  });
});

client.sock.once(&#x27;connect&#x27;, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Daemon.prototype.gracefullExit" id="apidoc.element.pm2.Daemon.prototype.gracefullExit">
        function <span class="apidocSignatureSpan">pm2.Daemon.prototype.</span>gracefullExit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gracefullExit = function () {
  var that = this;

  console.log(&#x27;pm2 has been killed by signal, dumping process list before exit...&#x27;);

  God.dumpProcessList(function() {

    var processes = God.getFormatedProcesses();

    async.eachLimit(processes, 1, function(proc, next) {
      console.log(&#x27;Deleting process %s&#x27;, proc.pm2_env.pm_id);
      God.deleteProcessId(proc.pm2_env.pm_id, function() {
        return next();
      });
      return false;
    }, function(err) {
      try {
        fs.unlinkSync(that.pid_path);
      } catch(e) {}
      console.log(&#x27;[PM2] Exited peacefully&#x27;);
      process.exit(0);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Daemon.prototype.handleSignals" id="apidoc.element.pm2.Daemon.prototype.handleSignals">
        function <span class="apidocSignatureSpan">pm2.Daemon.prototype.</span>handleSignals
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleSignals = function () {
  var that = this;

  process.on(&#x27;SIGTERM&#x27;, that.gracefullExit);
  process.on(&#x27;SIGINT&#x27;, that.gracefullExit);
  process.on(&#x27;SIGHUP&#x27;, function() {});
  process.on(&#x27;SIGQUIT&#x27;, that.gracefullExit);
  process.on(&#x27;SIGUSR2&#x27;, function() {
    God.reloadLogs({}, function() {});
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Write Daemon PID into file
try {
  fs.writeFileSync(that.pid_path, process.pid);
} catch (e) {
  console.error(e.stack || e);
}

this.<span class="apidocCodeKeywordSpan">handleSignals</span>();

/**
 * Pub system for real time notifications
 */
this.pub    = axon.socket(&#x27;pub-emitter&#x27;);

this.pub_socket = this.pub.bind(this.pub_socket_file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Daemon.prototype.innerStart" id="apidoc.element.pm2.Daemon.prototype.innerStart">
        function <span class="apidocSignatureSpan">pm2.Daemon.prototype.</span>innerStart
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">innerStart = function (cb) {
  var that = this;

  if (!cb) cb = function() {
    fmt.sep();
    fmt.title(&#x27;New PM2 Daemon started&#x27;);
    fmt.field(&#x27;Time&#x27;, new Date());
    fmt.field(&#x27;PM2 version&#x27;, pkg.version);
    fmt.field(&#x27;Node.js version&#x27;, process.versions.node);
    fmt.field(&#x27;Current arch&#x27;, process.arch);
    fmt.field(&#x27;PM2 home&#x27;, cst.PM2_HOME);
    fmt.field(&#x27;PM2 PID file&#x27;, that.pid_path);
    fmt.field(&#x27;RPC socket file&#x27;, that.rpc_socket_file);
    fmt.field(&#x27;BUS socket file&#x27;, that.pub_socket_file);
    fmt.field(&#x27;Application log path&#x27;, cst.DEFAULT_LOG_PATH);
    fmt.field(&#x27;Process dump file&#x27;, cst.DUMP_FILE_PATH);
    fmt.field(&#x27;Concurrent actions&#x27;, cst.CONCURRENT_ACTIONS);
    fmt.field(&#x27;SIGTERM timeout&#x27;, cst.KILL_TIMEOUT);
    fmt.sep();
  };

  // Write Daemon PID into file
  try {
    fs.writeFileSync(that.pid_path, process.pid);
  } catch (e) {
    console.error(e.stack || e);
  }

  this.handleSignals();

<span class="apidocCodeCommentSpan">  /**
   * Pub system for real time notifications
   */
</span>  this.pub    = axon.socket(&#x27;pub-emitter&#x27;);

  this.pub_socket = this.pub.bind(this.pub_socket_file);

  this.pub_socket.once(&#x27;bind&#x27;, function() {
    that.pub_socket_ready = true;
    that.sendReady(cb);
  });

  /**
   * Rep/Req - RPC system to interact with God
   */
  this.rep    = axon.socket(&#x27;rep&#x27;);

  var server = new rpc.Server(this.rep);

  this.rpc_socket = this.rep.bind(this.rpc_socket_file);

  this.rpc_socket.once(&#x27;bind&#x27;, function() {
    that.rpc_socket_ready = true;
    that.sendReady(cb);
  });

  var profiler;

  try {
    profiler = require(&#x27;v8-profiler&#x27;);
  } catch(e) {
    profiler = null;
  }

  /**
   * Memory Snapshot
   */
  function snapshotPM2(msg, cb) {
    if (profiler == null) {
      console.log(&#x27;v8-profiler is not available&#x27;);
      return cb(new Error(&#x27;v8-profiler is not available&#x27;));
    }

    var snapshot1 = profiler.takeSnapshot();
    var path = require(&#x27;path&#x27;);
    snapshot1.export(function(error, result) {
      fs.writeFile(msg.pwd, result, function() {
        snapshot1.delete();
        return cb(null, {file : msg.pwd});
      });
    });
  }

  function startProfilingPM2(msg, cb) {
    if (profiler == null) {
      console.log(&#x27;v8-profiler is not available&#x27;);
      return cb(new Error(&#x27;v8-profiler is not available&#x27;));
    }

    profiler.startProfiling(&#x27;cpu&#x27;);

    process.nextTick(function() {
      return cb(null, {msg : &#x27;profiling started&#x27;});
    });
  }

  function stopProfilingPM2(msg, cb) {
    if (profiler == null) {
      console.log(&#x27;v8-profiler is not available&#x27;);
      return cb(new Error(&#x27;v8-profiler is not available&#x27;));
    }

    var profile1 = profiler.stopProfiling(&#x27;cpu&#x27;);

    profile1.export()
      .pipe(fs.createWriteStream(msg.pwd))
      .on(&#x27;finish&#x27;, function() {
        profile1.delete();
        return cb(null, {file : msg.pwd});
      });
  }

  server.expose({
    killMe                  : that.close.bind(this),
    snapshotPM2             : snapshotPM2,
    profileStart            : startProfilingPM2,
    profileStop             : stopProfilingPM2,
    prepare                 : God.prepare,
    getMonitorData          : God.getMonitorData,
    getSystemData           : God.getSystemData,

    startProcessId          : God.startProcessId,
    stopProcessId           : God.stopProcessId,
    restartProcessId        : God.restartProcessId,
    deleteProcessId         : God.deleteProcessId,

    softReloadProcessId     : God.softReloadProcessId,
    reloadProcessId         : God.reloadProcessId,
    duplicateProcessId      : God.duplicateProcessId,
    resetMetaProcessId      : God.resetMetaProcessId,
    stopWatch               : God.stopWatch,
    startWatch              : God.startWatch,
    toggleWatch             : God.toggleWatch,
    notifyByProcessId       : God.notifyByProcessId,

    notifyKillPM2           : God.notifyKillPM2,
    forceGc                 : God.forceGc,

    msgProcess              : God.msgProcess,
    sendDataToProcessId     : God.sendDataToProcessId,
    sendSignalToProcessId   : God.sendSignalToProcessId,
    sendSignalToProcessName : God.sendSignalToProcessName, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  pub_socket_file : that.conf.DAEMON_PUB_PORT,
  rpc_socket_file : that.conf.DAEMON_RPC_PORT,
  pid_file        : that.conf.PM2_PID_FILE_PATH
});

console.log(&#x27;Launching in no daemon mode&#x27;);

daemon.<span class="apidocCodeKeywordSpan">innerStart</span>(function() {
  KMDaemon.launchAndInteract(that.conf, {
    machine_name : that.machine_name,
    public_key   : that.public_key,
    secret_key   : that.secret_key
  }, function(err, data, interactor_proc) {
    that.interactor_process = interactor_proc;
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Daemon.prototype.sendReady" id="apidoc.element.pm2.Daemon.prototype.sendReady">
        function <span class="apidocSignatureSpan">pm2.Daemon.prototype.</span>sendReady
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendReady = function (cb) {
  // Send ready message to Client
  if (this.rpc_socket_ready == true &#x26;&#x26; this.pub_socket_ready == true) {
    cb(null, {
      pid         : process.pid,
      pm2_version : pkg.version
    });
    if (typeof(process.send) != &#x27;function&#x27;)
      return false;

    process.send({
      online      : true,
      success     : true,
      pid         : process.pid,
      pm2_version : pkg.version
    });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
this.pub    = axon.socket(&#x27;pub-emitter&#x27;);

this.pub_socket = this.pub.bind(this.pub_socket_file);

this.pub_socket.once(&#x27;bind&#x27;, function() {
  that.pub_socket_ready = true;
  that.<span class="apidocCodeKeywordSpan">sendReady</span>(cb);
});

/**
 * Rep/Req - RPC system to interact with God
 */
this.rep    = axon.socket(&#x27;rep&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Daemon.prototype.start" id="apidoc.element.pm2.Daemon.prototype.start">
        function <span class="apidocSignatureSpan">pm2.Daemon.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function () {
  var that = this;
  var d = domain.create();

  d.once(&#x27;error&#x27;, function(err) {
    fmt.sep();
    fmt.title(&#x27;PM2 global error caught&#x27;);
    fmt.field(&#x27;Time&#x27;, new Date());
    console.error(err.message);
    console.error(err.stack);
    fmt.sep();

    console.error(&#x27;[PM2] Resurrecting PM2&#x27;);

		var path = cst.IS_WINDOWS ? process.cwd() + &#x27;/bin/pm2&#x27; : process.env[&#x27;_&#x27;];
    var fork_new_pm2 = require(&#x27;child_process&#x27;).spawn(&#x27;node&#x27;, [path, &#x27;update&#x27;], {
      detached: true,
      stdio: &#x27;inherit&#x27;
    });

    fork_new_pm2.on(&#x27;close&#x27;, function() {
      console.log(&#x27;PM2 successfully forked&#x27;);
      process.exit(0);
    })

  });

  d.run(function() {
    that.innerStart();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
else if (method.indexOf(&#x27;restartProcessId&#x27;) !== -1 &#x26;&#x26; process.argv.indexOf(&#x27;--watch&#x27;) &#x3e; -1) {
  delete app_conf.env.current_conf.watch;
  this.toggleWatch(method, app_conf);
}

if (!this.client || !this.client.call) {
  this.<span class="apidocCodeKeywordSpan">start</span>(function(error) {
    if (error) {
      if (fn)
        return fn(error);
      console.error(error);
      return process.exit(0);
    }
    return self.client.call(method, app_conf, fn);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Daemon.prototype.startLogic" id="apidoc.element.pm2.Daemon.prototype.startLogic">
        function <span class="apidocSignatureSpan">pm2.Daemon.prototype.</span>startLogic
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startLogic = function () {
  var that = this;

<span class="apidocCodeCommentSpan">  /**
   * Action treatment specifics
   * Attach actions to pm2_env.axm_actions variables (name + options)
   */
</span>  God.bus.on(&#x27;axm:action&#x27;, function axmActions(msg) {
    var pm2_env = msg.process;
    var exists  = false;
    var axm_action = msg.data;

    if (!pm2_env || !God.clusters_db[pm2_env.pm_id])
      return console.error(&#x27;Unknown id %s&#x27;, pm2_env.pm_id);

    if (!God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions)
      God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions = [];

    God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions.forEach(function(actions) {
      if (actions.action_name == axm_action.action_name)
        exists = true;
    });

    if (exists === false) {
      debug(&#x27;Adding action&#x27;, axm_action);
      God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions.push(axm_action);
    }
    msg = null;
  });

  /**
   * Configure module
   */
  God.bus.on(&#x27;axm:option:configuration&#x27;, function axmMonitor(msg) {
    if (!msg.process)
      return console.error(&#x27;[axm:option:configuration] no process defined&#x27;);

    if (!God.clusters_db[msg.process.pm_id])
      return console.error(&#x27;[axm:option:configuration] Unknown id %s&#x27;, msg.process.pm_id);

    try {
      // Application Name nverride
      if (msg.data.name)
        God.clusters_db[msg.process.pm_id].pm2_env.name = msg.data.name;

      Object.keys(msg.data).forEach(function(conf_key) {
        God.clusters_db[msg.process.pm_id].pm2_env.axm_options[conf_key] = Utility.clone(msg.data[conf_key]);
      });
    } catch(e) {
      console.error(e.stack || e);
    }
    msg = null;
  });

  /**
   * Process monitoring data (probes)
   */
  God.bus.on(&#x27;axm:monitor&#x27;, function axmMonitor(msg) {
    if (!msg.process)
      return console.error(&#x27;[axm:monitor] no process defined&#x27;);

    if (!msg.process || !God.clusters_db[msg.process.pm_id])
      return console.error(&#x27;Unknown id %s&#x27;, msg.process.pm_id);

    util._extend(God.clusters_db[msg.process.pm_id].pm2_env.axm_monitor, Utility.clone(msg.data));
    msg = null;
  });

  /**
   * Broadcast messages
   */
  God.bus.onAny(function(event, data_v) {
    if ([&#x27;axm:action&#x27;,
         &#x27;axm:monitor&#x27;,
         &#x27;axm:option:setPID&#x27;,
         &#x27;axm:option:configuration&#x27;].indexOf(event) &#x3e; -1) {
      data_v = null;
      return false;
    }
    that.pub.emit(event, Utility.clone(data_v));
    data_v = null;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  sendSignalToProcessName : God.sendSignalToProcessName,

  ping                    : God.ping,
  getVersion              : God.getVersion,
  reloadLogs              : God.reloadLogs
});

this.<span class="apidocCodeKeywordSpan">startLogic</span>();
}

Daemon.prototype.close = function(opts, cb) {
var that = this;

God.bus.emit(&#x27;pm2:kill&#x27;, {
  status : &#x27;killed&#x27;,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2.God" id="apidoc.module.pm2.God">module pm2.God</a></h1>


    <h2>
        <a href="#apidoc.element.pm2.God.checkProcess" id="apidoc.element.pm2.God.checkProcess">
        function <span class="apidocSignatureSpan">pm2.God.</span>checkProcess
        <span class="apidocSignatureSpan">(pid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkProcess = function (pid) {
  if (!pid) return false;

  try {
    // Sending 0 signal do not kill the process
    process.kill(pid, 0);
    return true;
  }
  catch (err) {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.deleteProcessId" id="apidoc.element.pm2.God.deleteProcessId">
        function <span class="apidocSignatureSpan">pm2.God.</span>deleteProcessId
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteProcessId = function (id, cb) {
  God.stopProcessId(id, function(err, proc) {
    if (err) return cb(God.logAndGenerateError(err), {});
    // ! transform to slow object
    delete God.clusters_db[id];

    if (Object.keys(God.clusters_db).length == 0)
      God.next_id = 0;
    return cb(null, proc);
  });
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  God.dumpProcessList(function() {

var processes = God.getFormatedProcesses();

async.eachLimit(processes, 1, function(proc, next) {
  console.log(&#x27;Deleting process %s&#x27;, proc.pm2_env.pm_id);
  God.<span class="apidocCodeKeywordSpan">deleteProcessId</span>(proc.pm2_env.pm_id, function() {
    return next();
  });
  return false;
}, function(err) {
  try {
    fs.unlinkSync(that.pid_path);
  } catch(e) {}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.dumpProcessList" id="apidoc.element.pm2.God.dumpProcessList">
        function <span class="apidocSignatureSpan">pm2.God.</span>dumpProcessList
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dumpProcessList = function (cb) {
  var process_list = [];
  var apps         = Utility.clone(God.getFormatedProcesses());

  // Don&#x27;t override the actual dump file if process list is empty
  // unless user explicitely did `pm2 dump`.
  // This often happens when PM2 crashed, we don&#x27;t want to override
  // the dump file with an empty list of process.
  if (!apps[0]) {
    debug(&#x27;[PM2] Did not override dump file because list of processes is empty&#x27;);
    return cb(null, {success:true, process_list: process_list});
  }

  function fin(err) {
    try {
      fs.writeFileSync(cst.DUMP_FILE_PATH, JSON.stringify(process_list));
    } catch (e) {
      console.error(e.stack || e);
    }
    return cb(null, {success:true, process_list: process_list});
  }

  function saveProc(apps) {
    if (!apps[0])
      return fin(null);
    delete apps[0].pm2_env.instances;
    delete apps[0].pm2_env.pm_id;
    // Do not dump modules
    if (!apps[0].pm2_env.pmx_module)
      process_list.push(apps[0].pm2_env);
    apps.shift();
    return saveProc(apps);
  }
  saveProc(apps);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Daemon.prototype.gracefullExit = function() {
  var that = this;

  console.log(&#x27;pm2 has been killed by signal, dumping process list before exit...&#x27;);

  God.<span class="apidocCodeKeywordSpan">dumpProcessList</span>(function() {

var processes = God.getFormatedProcesses();

async.eachLimit(processes, 1, function(proc, next) {
  console.log(&#x27;Deleting process %s&#x27;, proc.pm2_env.pm_id);
  God.deleteProcessId(proc.pm2_env.pm_id, function() {
    return next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.duplicateProcessId" id="apidoc.element.pm2.God.duplicateProcessId">
        function <span class="apidocSignatureSpan">pm2.God.</span>duplicateProcessId
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">duplicateProcessId = function (id, cb) {
  if (!(id in God.clusters_db))
    return cb(God.logAndGenerateError(id + &#x27; id unknown&#x27;), {});

  if (!God.clusters_db[id] || !God.clusters_db[id].pm2_env)
    return cb(God.logAndGenerateError(&#x27;Error when getting proc || proc.pm2_env&#x27;), {});

  var proc = Utility.clone(God.clusters_db[id].pm2_env);

  delete proc.created_at;
  delete proc.pm_id;

  God.executeApp(proc, function(err, clu) {
    God.notify(&#x27;start&#x27;, clu, true);
    cb(err, [Utility.clone(clu)]);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.executeApp" id="apidoc.element.pm2.God.executeApp">
        function <span class="apidocSignatureSpan">pm2.God.</span>executeApp
        <span class="apidocSignatureSpan">(env, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function executeApp(env, cb) {
  var env_copy = Utility.clone(env);

  Utility.extend(env_copy, env_copy.env);

  env_copy[&#x27;status&#x27;]         = cst.LAUNCHING_STATUS;
  env_copy[&#x27;pm_uptime&#x27;]      = Date.now();
  env_copy[&#x27;axm_actions&#x27;]    = [];
  env_copy[&#x27;axm_monitor&#x27;]    = {};
  env_copy[&#x27;axm_options&#x27;]    = {};
  env_copy[&#x27;axm_dynamic&#x27;]    = {};
  env_copy[&#x27;vizion_running&#x27;] =
    env_copy[&#x27;vizion_running&#x27;] !== undefined ? env_copy[&#x27;vizion_running&#x27;] : false;

  if (!env_copy.created_at)
    env_copy[&#x27;created_at&#x27;] = Date.now();

<span class="apidocCodeCommentSpan">  /**
   * Enter here when it&#x27;s the first time that the process is created
   * 1 - Assign a new id
   * 2 - Reset restart time and unstable_restarts
   * 3 - Assign a log file name depending on the id
   * 4 - If watch option is set, look for changes
   */
</span>  if (env_copy[&#x27;pm_id&#x27;] === undefined) {
    env_copy[&#x27;pm_id&#x27;]             = God.getNewId();
    env_copy[&#x27;restart_time&#x27;]      = 0;
    env_copy[&#x27;unstable_restarts&#x27;] = 0;

    // add -pm_id to pid file
    env_copy.pm_pid_path = env_copy.pm_pid_path.replace(/-[0-9]+\.pid$|\.pid$/g, &#x27;-&#x27; + env_copy[&#x27;pm_id&#x27;] + &#x27;.pid&#x27;);

    // If merge option, dont separate the logs
    if (!env_copy[&#x27;merge_logs&#x27;]) {
      [&#x27;&#x27;, &#x27;_out&#x27;, &#x27;_err&#x27;].forEach(function(k){
        var key = &#x27;pm&#x27; + k + &#x27;_log_path&#x27;;
        env_copy[key] &#x26;&#x26; (env_copy[key] = env_copy[key].replace(/-[0-9]+\.log$|\.log$/g, &#x27;-&#x27; + env_copy[&#x27;pm_id&#x27;] + &#x27;.log&#x27;));
      });
    }

    // Initiate watch file
    if (env_copy[&#x27;watch&#x27;]) {
      God.watch.enable(env_copy);
    }
  }

  /**
   * Avoid `Resource leak error` due to &#x27;disconnect&#x27; event
   * not being fired sometimes
   */
  var workAround = function(worker) {
    var listeners = null;

    listeners = worker.process.listeners(&#x27;exit&#x27;)[0];
    var exit = listeners[Object.keys(listeners)[0]];

    listeners = worker.process.listeners(&#x27;disconnect&#x27;)[0];
    var disconnect = listeners[Object.keys(listeners)[0]];

    worker.process.removeListener(&#x27;exit&#x27;, exit);
    worker.process.once(&#x27;exit&#x27;, function(exitCode, signalCode) {
      // If disconnect() has not been called
      // earlier, we call it here.
      if (worker.state != &#x27;disconnected&#x27;)
        disconnect();
      // Call the original &#x27;exit&#x27; callback
      exit(exitCode, signalCode);
    });
  };

  /** Callback when application is launched */
  var readyCb = function ready(proc) {
      if (proc.pm2_env.vizion !== false &#x26;&#x26; proc.pm2_env.vizion !== &#x22;false&#x22;)
        God.finalizeProcedure(proc);
      else
        God.notify(&#x27;online&#x27;, proc);

      proc.pm2_env.status = cst.ONLINE_STATUS;
      console.log(&#x27;App name:%s id:%s online&#x27;, proc.pm2_env.name, proc.pm2_env.pm_id);
      if (cb) cb(null, proc);
  }

  if (env_copy.exec_mode === &#x27;cluster_mode&#x27;) {
    /**
     * Cluster mode logic (for NodeJS apps)
     */
    God.nodeApp(env_copy, function nodeApp(err, clu) {
      if (cb &#x26;&#x26; err) return cb(err);
      if (err) return false;

      var old_env = God.clusters_db[clu.pm2_env.pm_id];

      if (old_env) {
        old_env = null;
        God.clusters_db[clu.pm2_env.pm_id] = null;
      }

      God.clusters_db[clu.pm2_env.pm_id] = clu;

      if (semver.lt(process.version, &#x27;7.0.0&#x27;) === true) {
        // Temporary
        workAround(clu);
      }

      clu.once(&#x27;error&#x27;, function(err) {
        console.error(err.stack || err);
        clu.pm2_env.status = cst.ERRORED_STATUS;
        try {
          clu.destroy &#x26;&#x26; clu.destroy();
        }
        catch (e) {
          console.error(e.stack || e);
          God.handleExit(clu, cst.ERROR_EXIT);
        }
      });

      clu.once(&#x27;disconnect&#x27;, function() {
        console.log(&#x27;App name:%s id:%s disconnected&#x27;, clu.pm2_env.name, clu.pm2_env.pm_id);
      });

      clu.once(&#x27;exit&#x27;, function cluExit(code, signal) {
        God.handleExit(clu, code || 0, signal || &#x27;SIGINT&#x27;);
      });

      return clu.once(&#x27;online&#x27;, function () {
        return readyCb(clu);
      });
    });
  }
  else {
    /**
     * Fork mode logic
     */
    God.forkMode(env_copy, function forkMode(err, clu) {
      if (cb &#x26;&#x26; err) return cb(err);
      if (err) return false; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (!stopping &#x26;&#x26; !overlimit) {
    //make this property unenumerable
    Object.defineProperty(proc.pm2_env, &#x27;restart_task&#x27;, {configurable: true, writable: true});
    proc.pm2_env.restart_task = setTimeout(function() {
      proc.pm2_env.restart_time += 1;
      God.<span class="apidocCodeKeywordSpan">executeApp</span>(proc.pm2_env);
    }, restart_delay);
  }

  return false;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.finalizeProcedure" id="apidoc.element.pm2.God.finalizeProcedure">
        function <span class="apidocSignatureSpan">pm2.God.</span>finalizeProcedure
        <span class="apidocSignatureSpan">(proc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function finalizeProcedure(proc) {
  var last_path    = &#x27;&#x27;;
  var current_path = proc.pm2_env.cwd || path.dirname(proc.pm2_env.pm_exec_path);
  var proc_id      = proc.pm2_env.pm_id;

  if (proc.pm2_env.vizion_running === true) {
    debug(&#x27;Vizion is already running for proc id: %d, skipping this round&#x27;, proc_id);
    return God.notify(&#x27;online&#x27;, proc);
  }

  proc.pm2_env.vizion_running = true;
  vizion.analyze({folder : current_path}, function recur_path(err, meta){
    var proc = God.clusters_db[proc_id];

    if (err)
      debug(err.stack || err);

    if (!proc ||
        !proc.pm2_env ||
        proc.pm2_env.status == cst.STOPPED_STATUS ||
        proc.pm2_env.status == cst.STOPPING_STATUS) {
      return console.error(&#x27;Proc is not defined anymore or is being killed&#x27;);
    }

    proc.pm2_env.vizion_running = false;

    if (!err) {
      proc.pm2_env.versioning = meta;
      proc.pm2_env.versioning.repo_path = current_path;
      God.notify(&#x27;online&#x27;, proc);
    }
    else if (err &#x26;&#x26; current_path === last_path) {
      proc.pm2_env.versioning = null;
      God.notify(&#x27;online&#x27;, proc);
    }
    else {
      last_path = current_path;
      current_path = path.dirname(current_path);
      proc.pm2_env.vizion_running = true;
      vizion.analyze({folder : current_path}, recur_path);
    }
    return false;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    exit(exitCode, signalCode);
  });
};

/** Callback when application is launched */
var readyCb = function ready(proc) {
    if (proc.pm2_env.vizion !== false &#x26;&#x26; proc.pm2_env.vizion !== &#x22;false&#x22;)
      God.<span class="apidocCodeKeywordSpan">finalizeProcedure</span>(proc);
    else
      God.notify(&#x27;online&#x27;, proc);

    proc.pm2_env.status = cst.ONLINE_STATUS;
    console.log(&#x27;App name:%s id:%s online&#x27;, proc.pm2_env.name, proc.pm2_env.pm_id);
    if (cb) cb(null, proc);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.findByName" id="apidoc.element.pm2.God.findByName">
        function <span class="apidocSignatureSpan">pm2.God.</span>findByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findByName = function (name) {
  var db = God.clusters_db;
  var arr = [];

  if (name == &#x27;all&#x27;) {
    for (var key in db) {
      // Avoid _old_proc process style
      if (typeof(God.clusters_db[key].pm2_env.pm_id) === &#x27;number&#x27;)
        arr.push(db[key]);
    }
    return arr;
  }

  for (var key in db) {
    if (God.clusters_db[key].pm2_env.name == name ||
        God.clusters_db[key].pm2_env.pm_exec_path == p.resolve(name)) {
      arr.push(db[key]);
    }
  }
  return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.findProcessById" id="apidoc.element.pm2.God.findProcessById">
        function <span class="apidocSignatureSpan">pm2.God.</span>findProcessById
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findProcessById(id) {
  return God.clusters_db[id] ? God.clusters_db[id] : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.forceGc" id="apidoc.element.pm2.God.forceGc">
        function <span class="apidocSignatureSpan">pm2.God.</span>forceGc
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forceGc = function (opts, cb) {
  if (global.gc) {
    global.gc();
    debug(&#x27;Garbage collection triggered successfully&#x27;);
    if (cb) cb(null, {success: true});
  }
  else {
    debug(&#x27;Garbage collection failed&#x27;);
    if (cb) cb(null, {success: false});
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.forkMode" id="apidoc.element.pm2.God.forkMode">
        function <span class="apidocSignatureSpan">pm2.God.</span>forkMode
        <span class="apidocSignatureSpan">(pm2_env, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forkMode(pm2_env, cb) {
  var command = &#x27;&#x27;;
  var args    = [];

  console.log(&#x27;Starting execution sequence in -fork mode- for app name:%s id:%s&#x27;,
              pm2_env.name,
              pm2_env.pm_id);
  var spawn = require(&#x27;child_process&#x27;).spawn;

  var interpreter = pm2_env.exec_interpreter || &#x27;node&#x27;;
  var pidFile     = pm2_env.pm_pid_path;

  if (interpreter !== &#x27;none&#x27;) {
    command = interpreter;

    if (pm2_env.node_args &#x26;&#x26; Array.isArray(pm2_env.node_args)) {
      args = args.concat(pm2_env.node_args);
    }

    // Deprecated - to remove at some point
    if (process.env.PM2_NODE_OPTIONS) {
      args = args.concat(process.env.PM2_NODE_OPTIONS.split(&#x27; &#x27;));
    }

    if (interpreter === &#x27;node&#x27; || RegExp(&#x27;node$&#x27;).test(interpreter)) {
      args.push(path.resolve(path.dirname(module.filename), &#x27;..&#x27;, &#x27;ProcessContainerFork.js&#x27;));
    }
    else
      args.push(pm2_env.pm_exec_path);
  }
  else {
    command = pm2_env.pm_exec_path;
    args = [ ];
  }

  if (pm2_env.args) {
    args = args.concat(pm2_env.args);
  }

  // piping stream o file
  var stds = {
    out: pm2_env.pm_out_log_path,
    err: pm2_env.pm_err_log_path
  };

  // entire log std if necessary.
  if (&#x27;pm_log_path&#x27; in pm2_env){
    stds.std = pm2_env.pm_log_path;
  }

  log(&#x22;stds: %j&#x22;, stds);

  Utility.startLogging(stds, function(err, result) {
    if (err) {
      God.logAndGenerateError(err);
      return cb(err);
    };

    try {
      var cspr = spawn(command, args, {
        env      : pm2_env,
        detached : true,
        cwd      : pm2_env.pm_cwd || process.cwd(),
        stdio    : [&#x27;pipe&#x27;, &#x27;pipe&#x27;, &#x27;pipe&#x27;, &#x27;ipc&#x27;] //Same as fork() in node core
      });
    } catch(e) {
      God.logAndGenerateError(e);
      return cb(e);
    }

    cspr.process = {};
    cspr.process.pid = cspr.pid;
    cspr.pm2_env = pm2_env;

    cspr.stderr.on(&#x27;data&#x27;, function forkErrData(data) {
      var log_data = null;

      if (pm2_env.log_type &#x26;&#x26; pm2_env.log_type === &#x27;json&#x27;) {
        log_data = JSON.stringify({
          message : data.toString(),
        timestamp : pm2_env.log_date_format ? moment().format(pm2_env.log_date_format) : new Date().toISOString(),
          type : &#x27;err&#x27;,
          process_id : cspr.pm2_env.pm_id,
          app_name : cspr.pm2_env.name
        }) + &#x27;\n&#x27;;
      }
      else if (pm2_env.log_date_format)
        log_data = moment().format(pm2_env.log_date_format) + &#x27;: &#x27; + data.toString();
      else
        log_data = data.toString();

      stds.std &#x26;&#x26; stds.std.write &#x26;&#x26; stds.std.write(log_data);

      // hardcoded values of special log path to not write on disk
      if (pm2_env.pm_err_log_path !== &#x27;NULL&#x27; &#x26;&#x26; pm2_env.pm_err_log_path !== &#x27;/dev/null&#x27;) {
        stds.err.write &#x26;&#x26; stds.err.write(log_data);
      }

      God.bus.emit(&#x27;log:err&#x27;, {
        process : {
          pm_id      : cspr.pm2_env.pm_id,
          name       : cspr.pm2_env.name,
          rev        : (cspr.pm2_env.versioning &#x26;&#x26; cspr.pm2_env.versioning.revision) ? cspr.pm2_env.versioning.revision : null
        },
        at  : Utility.getDate(),
        data : log_data
      });
    });

    cspr.stdout.on(&#x27;data&#x27;, function forkOutData(data) {
      var log_data = null;

      if (pm2_env.log_type &#x26;&#x26; pm2_env.log_type === &#x27;json&#x27;) {
        log_data = JSON.stringify({
          message : data.toString(),
          timestamp : pm2_env.log_date_format ? moment().format(pm2_env.log_date_format) : new Date().toISOString(),
          type : &#x27;out&#x27;,
          process_id : cspr.pm2_env.pm_id,
          app_name : cspr.pm2_env.name
        }) + &#x27;\n&#x27;;
      }
      else if (pm2_env.log_date_format)
        log_data = moment().format(pm2_env.log_date_format) + &#x27;: &#x27; + data.toString();
      else
        log_data = data.toString();

      stds.std &#x26;&#x26; stds.std.write &#x26;&#x26; stds.std.write(log_data);

      // hardcoded values of special log path to not write on disk
      if (pm2_env.pm_out_log_path !== &#x27;NULL&#x27; &#x26;&#x26; pm2_env.pm_out_log_path !== &#x27;/dev/null&#x27;) {
        stds.out.write &#x26;&#x26; stds.out.write(log_data);
      }

      God.bus.emit(&#x27;log:out&#x27;, {
        process : { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
    });
  }
  else {
    /**
     * Fork mode logic
     */
    God.<span class="apidocCodeKeywordSpan">forkMode</span>(env_copy, function forkMode(err, clu) {
if (cb &#x26;&#x26; err) return cb(err);
if (err) return false;

var old_env = God.clusters_db[clu.pm2_env.pm_id];
if (old_env) old_env = null;

var proc = God.clusters_db[env_copy.pm_id] = clu;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.getFormatedProcess" id="apidoc.element.pm2.God.getFormatedProcess">
        function <span class="apidocSignatureSpan">pm2.God.</span>getFormatedProcess
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFormatedProcesses(id) {
  if (God.clusters_db[id])
    return {
      pid     : God.clusters_db[id].process.pid,
      name    : God.clusters_db[id].pm2_env.name,
      pm2_env : God.clusters_db[id].pm2_env,
      pm_id   : God.clusters_db[id].pm2_env.pm_id
    };
  return {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.getFormatedProcesses" id="apidoc.element.pm2.God.getFormatedProcesses">
        function <span class="apidocSignatureSpan">pm2.God.</span>getFormatedProcesses
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFormatedProcesses() {
  var keys = Object.keys(God.clusters_db);
  var arr  = new Array();
  var kl   = keys.length;

  for (var i = 0; i &#x3c; kl; i++) {
    var key = keys[i];

    if (!God.clusters_db[key]) continue;
    // Avoid _old type pm_ids
    if (isNaN(God.clusters_db[key].pm2_env.pm_id)) continue;

    arr.push({
      pid     : God.clusters_db[key].process.pid,
      name    : God.clusters_db[key].pm2_env.name,
      pm2_env : God.clusters_db[key].pm2_env,
      pm_id   : God.clusters_db[key].pm2_env.pm_id
    })
  }
  return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Daemon.prototype.gracefullExit = function() {
  var that = this;

  console.log(&#x27;pm2 has been killed by signal, dumping process list before exit...&#x27;);

  God.dumpProcessList(function() {

var processes = God.<span class="apidocCodeKeywordSpan">getFormatedProcesses</span>();

async.eachLimit(processes, 1, function(proc, next) {
  console.log(&#x27;Deleting process %s&#x27;, proc.pm2_env.pm_id);
  God.deleteProcessId(proc.pm2_env.pm_id, function() {
    return next();
  });
  return false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.getMonitorData" id="apidoc.element.pm2.God.getMonitorData">
        function <span class="apidocSignatureSpan">pm2.God.</span>getMonitorData
        <span class="apidocSignatureSpan">(env, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMonitorData(env, cb) {
  var processes = God.getFormatedProcesses();

  async.eachSeries(processes, function computeMonitor(pro, next) {
    if (pro.pm2_env.status == cst.ONLINE_STATUS) {
      var pid = pro.pid;

      if (pro.pm2_env.axm_options &#x26;&#x26; pro.pm2_env.axm_options.pid) {
        if (isNaN(pro.pm2_env.axm_options.pid)) {
          pro[&#x27;monit&#x27;] = {
            memory : 0,
            cpu : 0
          };
          return process.nextTick(next);
        }
        pid = pro.pm2_env.axm_options.pid;
      }

      pidusage.stat(pid, function retPidUsage(err, res) {
        if (err) {
          // Do not log, some time modules does not retrieve PID
          // console.error(&#x27;Error caught while calling pidusage&#x27;);
          // console.error(err);
          pro[&#x27;monit&#x27;] = {
            memory : 0,
            cpu : 0
          };
          return next();
        }

        pro[&#x27;monit&#x27;] = {
          memory : Math.floor(res.memory),
          cpu    : Math.floor(res.cpu)
        };
        res = null;
        pid = null;
        return next();
      });
    }
    else {
      pro[&#x27;monit&#x27;] = {
        memory : 0,
        cpu : 0
      };
      return next();
    }
  }, function retMonitor(err, res) {
    if (err) return cb(God.logAndGenerateError(err), null);
    return cb(null, processes);
  });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var tasks = function() {
    if (God.Worker.is_running === true) {
debug(&#x27;[PM2][WORKER] Worker is already running, skipping this round&#x27;);
return false;
    }
    God.Worker.is_running = true;

    God.<span class="apidocCodeKeywordSpan">getMonitorData</span>(null, function(err, data) {
if (err || !data || typeof(data) !== &#x27;object&#x27;) {
  God.Worker.is_running = false;
  return console.error(err);
}

async.eachLimit(data, 1, function(proc_key, next) {
  if (!proc_key ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.getNewId" id="apidoc.element.pm2.God.getNewId">
        function <span class="apidocSignatureSpan">pm2.God.</span>getNewId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNewId = function () {
  return God.next_id++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * Enter here when it&#x27;s the first time that the process is created
   * 1 - Assign a new id
   * 2 - Reset restart time and unstable_restarts
   * 3 - Assign a log file name depending on the id
   * 4 - If watch option is set, look for changes
   */
  if (env_copy[&#x27;pm_id&#x27;] === undefined) {
env_copy[&#x27;pm_id&#x27;]             = God.<span class="apidocCodeKeywordSpan">getNewId</span>();
env_copy[&#x27;restart_time&#x27;]      = 0;
env_copy[&#x27;unstable_restarts&#x27;] = 0;

// add -pm_id to pid file
env_copy.pm_pid_path = env_copy.pm_pid_path.replace(/-[0-9]+\.pid$|\.pid$/g, &#x27;-&#x27; + env_copy[&#x27;pm_id&#x27;] + &#x27
;.pid&#x27;);

// If merge option, dont separate the logs
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.getProcesses" id="apidoc.element.pm2.God.getProcesses">
        function <span class="apidocSignatureSpan">pm2.God.</span>getProcesses
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProcesses = function () {
  return God.clusters_db;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.getSystemData" id="apidoc.element.pm2.God.getSystemData">
        function <span class="apidocSignatureSpan">pm2.God.</span>getSystemData
        <span class="apidocSignatureSpan">(env, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSystemData(env, cb) {
  God.getMonitorData(env, function(err, processes) {
    cb(err, {
      system: {
        hostname: os.hostname(),
        uptime: os.uptime(),
        cpus: os.cpus(),
        load: os.loadavg(),
        memory: {
          free: os.freemem(),
          total: os.totalmem()
        },
        time: Utility.getDate()
      },
      processes: processes
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.getVersion" id="apidoc.element.pm2.God.getVersion">
        function <span class="apidocSignatureSpan">pm2.God.</span>getVersion
        <span class="apidocSignatureSpan">(env, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getVersion = function (env, cb) {
  process.nextTick(function() {
    return cb(null, pkg.version);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.handleExit" id="apidoc.element.pm2.God.handleExit">
        function <span class="apidocSignatureSpan">pm2.God.</span>handleExit
        <span class="apidocSignatureSpan">(clu, exit_code, kill_signal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function handleExit(clu, exit_code, kill_signal) {
  console.log(&#x27;App [%s] with id [%s] and pid [%s], exited with code [%s] via signal [%s]&#x27;, clu.pm2_env.name, clu.pm2_env.pm_id,
clu.process.pid, exit_code, kill_signal || &#x27;SIGINT&#x27;);

  var proc = this.clusters_db[clu.pm2_env.pm_id];

  if (!proc) {
    console.error(&#x27;Process undefined ? with process id &#x27;, clu.pm2_env.pm_id);
    return false;
  }

  if (proc.process.pid)
    pidusage.unmonitor(proc.process.pid);

  var stopping    = (proc.pm2_env.status == cst.STOPPING_STATUS
                     || proc.pm2_env.status == cst.STOPPED_STATUS
                     || proc.pm2_env.status == cst.ERRORED_STATUS) || (proc.pm2_env.autorestart === false ||
                                                                       proc.pm2_env.autorestart === &#x22;false&#x22;);

  var overlimit   = false;

  if (stopping) proc.process.pid = 0;

  // Reset probes and actions
  if (proc.pm2_env.axm_actions) proc.pm2_env.axm_actions = [];
  if (proc.pm2_env.axm_monitor) proc.pm2_env.axm_monitor = {};

  if (proc.pm2_env.status != cst.ERRORED_STATUS &#x26;&#x26;
      proc.pm2_env.status != cst.STOPPING_STATUS)
    proc.pm2_env.status = cst.STOPPED_STATUS;

  if (proc.pm2_env.pm_id.toString().indexOf(&#x27;_old_&#x27;) !== 0) {
    try {
      fs.unlinkSync(proc.pm2_env.pm_pid_path);
    } catch (e) {
      debug(&#x27;Error when unlinking pid file&#x27;, e);
    }
  }

<span class="apidocCodeCommentSpan">  /**
   * Avoid infinite reloop if an error is present
   */
</span>  // If the process has been created less than 15seconds ago

  // And if the process has an uptime less than a second
  var min_uptime = typeof(proc.pm2_env.min_uptime) !== &#x27;undefined&#x27; ? proc.pm2_env.min_uptime : 1000;
  var max_restarts = typeof(proc.pm2_env.max_restarts) !== &#x27;undefined&#x27; ? proc.pm2_env.max_restarts : 16;

  if ((Date.now() - proc.pm2_env.created_at) &#x3c; (min_uptime * max_restarts)) {
    if ((Date.now() - proc.pm2_env.pm_uptime) &#x3c; min_uptime) {
      // Increment unstable restart
      proc.pm2_env.unstable_restarts += 1;
    }

    if (proc.pm2_env.unstable_restarts &#x3e;= max_restarts) {
      // Too many unstable restart in less than 15 seconds
      // Set the process as &#x27;ERRORED&#x27;
      // And stop restarting it
      proc.pm2_env.status = cst.ERRORED_STATUS;
      proc.process.pid = 0;

      console.log(&#x27;Script %s had too many unstable restarts (%d). Stopped. %j&#x27;,
                  proc.pm2_env.pm_exec_path,
                  proc.pm2_env.unstable_restarts,
                  proc.pm2_env.status);

      God.notify(&#x27;restart overlimit&#x27;, proc);

      proc.pm2_env.unstable_restarts = 0;
      proc.pm2_env.created_at = null;
      overlimit = true;
    }
  }

  if (typeof(exit_code) !== &#x27;undefined&#x27;) proc.pm2_env.exit_code = exit_code;

  God.notify(&#x27;exit&#x27;, proc);

  if (God.pm2_being_killed) {
    console.log(&#x27;[HandleExit] PM2 is being killed, stopping restart procedure...&#x27;);
    return false;
  }

  var restart_delay = 0;
  if (proc.pm2_env.restart_delay !== undefined &#x26;&#x26; !isNaN(parseInt(proc.pm2_env.restart_delay))) {
    restart_delay = parseInt(proc.pm2_env.restart_delay);
  }

  if (!stopping &#x26;&#x26; !overlimit) {
    //make this property unenumerable
    Object.defineProperty(proc.pm2_env, &#x27;restart_task&#x27;, {configurable: true, writable: true});
    proc.pm2_env.restart_task = setTimeout(function() {
      proc.pm2_env.restart_time += 1;
      God.executeApp(proc.pm2_env);
    }, restart_delay);
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  console.error(err.stack || err);
  clu.pm2_env.status = cst.ERRORED_STATUS;
  try {
    clu.destroy &#x26;&#x26; clu.destroy();
  }
  catch (e) {
    console.error(e.stack || e);
    God.<span class="apidocCodeKeywordSpan">handleExit</span>(clu, cst.ERROR_EXIT);
  }
});

clu.once(&#x27;disconnect&#x27;, function() {
  console.log(&#x27;App name:%s id:%s disconnected&#x27;, clu.pm2_env.name, clu.pm2_env.pm_id);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.killProcess" id="apidoc.element.pm2.God.killProcess">
        function <span class="apidocSignatureSpan">pm2.God.</span>killProcess
        <span class="apidocSignatureSpan">(pid, pm2_env, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killProcess = function (pid, pm2_env, cb) {
  if (!pid) return cb({msg : &#x27;no pid passed or null&#x27;});

  var mode = pm2_env.exec_mode;

  if (pm2_env.treekill !== true) {
    try {
      process.kill(parseInt(pid), &#x27;SIGINT&#x27;);
    } catch(e) {
      console.error(&#x27;[SimpleKill] %s pid can not be killed&#x27;, pid, e.stack, e.message);
    }
    return God.processIsDead(pid, pm2_env, cb);
  }
  else {
    treekill(parseInt(pid), &#x27;SIGINT&#x27;, function(err) {
      return God.processIsDead(pid, pm2_env, cb);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.logAndGenerateError" id="apidoc.element.pm2.God.logAndGenerateError">
        function <span class="apidocSignatureSpan">pm2.God.</span>logAndGenerateError
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logAndGenerateError = function (err) {
  // Is an Error object
  if (err instanceof Error) {
    console.trace(err);
    return err;
  }
  // Is a JSON or simple string
  console.error(err);
  return new Error(err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.msgProcess" id="apidoc.element.pm2.God.msgProcess">
        function <span class="apidocSignatureSpan">pm2.God.</span>msgProcess
        <span class="apidocSignatureSpan">(cmd, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">msgProcess = function (cmd, cb) {
  if (&#x27;id&#x27; in cmd) {
    var id = cmd.id;
    if (!(id in God.clusters_db))
      return cb(God.logAndGenerateError(id + &#x27; id unknown&#x27;), {});
    var proc = God.clusters_db[id];

    var action_exist = false;

    proc.pm2_env.axm_actions.forEach(function(action) {
      if (action.action_name == cmd.msg) {
        action_exist = true;
        // Reset output buffer
        action.output = [];
      }
    });
    if (action_exist == false) {
      return cb(God.logAndGenerateError(&#x27;Action doesn\&#x27;t exist &#x27; + cmd.msg + &#x27; for &#x27; + proc.pm2_env.name), {});
    }

    if (proc.pm2_env.status == cst.ONLINE_STATUS || proc.pm2_env.status == cst.LAUNCHING_STATUS) {
<span class="apidocCodeCommentSpan">      /*
       * Send message
       */
</span>      if (cmd.opts == null)
        proc.send(cmd.msg);
      else
        proc.send(cmd);

      return cb(null, { process_count : 1, success : true });
    }
    else
      return cb(God.logAndGenerateError(id + &#x27; : id offline&#x27;), {});
  }

  else if (&#x27;name&#x27; in cmd) {
    /*
     * As names are not unique in case of cluster, this
     * will send msg to all process matching  &#x27;name&#x27;
     */
    var name = cmd.name;
    var arr = Object.keys(God.clusters_db);
    var sent = 0;

    (function ex(arr) {
      if (arr[0] == null) return cb(null, { process_count : sent, success : true });

      var id      = arr[0];

      if (!God.clusters_db[id] || !God.clusters_db[id].pm2_env) {
        arr.shift();
        return ex(arr);
      }

      var proc_env = God.clusters_db[id].pm2_env;

      if (p.basename(proc_env.pm_exec_path) == name || proc_env.name == name) {
        if (proc_env.status == cst.ONLINE_STATUS || proc.pm2_env.status == cst.LAUNCHING_STATUS) {

          if (cmd.opts == null)
            God.clusters_db[id].send(cmd.msg);
          else
            God.clusters_db[id].send(cmd);

          sent++;
          arr.shift();
          return ex(arr);

        }
      }
      else {
        arr.shift();
        return ex(arr);
      }
      return false;
    })(arr);
  }

  else return cb(God.logAndGenerateError(&#x27;method requires name or id field&#x27;), {});
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.nodeApp" id="apidoc.element.pm2.God.nodeApp">
        function <span class="apidocSignatureSpan">pm2.God.</span>nodeApp
        <span class="apidocSignatureSpan">(env_copy, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nodeApp(env_copy, cb){
  var clu = null;

  console.log(&#x27;Starting execution sequence in -cluster mode- for app name:%s id:%s&#x27;,
              env_copy.name,
              env_copy.pm_id);

  if (env_copy.node_args &#x26;&#x26; Array.isArray(env_copy.node_args)) {
    cluster.settings.execArgv = env_copy.node_args;
  }

  env_copy._pm2_version = pkg.version;

  try {
    // node.js cluster clients can not receive deep-level objects or arrays in the forked process, e.g.:
    // { &#x22;args&#x22;: [&#x22;foo&#x22;, &#x22;bar&#x22;], &#x22;env&#x22;: { &#x22;foo1&#x22;: &#x22;bar1&#x22; }} will be parsed to
    // { &#x22;args&#x22;: &#x22;foo, bar&#x22;, &#x22;env&#x22;: &#x22;[object Object]&#x22;}
    // So we passing a stringified JSON here.
    clu = cluster.fork({pm2_env: JSON.stringify(env_copy)});
  } catch(e) {
    God.logAndGenerateError(e);
    return cb(e);
  }

  clu.pm2_env = env_copy;

<span class="apidocCodeCommentSpan">  /**
   * Broadcast message to God
   */
</span>  clu.on(&#x27;message&#x27;, function cluMessage(msg) {
    /*********************************
     * If you edit this function
     * Do the same in ForkMode.js !
     *********************************/
    if (msg.data &#x26;&#x26; msg.type) {
      return God.bus.emit(msg.type ? msg.type : &#x27;process:msg&#x27;, {
        at      : Utility.getDate(),
        data    : msg.data,
        process :  {
          pm_id      : clu.pm2_env.pm_id,
          name       : clu.pm2_env.name,
          rev        : (clu.pm2_env.versioning &#x26;&#x26; clu.pm2_env.versioning.revision) ? clu.pm2_env.versioning.revision : null
        }
      });
    }
    else {

      if (typeof msg == &#x27;object&#x27; &#x26;&#x26; &#x27;node_version&#x27; in msg) {
        clu.pm2_env.node_version = msg.node_version;
        return false;
      } else if (typeof msg == &#x27;object&#x27; &#x26;&#x26; &#x27;cron_restart&#x27; in msg) {
        return God.restartProcessId({
          id : clu.pm2_env.pm_id
        }, function() {
          console.log(&#x27;Application %s has been restarted via CRON&#x27;, clu.pm2_env.name);
        });
      }

      return God.bus.emit(&#x27;process:msg&#x27;, {
        at      : Utility.getDate(),
        raw     : msg,
        process :  {
          pm_id      : clu.pm2_env.pm_id,
          name       : clu.pm2_env.name
        }
      });
    }
  });

  return cb(null, clu);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (cb) cb(null, proc);
  }

  if (env_copy.exec_mode === &#x27;cluster_mode&#x27;) {
    /**
     * Cluster mode logic (for NodeJS apps)
     */
    God.<span class="apidocCodeKeywordSpan">nodeApp</span>(env_copy, function nodeApp(err, clu) {
if (cb &#x26;&#x26; err) return cb(err);
if (err) return false;

var old_env = God.clusters_db[clu.pm2_env.pm_id];

if (old_env) {
  old_env = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.notify" id="apidoc.element.pm2.God.notify">
        function <span class="apidocSignatureSpan">pm2.God.</span>notify
        <span class="apidocSignatureSpan">(action_name, data, manually)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notify = function (action_name, data, manually) {
  God.bus.emit(&#x27;process:event&#x27;, {
    event      : action_name,
    manually   : typeof(manually) == &#x27;undefined&#x27; ? false : true,
    process    : Utility.formatCLU(data),
    at         : Utility.getDate()
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/** Callback when application is launched */
var readyCb = function ready(proc) {
    if (proc.pm2_env.vizion !== false &#x26;&#x26; proc.pm2_env.vizion !== &#x22;false&#x22;)
      God.finalizeProcedure(proc);
    else
      God.<span class="apidocCodeKeywordSpan">notify</span>(&#x27;online&#x27;, proc);

    proc.pm2_env.status = cst.ONLINE_STATUS;
    console.log(&#x27;App name:%s id:%s online&#x27;, proc.pm2_env.name, proc.pm2_env.pm_id);
    if (cb) cb(null, proc);
}

if (env_copy.exec_mode === &#x27;cluster_mode&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.notifyByProcessId" id="apidoc.element.pm2.God.notifyByProcessId">
        function <span class="apidocSignatureSpan">pm2.God.</span>notifyByProcessId
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyByProcessId = function (opts, cb) {
  if (typeof(opts.id) === &#x27;undefined&#x27;) { return cb(new Error(&#x27;process id missing&#x27;)); }
  var proc = God.clusters_db[opts.id];
  if (!proc) { return cb(new Error(&#x27;process id doesnt exists&#x27;)); }

  God.bus.emit(&#x27;process:event&#x27;, {
    event      : opts.action_name,
    manually   : typeof(opts.manually) == &#x27;undefined&#x27; ? false : true,
    process    : Utility.formatCLU(proc),
    at         : Utility.getDate()
  });

  process.nextTick(function() {
    return cb ? cb(null) : false;
  });
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.notifyKillPM2" id="apidoc.element.pm2.God.notifyKillPM2">
        function <span class="apidocSignatureSpan">pm2.God.</span>notifyKillPM2
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyKillPM2 = function () {
  God.pm2_being_killed = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.ping" id="apidoc.element.pm2.God.ping">
        function <span class="apidocSignatureSpan">pm2.God.</span>ping
        <span class="apidocSignatureSpan">(env, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ping = function (env, cb) {
  return cb(null, {msg : &#x27;pong&#x27;});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.prepare" id="apidoc.element.pm2.God.prepare">
        function <span class="apidocSignatureSpan">pm2.God.</span>prepare
        <span class="apidocSignatureSpan">(env, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prepare(env, cb) {
  // If instances option is set (-i [arg])
  if (typeof env.instances != &#x27;undefined&#x27;) {
    if (env.instances == 0) env.instances = numCPUs;
    env.instances = parseInt(env.instances);
    if (env.instances &#x3c; 0) env.instances += numCPUs;
    if (env.instances &#x3c;= 0) env.instances = 1;
    // multi fork depending on number of cpus
    var arr = [];
    var instance_id = 0;

    (function ex(i) {
      if (i &#x3c;= 0) {
        if (cb) return cb(null, arr);
        return false;
      }

      env.NODE_APP_INSTANCE = instance_id++;
      env.vizion_running = false;

      if (env.env &#x26;&#x26; env.env.vizion_running)
        env.env.vizion_running = false;

      return God.executeApp(Utility.clone(env), function(err, clu) {
        if (err) return ex(i - 1);
        arr.push(Utility.clone(clu));
        God.notify(&#x27;start&#x27;, clu, true);
        return ex(i - 1);
      });
    })(env.instances);
  }
  else {
    env.vizion_running = false;
    if (env.env &#x26;&#x26; env.env.vizion_running) env.env.vizion_running = false;

    return God.executeApp(env, function(err, clu) {
      God.notify(&#x27;start&#x27;, clu, true);
      cb(err, [Utility.clone(clu)]);
    });
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.processIsDead" id="apidoc.element.pm2.God.processIsDead">
        function <span class="apidocSignatureSpan">pm2.God.</span>processIsDead
        <span class="apidocSignatureSpan">(pid, pm2_env, cb, sigkill)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processIsDead = function (pid, pm2_env, cb, sigkill) {
  if (!pid) return cb({type : &#x27;param:missing&#x27;, msg : &#x27;no pid passed&#x27;});

  var timeout      = null;
  var kill_timeout = (pm2_env &#x26;&#x26; pm2_env.kill_timeout) ? pm2_env.kill_timeout : cst.KILL_TIMEOUT;
  var mode         = pm2_env.exec_mode;

  var timer = setInterval(function() {
    if (God.checkProcess(pid) === false) {
      console.log(&#x27;pid=%d msg=process killed&#x27;, pid);
      clearTimeout(timeout);
      clearInterval(timer);
      return cb(null, true);
    }
    console.log(&#x27;pid=%d msg=failed to kill - retrying in 100ms&#x27;, pid);
    return false;
  }, 100);

  timeout = setTimeout(function() {
    clearInterval(timer);
    if (sigkill) {
      console.log(&#x27;Process with pid %d could not be killed&#x27;, pid);
      return cb({type : &#x27;timeout&#x27;, msg : &#x27;timeout&#x27;});
    }
    else {
      console.log(&#x27;Process with pid %d still alive after %sms, sending it SIGKILL now...&#x27;, pid, kill_timeout);

      if (pm2_env.treekill !== true) {
        try {
          process.kill(parseInt(pid), &#x27;SIGKILL&#x27;);
        } catch(e) {
          console.error(&#x27;[SimpleKill][SIGKILL] %s pid can not be killed&#x27;, pid, e.stack, e.message);
        }
        return God.processIsDead(pid, pm2_env, cb, true);
      }
      else {
        treekill(parseInt(pid), &#x27;SIGKILL&#x27;, function(err) {
          return God.processIsDead(pid, pm2_env, cb, true);
        });
      }
    }
  }, kill_timeout);
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.reloadLogs" id="apidoc.element.pm2.God.reloadLogs">
        function <span class="apidocSignatureSpan">pm2.God.</span>reloadLogs
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reloadLogs = function (opts, cb) {
  console.log(&#x27;Reloading logs...&#x27;);
  var processIds = Object.keys(God.clusters_db);

  processIds.forEach(function (id) {
    var cluster = God.clusters_db[id];

    console.log(&#x27;Reloading logs for process id %d&#x27;, id);

    if (cluster &#x26;&#x26;
        cluster.pm2_env) {
      if (cluster.send &#x26;&#x26;
          cluster.pm2_env.exec_mode == &#x27;cluster_mode&#x27;) {
        cluster.send({
          type:&#x27;log:reload&#x27;
        });
      }
      else if (cluster._reloadLogs) {
        cluster._reloadLogs(function(err) {
          if (err) God.logAndGenerateError(err);
        });
      }
    }
  });

  return cb(null, {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var that = this;

process.on(&#x27;SIGTERM&#x27;, that.gracefullExit);
process.on(&#x27;SIGINT&#x27;, that.gracefullExit);
process.on(&#x27;SIGHUP&#x27;, function() {});
process.on(&#x27;SIGQUIT&#x27;, that.gracefullExit);
process.on(&#x27;SIGUSR2&#x27;, function() {
  God.<span class="apidocCodeKeywordSpan">reloadLogs</span>({}, function() {});
});
}

Daemon.prototype.sendReady = function(cb) {
// Send ready message to Client
if (this.rpc_socket_ready == true &#x26;&#x26; this.pub_socket_ready == true) {
  cb(null, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.reloadProcessId" id="apidoc.element.pm2.God.reloadProcessId">
        function <span class="apidocSignatureSpan">pm2.God.</span>reloadProcessId
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reloadProcessId = function (opts, cb) {
  var id  = opts.id;
  var env = opts.env || {};

  if (!(id in God.clusters_db))
    return cb(new Error(&#x27;PM2 ID unknown&#x27;));

  if (God.clusters_db[id].pm2_env.status == cst.ONLINE_STATUS &#x26;&#x26;
      God.clusters_db[id].pm2_env.exec_mode == &#x27;cluster_mode&#x27;) {

    Utility.extendExtraConfig(God.clusters_db[id], opts);
    Utility.extend(God.clusters_db[id].pm2_env.env, opts.env);

    var wait_msg = God.clusters_db[id].pm2_env.wait_ready ? &#x27;ready&#x27; : &#x27;listening&#x27;;
    return hardReload(God, id, wait_msg, cb);
  }
  else {
    console.log(&#x27;Process %s in a stopped status, starting it&#x27;, id);
    return God.restartProcessId(opts, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.resetMetaProcessId" id="apidoc.element.pm2.God.resetMetaProcessId">
        function <span class="apidocSignatureSpan">pm2.God.</span>resetMetaProcessId
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetMetaProcessId = function (id, cb) {
  if (!(id in God.clusters_db))
    return cb(God.logAndGenerateError(id + &#x27; id unknown&#x27;), {});

  if (!God.clusters_db[id] || !God.clusters_db[id].pm2_env)
    return cb(God.logAndGenerateError(&#x27;Error when getting proc || proc.pm2_env&#x27;), {});

  God.clusters_db[id].pm2_env.created_at = Utility.getDate();
  God.clusters_db[id].pm2_env.unstable_restarts = 0;
  God.clusters_db[id].pm2_env.restart_time = 0;

  return cb(null, God.getFormatedProcesses());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.resetState" id="apidoc.element.pm2.God.resetState">
        function <span class="apidocSignatureSpan">pm2.God.</span>resetState
        <span class="apidocSignatureSpan">(pm2_env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetState = function (pm2_env) {
  pm2_env.created_at = Date.now();
  pm2_env.unstable_restarts = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.restartProcessId" id="apidoc.element.pm2.God.restartProcessId">
        function <span class="apidocSignatureSpan">pm2.God.</span>restartProcessId
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restartProcessId = function (opts, cb) {
  var id = opts.id;
  var env = opts.env || {};

  if (typeof(id) === &#x27;undefined&#x27;)
    return cb(God.logAndGenerateError(&#x27;opts.id not passed to restartProcessId&#x27;, opts));
  if (!(id in God.clusters_db))
    return cb(God.logAndGenerateError(&#x27;God db process id unknown&#x27;), {});

  var proc = God.clusters_db[id];

  God.resetState(proc.pm2_env);

<span class="apidocCodeCommentSpan">  /**
   * Merge new application configuration on restart
   * Same system in reloadProcessId and softReloadProcessId
   */
</span>  Utility.extendExtraConfig(proc, opts);
  Utility.extend(proc.pm2_env.env, opts.env);

  if (God.pm2_being_killed) {
    return cb(God.logAndGenerateError(&#x27;[RestartProcessId] PM2 is being killed, stopping restart procedure...&#x27;));
  }
  if (proc.pm2_env.status === cst.ONLINE_STATUS || proc.pm2_env.status === cst.LAUNCHING_STATUS) {
    God.stopProcessId(id, function(err) {
      if (God.pm2_being_killed)
        return cb(God.logAndGenerateError(&#x27;[RestartProcessId] PM2 is being killed, stopping restart procedure...&#x27;));
      proc.pm2_env.restart_time += 1;
      return God.startProcessId(id, cb);
    });

    return false;
  }
  else {
    debug(&#x27;[restart] process not online, starting it&#x27;);
    return God.startProcessId(id, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.restartProcessName" id="apidoc.element.pm2.God.restartProcessName">
        function <span class="apidocSignatureSpan">pm2.God.</span>restartProcessName
        <span class="apidocSignatureSpan">(name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restartProcessName = function (name, cb) {
  var processes = God.findByName(name);

  if (processes &#x26;&#x26; processes.length === 0)
    return cb(God.logAndGenerateError(&#x27;Unknown process&#x27;), {});

  async.eachLimit(processes, cst.CONCURRENT_ACTIONS, function(proc, next) {
    if (God.pm2_being_killed)
      return next(&#x27;[Watch] PM2 is being killed, stopping restart procedure...&#x27;);
    if (proc.pm2_env.status === cst.ONLINE_STATUS)
      return God.restartProcessId({id:proc.pm2_env.pm_id}, next);
    else if (proc.pm2_env.status !== cst.STOPPING_STATUS
             &#x26;&#x26; proc.pm2_env.status !== cst.LAUNCHING_STATUS)
      return God.startProcessId(proc.pm2_env.pm_id, next);
    else
      return next(&#x22;[Watch] Process name %s is being stopped so I won&#x27;t restart it&#x22;, name);
  }, function(err) {
    if (err) return cb(God.logAndGenerateError(err));
    return cb(null, God.getFormatedProcesses());
  });

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return false;
      }

      self.restarting = true;

      console.error(&#x27;Change detected on path %s for app %s - restarting&#x27;, path, pm2_env.name);

      God.<span class="apidocCodeKeywordSpan">restartProcessName</span>(pm2_env.name, function(err, list) {
self.restarting = false;

if (err) {
  log(&#x27;Error while restarting&#x27;, err);
  return false;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.sendDataToProcessId" id="apidoc.element.pm2.God.sendDataToProcessId">
        function <span class="apidocSignatureSpan">pm2.God.</span>sendDataToProcessId
        <span class="apidocSignatureSpan">(packet, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendDataToProcessId = function (packet, cb) {
  if (typeof(packet.id) == undefined ||
      !packet.data ||
      !packet.topic)
    return cb(God.logAndGenerateError(&#x27;ID, DATA or TOPIC field is missing&#x27;), {});

  var pm_id = packet.id;
  var data  = packet.data;

  var proc = God.clusters_db[pm_id];

  if (!proc)
    return cb(God.logAndGenerateError(&#x27;Process with ID &#x27;, pm_id, &#x27; unknown!&#x27;), {});

  if (proc.pm2_env.status != cst.ONLINE_STATUS &#x26;&#x26; proc.pm2_env.status != cst.LAUNCHING_STATUS)
    return cb(God.logAndGenerateError(&#x27;Process with ID &#x27;, pm_id, &#x27; unknown!&#x27;), {});

  try {
    proc.send(packet);
  }
  catch(e) {
    return cb(God.logAndGenerateError(e), {});
  }

  return cb(null, {
    success: true,
    data   : packet
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.sendSignalToProcessId" id="apidoc.element.pm2.God.sendSignalToProcessId">
        function <span class="apidocSignatureSpan">pm2.God.</span>sendSignalToProcessId
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendSignalToProcessId = function (opts, cb) {
  var id = opts.process_id;
  var signal = opts.signal;

  if (!(id in God.clusters_db))
    return cb(God.logAndGenerateError(id + &#x27; id unknown&#x27;), {});

  var proc = God.clusters_db[id];

  //God.notify(&#x27;send signal &#x27; + signal, proc, true);

  try {
    process.kill(God.clusters_db[id].process.pid, signal);
  } catch(e) {
    return cb(God.logAndGenerateError(&#x27;Error when sending signal (signal unknown)&#x27;), {});
  }
  return cb(null, God.getFormatedProcesses());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.sendSignalToProcessName" id="apidoc.element.pm2.God.sendSignalToProcessName">
        function <span class="apidocSignatureSpan">pm2.God.</span>sendSignalToProcessName
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendSignalToProcessName = function (opts, cb) {
  var processes = God.findByName(opts.process_name);
  var signal    = opts.signal;

  if (processes &#x26;&#x26; processes.length === 0)
    return cb(God.logAndGenerateError(&#x27;Unknown process name&#x27;), {});

  async.eachLimit(processes, cst.CONCURRENT_ACTIONS, function(proc, next) {
    if (proc.pm2_env.status == cst.ONLINE_STATUS || proc.pm2_env.status == cst.LAUNCHING_STATUS) {
      try {
        process.kill(proc.process.pid, signal);
      } catch(e) {
        return next(e);
      }
    }
    return setTimeout(next, 200);
  }, function(err) {
    if (err) return cb(God.logAndGenerateError(err), {});
    return cb(null, God.getFormatedProcesses());
  });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.softReloadProcessId" id="apidoc.element.pm2.God.softReloadProcessId">
        function <span class="apidocSignatureSpan">pm2.God.</span>softReloadProcessId
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">softReloadProcessId = function (opts, cb) {
  var id  = opts.id;
  var env = opts.env || {};

  if (!(id in God.clusters_db))
    return cb(new Error(&#x27;PM ID unknown&#x27;));

  if (God.clusters_db[id].pm2_env.status == cst.ONLINE_STATUS &#x26;&#x26;
      God.clusters_db[id].pm2_env.exec_mode == &#x27;cluster_mode&#x27; &#x26;&#x26;
      !God.clusters_db[id].pm2_env.wait_ready) {

    Utility.extendExtraConfig(God.clusters_db[id], opts);
    Utility.extend(God.clusters_db[id].pm2_env.env, opts.env);

    return softReload(God, id, cb);
  }
  else {
    console.log(&#x27;Process %s in a stopped status, starting it&#x27;, id);
    return God.restartProcessId(opts, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (proc_key.monit.memory !== undefined &#x26;&#x26;
    proc.pm2_env.max_memory_restart !== undefined &#x26;&#x26;
    proc.pm2_env.max_memory_restart &#x3c; proc_key.monit.memory &#x26;&#x26;
    proc.pm2_env.axm_options &#x26;&#x26;
    proc.pm2_env.axm_options.pid === undefined) {
  console.log(&#x27;[PM2][WORKER] Process %s restarted because it exceeds --max-memory-restart value (current_memory=%s max_memory_limit
=%s [octets])&#x27;, proc.pm2_env.pm_id, proc_key.monit.memory, proc.pm2_env.max_memory_restart);
  God.<span class="apidocCodeKeywordSpan">softReloadProcessId</span>({
    id : proc.pm2_env.pm_id
  }, function(err, data) {
    if (err)
      console.error(err.stack || err);
    return cb();
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.startProcessId" id="apidoc.element.pm2.God.startProcessId">
        function <span class="apidocSignatureSpan">pm2.God.</span>startProcessId
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startProcessId = function (id, cb) {
  if (!(id in God.clusters_db))
    return cb(God.logAndGenerateError(id + &#x27; id unknown&#x27;), {});

  var proc = God.clusters_db[id];
  if (proc.pm2_env.status == cst.ONLINE_STATUS)
    return cb(God.logAndGenerateError(&#x27;process already online&#x27;), {});
  if (proc.pm2_env.status == cst.LAUNCHING_STATUS)
    return cb(God.logAndGenerateError(&#x27;process already started&#x27;), {});
  if (proc.process &#x26;&#x26; proc.process.pid)
    return cb(God.logAndGenerateError(&#x27;Process with pid &#x27; + proc.process.pid + &#x27; already exists&#x27;), {});

  return God.executeApp(God.clusters_db[id].pm2_env, function(err, proc) {
    return cb(err, Utility.clone(proc));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.startWatch" id="apidoc.element.pm2.God.startWatch">
        function <span class="apidocSignatureSpan">pm2.God.</span>startWatch
        <span class="apidocSignatureSpan">(method, value, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startWatch = function (method, value, fn) {
  var env = null;

  if (method == &#x27;restartProcessId&#x27;) {
    env = God.clusters_db[value.id];
  } else if(method == &#x27;restartProcessName&#x27;) {
    env = God.clusters_db[God.findByName(value)];
  }

  if (env) {
    if (env.pm2_env.watch)
      return fn(null, {success:true, notrestarted:true});

    God.watch.enable(env.pm2_env);
    //env.pm2_env.env.watch = true;
    env.pm2_env.watch = true;
  }

  return fn(null, {success:true});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.stopProcessId" id="apidoc.element.pm2.God.stopProcessId">
        function <span class="apidocSignatureSpan">pm2.God.</span>stopProcessId
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopProcessId = function (id, cb) {
  if (typeof id == &#x27;object&#x27; &#x26;&#x26; &#x27;id&#x27; in id)
    id = id.id;

  if (!(id in God.clusters_db))
    return cb(God.logAndGenerateError(id + &#x27; : id unknown&#x27;), {});

  //clear time-out restart task
  clearTimeout(God.clusters_db[id].pm2_env.restart_task);

  if (God.clusters_db[id].pm2_env.status == cst.STOPPED_STATUS)
    return cb(null, God.getFormatedProcess(id));
  // state == &#x27;none&#x27; means that the process is not online yet
  if (God.clusters_db[id].state &#x26;&#x26; God.clusters_db[id].state === &#x27;none&#x27;)
    return setTimeout(function() { God.stopProcessId(id, cb); }, 250);

  var proc     = God.clusters_db[id];

  console.log(&#x27;Stopping app:%s id:%s&#x27;, proc.pm2_env.name, proc.pm2_env.pm_id);
  proc.pm2_env.status = cst.STOPPING_STATUS;

  if (!proc.process.pid) {
    console.error(&#x27;app=%s id=%d does not have a pid&#x27;, proc.pm2_env.name, proc.pm2_env.pm_id);
    proc.pm2_env.status = cst.STOPPED_STATUS;
    return cb(null, { error : true, message : &#x27;could not kill process w/o pid&#x27;});
  }

  God.killProcess(proc.process.pid, proc.pm2_env, function(err) {
    proc.pm2_env.status = cst.STOPPED_STATUS;
    pidusage.unmonitor(proc.process.pid);

    God.notify(&#x27;exit&#x27;, proc);

    if (err &#x26;&#x26; err.type &#x26;&#x26; err.type === &#x27;timeout&#x27;) {
      console.error(&#x27;app=%s id=%d pid=%s could not be stopped&#x27;,
                    proc.pm2_env.name,
                    proc.pm2_env.pm_id,
                    proc.process.pid);
      proc.pm2_env.status = cst.ERRORED_STATUS;
      return cb(null, God.getFormatedProcess(id));
    }

    if (proc.pm2_env.pm_id.toString().indexOf(&#x27;_old_&#x27;) !== 0) {
      try {
        fs.unlinkSync(proc.pm2_env.pm_pid_path);
      } catch (e) {}
    }

    if (proc.pm2_env.axm_actions) proc.pm2_env.axm_actions = [];
    if (proc.pm2_env.axm_monitor) proc.pm2_env.axm_monitor = {};

    proc.process.pid = 0;
    return cb(null, God.getFormatedProcess(id));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.stopWatch" id="apidoc.element.pm2.God.stopWatch">
        function <span class="apidocSignatureSpan">pm2.God.</span>stopWatch
        <span class="apidocSignatureSpan">(method, value, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopWatch = function (method, value, fn) {
  var env = null;

  if (method == &#x27;stopAll&#x27; || method == &#x27;deleteAll&#x27;) {
    var processes = God.getFormatedProcesses();

    processes.forEach(function(proc) {
      God.clusters_db[proc.pm_id].pm2_env.watch = false;
      God.watch.disable(proc.pm2_env);
    });

  } else {

    if (method.indexOf(&#x27;ProcessId&#x27;) !== -1) {
      env = God.clusters_db[value];
    } else if (method.indexOf(&#x27;ProcessName&#x27;) !== -1) {
      env = God.clusters_db[God.findByName(value)];
    }

    if (env) {
      God.watch.disable(env.pm2_env);
      env.pm2_env.watch = false;
    }
  }
  return fn(null, {success:true});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return
 */
Client.prototype.executeRemote = function executeRemote(method, app_conf, fn) {
var self = this;

// stop watch on stop | env is the process id
if (method.indexOf(&#x27;stop&#x27;) !== -1) {
  this.<span class="apidocCodeKeywordSpan">stopWatch</span>(method, app_conf);
}
// stop watching when process is deleted
else if (method.indexOf(&#x27;delete&#x27;) !== -1) {
  this.stopWatch(method, app_conf);
}
// stop everything on kill
else if (method.indexOf(&#x27;kill&#x27;) !== -1) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.God.toggleWatch" id="apidoc.element.pm2.God.toggleWatch">
        function <span class="apidocSignatureSpan">pm2.God.</span>toggleWatch
        <span class="apidocSignatureSpan">(method, value, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toggleWatch = function (method, value, fn) {
  var env = null;

  if (method == &#x27;restartProcessId&#x27;) {
    env = God.clusters_db[value.id];
  } else if(method == &#x27;restartProcessName&#x27;) {
    env = God.clusters_db[God.findByName(value)];
  }

  if (env) {
    //env.pm2_env.env.watch = !env.pm2_env.env.watch;
    env.pm2_env.watch = !env.pm2_env.watch;
    if (env.pm2_env.watch)
      God.watch.enable(env.pm2_env);
    else
      God.watch.disable(env.pm2_env);
  }

  return fn(null, {success:true});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
// stop everything on kill
else if (method.indexOf(&#x27;kill&#x27;) !== -1) {
  this.stopWatch(&#x27;deleteAll&#x27;, app_conf);
}
else if (method.indexOf(&#x27;restartProcessId&#x27;) !== -1 &#x26;&#x26; process.argv.indexOf(&#x27;--watch&#x27;) &#x3e; -1) {
  delete app_conf.env.current_conf.watch;
  this.<span class="apidocCodeKeywordSpan">toggleWatch</span>(method, app_conf);
}

if (!this.client || !this.client.call) {
  this.start(function(error) {
    if (error) {
      if (fn)
        return fn(error);
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2.Satan" id="apidoc.module.pm2.Satan">module pm2.Satan</a></h1>


    <h2>
        <a href="#apidoc.element.pm2.Satan.disconnectBus" id="apidoc.element.pm2.Satan.disconnectBus">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>disconnectBus
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disconnectBus(cb) {
  this.sub_sock.once(&#x27;close&#x27;, function() {
    return cb ? cb() : false;
  });
  this.sub_sock.close();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Satan.disconnectRPC" id="apidoc.element.pm2.Satan.disconnectRPC">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>disconnectRPC
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disconnectRPC(cb) {
  debug(&#x27;Disconnecting PM2 RPC&#x27;);

  if (!Satan.client_sock || !Satan.client_sock.close) {
    return cb({
      success : false,
      msg : &#x27;RPC connection to PM2 is not launched&#x27;
    });
  }

  if (Satan.client_sock.connected == false ||
      Satan.client_sock.closing == true) {
    return cb({
      success : false,
      msg : &#x27;RPC closed&#x27;
    });
  }

  try {
    var timer;

    Satan.client_sock.once(&#x27;close&#x27;, function() {
      clearTimeout(timer);
      debug(&#x27;PM2 RPC cleanly closed&#x27;);
      return cb ? cb(null, {success:true}) : false;
    });

    timer = setTimeout(function() {
      if (Satan.client_sock.destroy)
        Satan.client_sock.destroy();
      return cb ? cb(null, {success:true}) : false;
    }, 200);

    Satan.client_sock.close();
  } catch(e) {
    debug(&#x27;Error while disconnecting RPC PM2&#x27;, e.stack || e);
    return cb ? cb(e.stack || e) : false;
  };
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {} fn
 * @return
 */
Satan.killDaemon = function killDaemon(fn) {
var timeout;

function quit() {
  Satan.<span class="apidocCodeKeywordSpan">disconnectRPC</span>(function() {
    debug(&#x27;RPC disconnected&#x27;);
    return fn ? fn(null, {success:true}) : false;
  });
}

process.once(&#x27;SIGQUIT&#x27;, function() {
  debug(&#x27;Received SIGQUIT&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Satan.executeRemote" id="apidoc.element.pm2.Satan.executeRemote">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>executeRemote
        <span class="apidocSignatureSpan">(method, env, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function executeRemote(method, env, fn) {
  var env_watch = false;

  if (env.env &#x26;&#x26; env.env.watch)
    env_watch = env.env.watch;

  env_watch = util.isArray(env_watch) &#x26;&#x26; env_watch.length === 0 ? !!~process.argv.indexOf(&#x27;--watch&#x27;) : env_watch;

  //stop watching when process is deleted
  if (method.indexOf(&#x27;delete&#x27;) !== -1) {
    Satan.stopWatch(method, env);
  //stop everything on kill
  } else if(method.indexOf(&#x27;kill&#x27;) !== -1) {
    Satan.stopWatch(&#x27;deleteAll&#x27;, env);
  //stop watch on stop (stop doesn&#x27;t accept env, yet)
  } else if (~process.argv.indexOf(&#x27;--watch&#x27;) &#x26;&#x26; method.indexOf(&#x27;stop&#x27;) !== -1) {
    Satan.stopWatch(method, env);
  //restart watch
  } else if (env_watch &#x26;&#x26; method.indexOf(&#x27;restart&#x27;) !== -1) {
    Satan.restartWatch(method, env);
  }

  if (!Satan.client || !Satan.client.call) {
    if (fn) return fn(new Error(&#x27;Could not connect to local pm2, have you called pm2.connect(function()})&#x27;));
    console.error(&#x27;Did you forgot to call pm2.connect(function() { }) before interacting with PM2 ?&#x27;);
    return process.exit(0);
  }

  debug(&#x27;Calling daemon method pm2:%s&#x27;, method);
  return Satan.client.call(method, env, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

debug(&#x27;Calling daemon method pm2:%s on rpc socket:%s&#x27;, method, this.rpc_socket_file);
return this.client.call(method, app_conf, fn);
};

Client.prototype.notifyGod = function(action_name, id, cb) {
this.<span class="apidocCodeKeywordSpan">executeRemote</span>(&#x27;notifyByProcessId&#x27;, {
  id : id,
  action_name : action_name,
  manually : true
}, function() {
  debug(&#x27;God notified&#x27;);
  return cb ? cb() : false;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Satan.getExposedMethods" id="apidoc.element.pm2.Satan.getExposedMethods">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>getExposedMethods
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExposedMethods(cb) {
  Satan.client.methods(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Satan.killDaemon" id="apidoc.element.pm2.Satan.killDaemon">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>killDaemon
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function killDaemon(fn) {
  var timeout;

  function quit() {
    Satan.disconnectRPC(function() {
      debug(&#x27;RPC disconnected&#x27;);
      return fn ? fn(null, {success:true}) : false;
    });
  }

  process.once(&#x27;SIGQUIT&#x27;, function() {
    debug(&#x27;Received SIGQUIT&#x27;);
    clearTimeout(timeout);
    quit();
  });

  timeout = setTimeout(function() {
    quit();
  }, 3000);

  // Kill daemon
  Satan.executeRemote(&#x27;killMe&#x27;, {pid : process.pid}, function() {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Satan.launchBus" id="apidoc.element.pm2.Satan.launchBus">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>launchBus
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function launchEventSystem(cb) {
  var self = this;
  this.sub = axon.socket(&#x27;sub-emitter&#x27;);
  this.sub_sock = this.sub.connect(cst.DAEMON_PUB_PORT);

  this.sub_sock.once(&#x27;connect&#x27;, function() {
    return cb(null, self.sub);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
fmt.field(&#x27;Watch and Restart&#x27;, chalk.green(&#x27;Enabled&#x27;));
fmt.field(&#x27;Ignored folder&#x27;, opts.ignore_watch || &#x27;node_modules&#x27;);
if (opts.postExec)
  fmt.field(&#x27;Post restart cmd&#x27;, opts.postExec);
fmt.sep();

setTimeout(function() {
  pm2.Client.<span class="apidocCodeKeywordSpan">launchBus</span>(function(err, bus) {
    bus.on(&#x27;process:event&#x27;, function(packet) {
      if (packet.event == &#x27;online&#x27;) {
        if (opts.postExec)
          postExecCmd(opts.postExec);
      }
    });
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Satan.launchDaemon" id="apidoc.element.pm2.Satan.launchDaemon">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>launchDaemon
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function launchDaemon(cb) {
  debug(&#x27;Launching daemon&#x27;);

  var SatanJS = p.resolve(p.dirname(module.filename), &#x27;Satan.js&#x27;);
  var InteractorDaemonizer = require(&#x27;./Interactor/InteractorDaemonizer.js&#x27;);

  var node_args = [];

  var out, err;

  if (process.env.TRAVIS) {
    // Redirect PM2 internal err and out to STDERR STDOUT when running with Travis
    out = 1;
    err = 2;
  }
  else {
    out = fs.openSync(cst.PM2_LOG_FILE_PATH, &#x27;a&#x27;),
    err = fs.openSync(cst.PM2_LOG_FILE_PATH, &#x27;a&#x27;);
  }

  // Node.js tuning for better performance
  //node_args.push(&#x27;--expose-gc&#x27;); // Allows manual GC in the code
  //node_args.push(&#x27;--gc-global&#x27;); // Does full GC (smaller memory footprint)

<span class="apidocCodeCommentSpan">  /**
   * Add node [arguments] depending on PM2_NODE_OPTIONS env variable
   */
</span>  if (process.env.PM2_NODE_OPTIONS)
    node_args = node_args.concat(process.env.PM2_NODE_OPTIONS.split(&#x27; &#x27;));
  node_args.push(SatanJS);

  var resolved_home = process.env.PM2_HOME || process.env.HOME || process.env.HOMEPATH;

  debug(&#x22;PM2 home path: %s&#x22;, resolved_home);
  debug(&#x22;Node.js engine full path: %s&#x22;, process.execPath);
  debug(&#x22;Node.js with V8 arguments: %s&#x22;, node_args);

  var child = require(&#x27;child_process&#x27;).spawn(process.execPath || &#x27;node&#x27;, node_args, {
    detached   : true,
    cwd        : process.cwd(),
    env        : util._extend({
      &#x27;SILENT&#x27; : cst.DEBUG ? !cst.DEBUG : true,
      &#x27;HOME&#x27;   : resolved_home
    }, process.env),
    stdio      : [&#x27;ipc&#x27;, out, err]
  });

  function onError(e) {
    console.error(e.stack || e);
    return cb ? cb(e.stack || e) : false;
  }

  child.once(&#x27;error&#x27;, onError);

  child.unref();

  child.once(&#x27;message&#x27;, function(msg) {
    debug(&#x27;PM2 daemon launched with return message: &#x27;, msg);
    child.removeListener(&#x27;error&#x27;, onError);
    child.disconnect();
    InteractorDaemonizer.launchAndInteract({}, function(err, data) {
      if (data)
        debug(&#x27;Interactor launched&#x27;);
      return cb ? cb(null, child) : false;
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  return false;
}

/**
 * Daemon mode
 */
that.<span class="apidocCodeKeywordSpan">launchDaemon</span>(function(err, child) {
  if (err) {
    Common.printError(err);
    return cb ? cb(err) : process.exit(that.conf.ERROR_EXIT);
  }
  Common.printOut(that.conf.PREFIX_MSG + &#x27;PM2 Successfully daemonized&#x27;);
  that.launchRPC(function(err, meta) {
    return cb(null, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Satan.launchRPC" id="apidoc.element.pm2.Satan.launchRPC">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>launchRPC
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function launchRPC(cb) {
  debug(&#x27;Launching RPC client on socket file %s&#x27;, cst.DAEMON_RPC_PORT);
  var req      = axon.socket(&#x27;req&#x27;);
  Satan.client = new rpc.Client(req);

  Satan.client.sock.once(&#x27;connect&#x27;, function() {
    debug(&#x27;Connected to Daemon&#x27;);
    process.emit(&#x27;satan:client:ready&#x27;);
    setTimeout(function() {
      return cb ? cb(null) : false;
    }, 4);
  });

  this.client_sock = req.connect(cst.DAEMON_RPC_PORT);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// @breaking change (noDaemonMode has been drop)
// @todo ret err
Client.prototype.start = function(cb) {
var that = this;

this.pingDaemon(function(daemonAlive) {
  if (daemonAlive == true)
    return that.<span class="apidocCodeKeywordSpan">launchRPC</span>(function(err, meta) {
      return cb(null, {
        daemon_mode      : that.conf.daemon_mode,
        new_pm2_instance : false,
        rpc_socket_file  : that.rpc_socket_file,
        pub_socket_file  : that.pub_socket_file,
        pm2_home         : that.pm2_home
      });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Satan.notifyGod" id="apidoc.element.pm2.Satan.notifyGod">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>notifyGod
        <span class="apidocSignatureSpan">(action_name, id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyGod = function (action_name, id, cb) {
  Satan.executeRemote(&#x27;notifyByProcessId&#x27;, {
    id : id,
    action_name : action_name,
    manually : true
  }, function() {
    debug(&#x27;God notified&#x27;);
    return cb ? cb() : false;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Satan.pingDaemon" id="apidoc.element.pm2.Satan.pingDaemon">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>pingDaemon
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pingDaemon(cb) {
  var req    = axon.socket(&#x27;req&#x27;);
  var client = new rpc.Client(req);

  debug(&#x27;[PING PM2] Trying to connect to server&#x27;);

  client.sock.once(&#x27;reconnect attempt&#x27;, function() {
    client.sock.close();
    debug(&#x27;Daemon not launched&#x27;);
    process.nextTick(function() {
      return cb(false);
    });
  });

  client.sock.once(&#x27;connect&#x27;, function() {
    client.sock.once(&#x27;close&#x27;, function() {
      return cb(true);
    });
    client.sock.close();
    debug(&#x27;Daemon alive&#x27;);
  });

  req.connect(cst.DAEMON_RPC_PORT);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// @breaking change (noDaemonMode has been drop)
// @todo ret err
Client.prototype.start = function(cb) {
var that = this;

this.<span class="apidocCodeKeywordSpan">pingDaemon</span>(function(daemonAlive) {
  if (daemonAlive == true)
    return that.launchRPC(function(err, meta) {
      return cb(null, {
        daemon_mode      : that.conf.daemon_mode,
        new_pm2_instance : false,
        rpc_socket_file  : that.rpc_socket_file,
        pub_socket_file  : that.pub_socket_file,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Satan.printOut" id="apidoc.element.pm2.Satan.printOut">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>printOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">printOut = function () {
  if (process.env.PM2_SILENT || process.env.PM2_PROGRAMMATIC === &#x27;true&#x27;) return false;
  return console.log.apply(console, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Daemon mode
 */
that.launchDaemon(function(err, child) {
  if (err) {
    Common.printError(err);
    return cb ? cb(err) : process.exit(that.conf.ERROR_EXIT);
  }
  Common.<span class="apidocCodeKeywordSpan">printOut</span>(that.conf.PREFIX_MSG + &#x27;PM2 Successfully daemonized&#x27;);
  that.launchRPC(function(err, meta) {
    return cb(null, {
      daemon_mode      : that.conf.daemon_mode,
      new_pm2_instance : true,
      rpc_socket_file  : that.rpc_socket_file,
      pub_socket_file  : that.pub_socket_file,
      pm2_home         : that.pm2_home
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Satan.processStateHandler" id="apidoc.element.pm2.Satan.processStateHandler">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>processStateHandler
        <span class="apidocSignatureSpan">(God)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processStateHandler = function (God) {
<span class="apidocCodeCommentSpan">  /**
   * Description
   * @method gracefullExit
   * @return
   */
</span>  function gracefullExit() {
    Satan.printOut(&#x27;pm2 has been killed by signal, dumping process list before exit...&#x27;);

    God.dumpProcessList(function() {

      var processes = God.getFormatedProcesses();

      async.eachLimit(processes, cst.CONCURRENT_ACTIONS, function(proc, next) {
        console.log(&#x27;Deleting process %s&#x27;, proc.pm2_env.pm_id);
        God.deleteProcessId(proc.pm2_env.pm_id, function() {
          return next();
        });
        return false;
      }, function(err) {
        try {
          fs.unlinkSync(cst.PM2_PID_FILE_PATH);
        } catch(e) {}
        Satan.printOut(&#x27;[PM2] Exited peacefully&#x27;);
        process.exit(cst.SUCCESS_EXIT);
      });
    });
  }

  try {
    fs.writeFileSync(cst.PM2_PID_FILE_PATH, process.pid);
  } catch (e) {
    console.error(e.stack || e);
  }

  process.on(&#x27;SIGILL&#x27;, function() {
    global.gc();
    Satan.printOut(&#x27;Running garbage collector&#x27;);
  });

  process.on(&#x27;SIGTERM&#x27;, gracefullExit);
  process.on(&#x27;SIGINT&#x27;, gracefullExit);
  process.on(&#x27;SIGQUIT&#x27;, gracefullExit);
  process.on(&#x27;SIGUSR2&#x27;, function() {
    God.reloadLogs({}, function() {});
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var God = require(&#x27;./God&#x27;);
var self = this;

var pkg    = require(&#x27;../package.json&#x27;);
var rpc_socket_ready = false;
var pub_socket_ready = false;

Satan.<span class="apidocCodeKeywordSpan">processStateHandler</span>(God);

function sendReady() {
  // Send ready message to Satan Client
  if (rpc_socket_ready == true &#x26;&#x26; pub_socket_ready == true) {
    if (typeof(process.send) === &#x27;function&#x27;) {
      process.send({
        online      : true,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Satan.remoteWrapper" id="apidoc.element.pm2.Satan.remoteWrapper">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>remoteWrapper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteWrapper = function () {
  // Only require here because God init himself
  var God = require(&#x27;./God&#x27;);
  var self = this;

  var pkg    = require(&#x27;../package.json&#x27;);
  var rpc_socket_ready = false;
  var pub_socket_ready = false;

  Satan.processStateHandler(God);

  function sendReady() {
    // Send ready message to Satan Client
    if (rpc_socket_ready == true &#x26;&#x26; pub_socket_ready == true) {
      if (typeof(process.send) === &#x27;function&#x27;) {
        process.send({
          online      : true,
          success     : true,
          pid         : process.pid,
          pm2_version : pkg.version
        });
      }
    };
  }

<span class="apidocCodeCommentSpan">  /**
   * External interaction part
   */
</span>
  /**
   * Pub system for real time notifications
   */
  var pub    = axon.socket(&#x27;pub-emitter&#x27;);

  this.pub_socket = pub.bind(cst.DAEMON_PUB_PORT);

  this.pub_socket.once(&#x27;bind&#x27;, function() {
    Satan.printOut(&#x27;BUS system [READY] on port %s&#x27;, cst.DAEMON_PUB_PORT);
    pub_socket_ready = true;
    sendReady();
  });

  /**
   * Rep/Req - RPC system to interact with God
   */
  var rep    = axon.socket(&#x27;rep&#x27;);

  var server = new rpc.Server(rep);

  Satan.printOut(&#x27;[[[[ PM2/God daemon launched ]]]]&#x27;);

  this.rpc_socket = rep.bind(cst.DAEMON_RPC_PORT);

  this.rpc_socket.once(&#x27;bind&#x27;, function() {
    Satan.printOut(&#x27;RPC interface [READY] on port %s&#x27;, cst.DAEMON_RPC_PORT);
    rpc_socket_ready = true;
    sendReady();
  });

  server.expose({
    prepare                 : God.prepare,
    getMonitorData          : God.getMonitorData,
    getSystemData           : God.getSystemData,

    startProcessId          : God.startProcessId,
    stopProcessId           : God.stopProcessId,
    restartProcessId        : God.restartProcessId,
    deleteProcessId         : God.deleteProcessId,

    softReloadProcessId     : God.softReloadProcessId,
    reloadProcessId         : God.reloadProcessId,
    duplicateProcessId      : God.duplicateProcessId,
    resetMetaProcessId      : God.resetMetaProcessId,
    stopWatch               : God.stopWatch,
    restartWatch            : God.restartWatch,
    notifyByProcessId       : God.notifyByProcessId,

    killMe                  : God.killMe,
    notifyKillPM2           : God.notifyKillPM2,
    forceGc                 : God.forceGc,

    findByFullPath          : God.findByFullPath,

    msgProcess              : God.msgProcess,
    sendDataToProcessId     : God.sendDataToProcessId,
    sendSignalToProcessId   : God.sendSignalToProcessId,
    sendSignalToProcessName : God.sendSignalToProcessName,

    ping                    : God.ping,
    getVersion              : God.getVersion,
    reloadLogs              : God.reloadLogs
  });

  /**
   * Action treatment specifics
   * Attach actions to pm2_env.axm_actions variables (name + options)
   */
  God.bus.on(&#x27;axm:action&#x27;, function axmActions(msg) {
    var pm2_env = msg.process;
    var exists  = false;
    var axm_action = msg.data;

    if (!pm2_env || !God.clusters_db[pm2_env.pm_id])
      return console.error(&#x27;Unknown id %s&#x27;, pm2_env.pm_id);

    if (!God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions)
      God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions = [];

    God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions.forEach(function(actions) {
      if (actions.action_name == axm_action.action_name)
        exists = true;
    });

    if (exists === false) {
      debug(&#x27;Adding action&#x27;, axm_action);
      God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions.push(axm_action);
    }

    return God;
  });

  /**
   * Configure module
   */
  God.bus.on(&#x27;axm:option:configuration&#x27;, function axmMonitor(msg) {
    if (!msg.process)
      return console.error(&#x27;[axm:option:configuration] no process defined&#x27;);

    if (!God.clusters_db[msg.process.pm_id])
      return console.error(&#x27;[axm:option:configuration] Unknown id %s&#x27;, msg.process.pm_id);

    try {
      // Application Name nverride
      if (msg.data.name)
        God.clusters_db[msg.process.pm_id].pm2_env.name = msg.data.name;

      Object.keys(msg.data).forEach(function(conf_key) {
        God.clusters_db[msg.process.pm_id]. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Satan._noDaemonMode = noDaemonMode;

  Satan.pingDaemon(function(ab) {
    // If Daemon not alive
    if (ab == false) {
if (noDaemonMode) {
  debug(&#x27;Launching in no daemon mode&#x27;);
  Satan.<span class="apidocCodeKeywordSpan">remoteWrapper</span>();
  return Satan.launchRPC(function() {
    require(&#x27;./Modularizer.js&#x27;).launchAll(cb);
  });
}

Satan.printOut(cst.PREFIX_MSG + &#x27;Spawning PM2 daemon&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Satan.restartWatch" id="apidoc.element.pm2.Satan.restartWatch">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>restartWatch
        <span class="apidocSignatureSpan">(method, env, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function restartWatch(method, env, fn) {
  debug(&#x27;Calling restartWatch&#x27;);
  Satan.client.call(&#x27;restartWatch&#x27;, method, env, function() {
    debug(&#x27;Restart watching&#x27;);
    return fn ? fn() : false;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else if(method.indexOf(&#x27;kill&#x27;) !== -1) {
  Satan.stopWatch(&#x27;deleteAll&#x27;, env);
//stop watch on stop (stop doesn&#x27;t accept env, yet)
} else if (~process.argv.indexOf(&#x27;--watch&#x27;) &#x26;&#x26; method.indexOf(&#x27;stop&#x27;) !== -1) {
  Satan.stopWatch(method, env);
//restart watch
} else if (env_watch &#x26;&#x26; method.indexOf(&#x27;restart&#x27;) !== -1) {
  Satan.<span class="apidocCodeKeywordSpan">restartWatch</span>(method, env);
}

if (!Satan.client || !Satan.client.call) {
  if (fn) return fn(new Error(&#x27;Could not connect to local pm2, have you called pm2.connect(function()})&#x27;));
  console.error(&#x27;Did you forgot to call pm2.connect(function() { }) before interacting with PM2 ?&#x27;);
  return process.exit(0);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Satan.start" id="apidoc.element.pm2.Satan.start">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>start
        <span class="apidocSignatureSpan">(noDaemonMode, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (noDaemonMode, cb) {
  if (typeof(noDaemonMode)  == &#x22;function&#x22;) {
    cb = noDaemonMode;
    noDaemonMode = false;
  }

  Satan._noDaemonMode = noDaemonMode;

  Satan.pingDaemon(function(ab) {
    // If Daemon not alive
    if (ab == false) {
      if (noDaemonMode) {
        debug(&#x27;Launching in no daemon mode&#x27;);
        Satan.remoteWrapper();
        return Satan.launchRPC(function() {
          require(&#x27;./Modularizer.js&#x27;).launchAll(cb);
        });
      }

      Satan.printOut(cst.PREFIX_MSG + &#x27;Spawning PM2 daemon&#x27;);

      // Daemonize PM2
      return Satan.launchDaemon(function(err, child) {
        if (err) {
          console.error(err);
          return cb ? cb(err) : process.exit(cst.ERROR_EXIT);
        }
        Satan.printOut(cst.PREFIX_MSG + &#x27;PM2 Successfully daemonized&#x27;);
        // Launch RPC
        return Satan.launchRPC(function() {
          require(&#x27;./Modularizer.js&#x27;).launchAll(cb);
        });
      });
    }
    // Else just start the PM2 client side (RPC)
    return Satan.launchRPC(cb);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
else if (method.indexOf(&#x27;restartProcessId&#x27;) !== -1 &#x26;&#x26; process.argv.indexOf(&#x27;--watch&#x27;) &#x3e; -1) {
  delete app_conf.env.current_conf.watch;
  this.toggleWatch(method, app_conf);
}

if (!this.client || !this.client.call) {
  this.<span class="apidocCodeKeywordSpan">start</span>(function(error) {
    if (error) {
      if (fn)
        return fn(error);
      console.error(error);
      return process.exit(0);
    }
    return self.client.call(method, app_conf, fn);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Satan.stopWatch" id="apidoc.element.pm2.Satan.stopWatch">
        function <span class="apidocSignatureSpan">pm2.Satan.</span>stopWatch
        <span class="apidocSignatureSpan">(method, env, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopWatch(method, env, fn) {
  debug(&#x27;Calling stopWatch&#x27;);
  Satan.client.call(&#x27;stopWatch&#x27;, method, env, function() {
    debug(&#x27;Stop watching&#x27;);
    return fn ? fn() : false;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return
 */
Client.prototype.executeRemote = function executeRemote(method, app_conf, fn) {
var self = this;

// stop watch on stop | env is the process id
if (method.indexOf(&#x27;stop&#x27;) !== -1) {
  this.<span class="apidocCodeKeywordSpan">stopWatch</span>(method, app_conf);
}
// stop watching when process is deleted
else if (method.indexOf(&#x27;delete&#x27;) !== -1) {
  this.stopWatch(method, app_conf);
}
// stop everything on kill
else if (method.indexOf(&#x27;kill&#x27;) !== -1) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2.Utility" id="apidoc.module.pm2.Utility">module pm2.Utility</a></h1>


    <h2>
        <a href="#apidoc.element.pm2.Utility.clone" id="apidoc.element.pm2.Utility.clone">
        function <span class="apidocSignatureSpan">pm2.Utility.</span>clone
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function (obj) {
  if (obj === null || obj === undefined) return {};
  return fclone(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  try {
    // Application Name nverride
    if (msg.data.name)
      God.clusters_db[msg.process.pm_id].pm2_env.name = msg.data.name;

    Object.keys(msg.data).forEach(function(conf_key) {
      God.clusters_db[msg.process.pm_id].pm2_env.axm_options[conf_key] = Utility.<span class="apidocCodeKeywordSpan">clone</span
>(msg.data[conf_key]);
    });
  } catch(e) {
    console.error(e.stack || e);
  }
  msg = null;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Utility.extend" id="apidoc.element.pm2.Utility.extend">
        function <span class="apidocSignatureSpan">pm2.Utility.</span>extend
        <span class="apidocSignatureSpan">(destination, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (destination, source){
  if (!source || typeof source != &#x27;object&#x27;) return destination;

    Object.keys(source).forEach(function(new_key) {
      if (source[new_key] != &#x27;[object Object]&#x27;)
        destination[new_key] = source[new_key];
    });

  return destination;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Mixed} env
 * @param {Function} cb
 * @return Literal
 */
God.executeApp = function executeApp(env, cb) {
var env_copy = Utility.clone(env);

Utility.<span class="apidocCodeKeywordSpan">extend</span>(env_copy, env_copy.env);

env_copy[&#x27;status&#x27;]         = cst.LAUNCHING_STATUS;
env_copy[&#x27;pm_uptime&#x27;]      = Date.now();
env_copy[&#x27;axm_actions&#x27;]    = [];
env_copy[&#x27;axm_monitor&#x27;]    = {};
env_copy[&#x27;axm_options&#x27;]    = {};
env_copy[&#x27;axm_dynamic&#x27;]    = {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Utility.extendExtraConfig" id="apidoc.element.pm2.Utility.extendExtraConfig">
        function <span class="apidocSignatureSpan">pm2.Utility.</span>extendExtraConfig
        <span class="apidocSignatureSpan">(proc, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendExtraConfig = function (proc, opts) {
  if (opts.env &#x26;&#x26; opts.env.current_conf) {
    Utility.extend(proc.pm2_env, opts.env.current_conf);
    delete opts.env.current_conf;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Utility.formatCLU" id="apidoc.element.pm2.Utility.formatCLU">
        function <span class="apidocSignatureSpan">pm2.Utility.</span>formatCLU
        <span class="apidocSignatureSpan">(process)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatCLU = function (process) {
  if (!process.pm2_env) {
    return process;
  }

  var obj = Utility.clone(process.pm2_env);
  delete obj.env;

  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

module.exports = function(God) {

God.notify = function(action_name, data, manually) {
  God.bus.emit(&#x27;process:event&#x27;, {
    event      : action_name,
    manually   : typeof(manually) == &#x27;undefined&#x27; ? false : true,
    process    : Utility.<span class="apidocCodeKeywordSpan">formatCLU</span>(data),
    at         : Utility.getDate()
  });
};

God.notifyByProcessId = function(opts, cb) {
  if (typeof(opts.id) === &#x27;undefined&#x27;) { return cb(new Error(&#x27;process id missing&#x27;)); }
  var proc = God.clusters_db[opts.id];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Utility.getDate" id="apidoc.element.pm2.Utility.getDate">
        function <span class="apidocSignatureSpan">pm2.Utility.</span>getDate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDate = function () {
  return Date.now();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
module.exports = function(God) {

God.notify = function(action_name, data, manually) {
  God.bus.emit(&#x27;process:event&#x27;, {
    event      : action_name,
    manually   : typeof(manually) == &#x27;undefined&#x27; ? false : true,
    process    : Utility.formatCLU(data),
    at         : Utility.<span class="apidocCodeKeywordSpan">getDate</span>()
  });
};

God.notifyByProcessId = function(opts, cb) {
  if (typeof(opts.id) === &#x27;undefined&#x27;) { return cb(new Error(&#x27;process id missing&#x27;)); }
  var proc = God.clusters_db[opts.id];
  if (!proc) { return cb(new Error(&#x27;process id doesnt exists&#x27;)); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Utility.overrideConsole" id="apidoc.element.pm2.Utility.overrideConsole">
        function <span class="apidocSignatureSpan">pm2.Utility.</span>overrideConsole
        <span class="apidocSignatureSpan">(bus)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">overrideConsole = function (bus) {
  if (cst.PM2_LOG_DATE_FORMAT &#x26;&#x26; typeof cst.PM2_LOG_DATE_FORMAT == &#x27;string&#x27;){
    var moment = require(&#x27;moment&#x27;);

    // Generate timestamp prefix
    function timestamp(){
      return moment().format(cst.PM2_LOG_DATE_FORMAT) + &#x27;: &#x27;;
    }

    var hacks = [&#x27;info&#x27;, &#x27;log&#x27;, &#x27;error&#x27;, &#x27;warn&#x27;], consoled = {};

    // store console functions.
    hacks.forEach(function(method){
      consoled[method] = console[method];
    });

    hacks.forEach(function(k){
      console[k] = function(){
        if (bus) {
          bus.emit(&#x27;log:PM2&#x27;, {
            process : {
              pm_id      : &#x27;PM2&#x27;,
              name       : &#x27;PM2&#x27;,
              rev        : null
            },
            at  : Utility.getDate(),
            data : util.format.apply(this, arguments) + &#x27;\n&#x27;
          });
        }
        // do not destroy variable insertion
        arguments[0] &#x26;&#x26; (arguments[0] = timestamp() + arguments[0]);
        consoled[k].apply(console, arguments);
      };
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  bus : new EventEmitter2({
    wildcard: true,
    delimiter: &#x27;:&#x27;,
    maxListeners: 1000
  })
};

Utility.<span class="apidocCodeKeywordSpan">overrideConsole</span>(God.bus);

/**
 * Populate God namespace
 */
require(&#x27;./Event.js&#x27;)(God);
require(&#x27;./God/Methods.js&#x27;)(God);
require(&#x27;./God/ForkMode.js&#x27;)(God);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Utility.packageNameToModuleName" id="apidoc.element.pm2.Utility.packageNameToModuleName">
        function <span class="apidocSignatureSpan">pm2.Utility.</span>packageNameToModuleName
        <span class="apidocSignatureSpan">(package_name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">packageNameToModuleName = function (package_name) {
  if (package_name.match(/^(.+\/)?([^\/]+)\.tgz($|\?)/)) {
    package_name = package_name.match(/^(.+\/)?([^\/]+)\.tgz($|\?)/)[2];
    if (package_name.match(/^(.+)-[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9_]+\.[0-9]+)?$/)) {
      package_name = package_name.match(/^(.+)-[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9_]+\.[0-9]+)?$/)[1];
    }
  }
  return package_name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Utility.startLogging" id="apidoc.element.pm2.Utility.startLogging">
        function <span class="apidocSignatureSpan">pm2.Utility.</span>startLogging
        <span class="apidocSignatureSpan">(stds, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startLogging = function (stds, callback) {
<span class="apidocCodeCommentSpan">  /**
   * Start log outgoing messages
   * @method startLogging
   * @param {} callback
   * @return
   */
</span>  // Make sure directories of `logs` and `pids` exist.
  // try {
  //   [&#x27;logs&#x27;, &#x27;pids&#x27;].forEach(function(n){
  //     console.log(n);
  //     (function(_path){
  //       !fs.existsSync(_path) &#x26;&#x26; fs.mkdirSync(_path, &#x27;0755&#x27;);
  //     })(path.resolve(cst.PM2_ROOT_PATH, n));
  //   });
  // } catch(err) {
  //   return callback(new Error(&#x27;can not create directories (logs/pids):&#x27; + err.message));
  // }

  // waterfall.
  var flows = [];
  // types of stdio, should be sorted as `std(entire log)`, `out`, `err`.
  var types = Object.keys(stds).sort(function(x, y){
    return -x.charCodeAt(0) + y.charCodeAt(0);
  });

  // Create write streams.
  (function createWS(io){
    if(io.length != 1){
      return false;
    }
    io = io[0];

    // If `std` is a Stream type, try next `std`.
    // compatible with `pm2 reloadLogs`
    if(typeof stds[io] == &#x27;object&#x27; &#x26;&#x26; !isNaN(stds[io].fd)){
      return createWS(types.splice(0, 1));
    }

    flows.push(function(next){
      var file = stds[io];
      // if file contains ERR or /dev/null, dont try to create stream since he dont want logs
      if (!file || file.indexOf(&#x27;NULL&#x27;) &#x3e; -1 || file.indexOf(&#x27;/dev/null&#x27;) &#x3e; -1)
        return next();
      stds[io] = fs.createWriteStream(file, {flags: &#x27;a&#x27;})
        .on(&#x27;error&#x27;, function(err){
          next(err);
        })
        .on(&#x27;open&#x27;, function(){
          next();
        });
      stds[io]._file = file;
    });
    return createWS(types.splice(0, 1));
  })(types.splice(0, 1));

  async.waterfall(flows, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.Utility.whichFileExists" id="apidoc.element.pm2.Utility.whichFileExists">
        function <span class="apidocSignatureSpan">pm2.Utility.</span>whichFileExists
        <span class="apidocSignatureSpan">(file_arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whichFileExists = function (file_arr) {
  var f = null;

  file_arr.some(function(file) {
    try {
      fs.statSync(file);
    } catch(e) {
      return false;
    }
    f = file;
    return true;
  });
  return f;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2.completion" id="apidoc.module.pm2.completion">module pm2.completion</a></h1>


    <h2>
        <a href="#apidoc.element.pm2.completion.complete" id="apidoc.element.pm2.completion.complete">
        function <span class="apidocSignatureSpan">pm2.completion.</span>complete
        <span class="apidocSignatureSpan">(name, completer, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function complete(name, completer, cb) {

  // cb not there, assume callback is completer and
  // the completer is the executable itself
  if(!cb) {
    cb = completer;
    completer = name;
  }

  var env = parseEnv();

  // if not a complete command, return here.
  if(!env.complete) return cb();

  // if install cmd, add complete script to either ~/.bashrc or ~/.zshrc
  if(env.install) return install(name, completer, function(err, state) {
    console.log(state || err.message);
    if(err) return cb(err);
    cb(null, null, state);
  });

  // if install cmd, add complete script to either ~/.bashrc or ~/.zshrc
  if(env.uninstall) return uninstall(name, completer, function(err, state) {
    console.log(state || err.message);
    if(err) return cb(err);
    cb(null, null, state);
  });

  // if the COMP_* are not in the env, then dump the install script.
  if(!env.words || !env.point || !env.line) return script(name, completer, function(err, content) {
    if(err) return cb(err);
    process.stdout.write(content, function (n) { cb(null, null, content); });
    process.stdout.on(&#x22;error&#x22;, function (er) {
      // Darwin is a real dick sometimes.
      //
      // This is necessary because the &#x22;source&#x22; or &#x22;.&#x22; program in
      // bash on OS X closes its file argument before reading
      // from it, meaning that you get exactly 1 write, which will
      // work most of the time, and will always raise an EPIPE.
      //
      // Really, one should not be tossing away EPIPE errors, or any
      // errors, so casually.  But, without this, `. &#x3c;(npm completion)`
      // can never ever work on OS X.
      //      -- isaacs
      // https://github.com/isaacs/npm/blob/master/lib/completion.js#L162
      if (er.errno === &#x22;EPIPE&#x22;) er = null
      cb(er, null, content);
    });
    cb(null, null, content);
  });

  var partial = env.line.substr(0, env.point),
  last = env.line.split(&#x27; &#x27;).slice(-1).join(&#x27;&#x27;),
  lastPartial = partial.split(&#x27; &#x27;).slice(-1).join(&#x27;&#x27;),
  prev = env.line.split(&#x27; &#x27;).slice(0, -1).slice(-1)[0];

  cb(null, {
    line: env.line,
    words: env.words,
    point: env.point,
    partial: partial,
    last: last,
    prev: prev,
    lastPartial: lastPartial
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.completion.isComplete" id="apidoc.element.pm2.completion.isComplete">
        function <span class="apidocSignatureSpan">pm2.completion.</span>isComplete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isComplete() {
  var env = parseEnv();
  return env.complete || (env.words &#x26;&#x26; env.point &#x26;&#x26; env.line);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.completion.log" id="apidoc.element.pm2.completion.log">
        function <span class="apidocSignatureSpan">pm2.completion.</span>log
        <span class="apidocSignatureSpan">(arr, o, prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log(arr, o, prefix) {
  prefix = prefix || &#x27;&#x27;;
  arr = Array.isArray(arr) ? arr : [arr];
  arr.filter(abbrev(o)).forEach(function(v) {
    console.log(prefix + v);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var daemon = new Daemon({
  pub_socket_file : that.conf.DAEMON_PUB_PORT,
  rpc_socket_file : that.conf.DAEMON_RPC_PORT,
  pid_file        : that.conf.PM2_PID_FILE_PATH
});

console.<span class="apidocCodeKeywordSpan">log</span>(&#x27;Launching in no daemon mode&#x27;);

daemon.innerStart(function() {
  KMDaemon.launchAndInteract(that.conf, {
    machine_name : that.machine_name,
    public_key   : that.public_key,
    secret_key   : that.secret_key
  }, function(err, data, interactor_proc) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.completion.parseOut" id="apidoc.element.pm2.completion.parseOut">
        function <span class="apidocSignatureSpan">pm2.completion.</span>parseOut
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseOut(str) {
  var shorts = str.match(/\s-\w+/g);
  var longs = str.match(/\s--\w+/g);

  return {
    shorts: shorts.map(trim).map(cleanPrefix),
    longs: longs.map(trim).map(cleanPrefix)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.completion.parseTasks" id="apidoc.element.pm2.completion.parseTasks">
        function <span class="apidocSignatureSpan">pm2.completion.</span>parseTasks
        <span class="apidocSignatureSpan">(str, prefix, reg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseTasks = function (str, prefix, reg) {
  var tasks = str.match(reg || new RegExp(&#x27;^&#x27; + prefix + &#x27;\\s[^#]+&#x27;, &#x27;gm&#x27;)) || [];
  return tasks.map(trim).map(function(s) {
    return s.replace(prefix + &#x27; &#x27;, &#x27;&#x27;);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2.custom" id="apidoc.module.pm2.custom">module pm2.custom</a></h1>


    <h2>
        <a href="#apidoc.element.pm2.custom.custom" id="apidoc.element.pm2.custom.custom">
        function <span class="apidocSignatureSpan">pm2.</span>custom
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">custom = function (opts) {
  if (!opts) opts = {};
  var that = this;

  this.daemon_mode = typeof(opts.daemon_mode) == &#x27;undefined&#x27; ? true : opts.daemon_mode;
  this.pm2_home    = conf.PM2_ROOT_PATH;
  this.public_key   = process.env.KEYMETRICS_SECRET || opts.public_key || null;
  this.secret_key   = process.env.KEYMETRICS_PUBLIC || opts.secret_key || null;
  this.machine_name = process.env.INSTANCE_NAME || opts.machine_name || null

<span class="apidocCodeCommentSpan">  /**
   * CWD resolution
   */
</span>  this.cwd         = process.cwd();
  if (opts.cwd) {
    this.cwd = path.resolve(opts.cwd);
  }

  /**
   * PM2 HOME resolution
   */
  if (opts.pm2_home &#x26;&#x26; opts.independent == true)
    throw new Error(&#x27;You cannot set a pm2_home and independent instance in same time&#x27;);

  if (opts.pm2_home) {
    // Override default conf file
    this.pm2_home        = opts.pm2_home;
    conf = util._extend(conf, path_structure(this.pm2_home));
  }
  else if (opts.independent == true &#x26;&#x26; conf.IS_WINDOWS === false) {
    // Create an unique pm2 instance
    var crypto = require(&#x27;crypto&#x27;);
    var random_file = crypto.randomBytes(8).toString(&#x27;hex&#x27;);
    this.pm2_home = path.join(&#x27;/tmp&#x27;, random_file);

    // If we dont explicitly tell to have a daemon
    // It will go as in proc
    if (typeof(opts.daemon_mode) == &#x27;undefined&#x27;)
      this.daemon_mode = false;
    conf = util._extend(conf, path_structure(this.pm2_home));
  }

  this._conf = conf;

  if (conf.IS_WINDOWS) {
    // Weird fix, may need to be dropped
    // @todo windows connoisseur double check
    if (process.stdout._handle &#x26;&#x26; process.stdout._handle.setBlocking)
      process.stdout._handle.setBlocking(true);
  }

  this.Client = new Client({
    pm2_home : that.pm2_home,
    conf     : this._conf,
    secret_key : this.secret_key,
    public_key : this.public_key,
    daemon_mode : this.daemon_mode,
    machine_name : this.machine_name
  });

  this.gl_interact_infos = null;
  this.gl_is_km_linked = false;

  try {
    var pid = fs.readFileSync(conf.INTERACTOR_PID_PATH);
    pid = parseInt(pid.toString().trim());
    process.kill(pid, 0);
    that.gl_is_km_linked = true;
  } catch(e) {
    that.gl_is_km_linked = false;
  }

  // For testing purposes
  if (this.secret_key &#x26;&#x26; process.env.NODE_ENV == &#x27;local_test&#x27;)
    that.gl_is_km_linked = true;

  KMDaemon.getInteractInfo(this._conf, function(i_err, interact) {
    that.gl_interact_infos = interact;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fmt       = require(&#x27;./tools/fmt.js&#x27;);
var exec      = require(&#x27;child_process&#x27;).exec;
var os        = require(&#x27;os&#x27;);

commander.version(pkg.version)
  .usage(&#x27;[cmd] app&#x27;);

var pm2 = new PM2.<span class="apidocCodeKeywordSpan">custom</span>({
  pm2_home : path.join(os.homedir ? os.homedir() : (process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE), &#x27;.
pm2-dev&#x27;)
});

pm2.connect(function() {
  commander.parse(process.argv);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pm2.custom.prototype" id="apidoc.module.pm2.custom.prototype">module pm2.custom.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pm2.custom.prototype._handleAttributeUpdate" id="apidoc.element.pm2.custom.prototype._handleAttributeUpdate">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_handleAttributeUpdate
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleAttributeUpdate = function (opts) {
  var conf = Config.transCMDToConf(opts);
  var that = this;

  if (typeof(conf.name) != &#x27;string&#x27;)
    delete conf.name;

  var argsIndex = 0;
  if (opts.rawArgs &#x26;&#x26; (argsIndex = opts.rawArgs.indexOf(&#x27;--&#x27;)) &#x3e;= 0) {
    conf.args = opts.rawArgs.slice(argsIndex + 1);
  }

  var appConf = Common.verifyConfs(conf)[0];

  if (appConf instanceof Error) {
    Common.printError(&#x27;Error while transforming CamelCase args to underscore&#x27;);
    return appConf;
  }

  if (argsIndex == -1)
    delete appConf.args;
  if (appConf.name == &#x27;undefined&#x27;)
    delete appConf.name;

  delete appConf.exec_mode;

  if(util.isArray(appConf.watch) &#x26;&#x26; appConf.watch.length === 0) {
    if(!~opts.rawArgs.indexOf(&#x27;--watch&#x27;))
      delete appConf.watch
  }

  return appConf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype._operate" id="apidoc.element.pm2.custom.prototype._operate">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_operate
        <span class="apidocSignatureSpan">(action_name, process_name, envs, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_operate = function (action_name, process_name, envs, cb) {
  var that = this;
  var update_env = false;
  var ret = [];

  // Make sure all options exist

  if (!envs)
    envs = {};

  if (typeof(envs) == &#x27;function&#x27;){
    cb = envs;
    envs = {};
  }

  // Set via env.update (JSON processing)
  if (envs.updateEnv === true)
    update_env = true;

  if (!process.env.PM2_JSON_PROCESSING || envs.commands) {
    envs = that._handleAttributeUpdate(envs);
  }

<span class="apidocCodeCommentSpan">  /**
   * Set current updated configuration if not passed
   */
</span>  if (!envs.current_conf) {
    var _conf = fclone(envs);
    envs = {
      current_conf : _conf
    }

    // Is KM linked?
    envs.current_conf.km_link = that.gl_is_km_linked;
  }

  /**
   * Operate action on specific process id
   */
  function processIds(ids, cb) {
    Common.printOut(conf.PREFIX_MSG + &#x27;Applying action %s on app [%s](ids: %s)&#x27;, action_name, process_name, ids);

    var concurrent_actions = conf.CONCURRENT_ACTIONS;
    if (action_name == &#x27;deleteProcessId&#x27;)
      concurrent_actions = 10;

    async.eachLimit(ids, concurrent_actions, function(id, next) {
      var opts;

      // These functions need extra param to be passed
      if (action_name == &#x27;restartProcessId&#x27; ||
          action_name == &#x27;reloadProcessId&#x27; ||
          action_name == &#x27;softReloadProcessId&#x27;) {
        var new_env = {};

        if (update_env === true) {
          if (conf.PM2_PROGRAMMATIC == true)
            new_env = Common.safeExtend({}, process.env);
          else
            new_env = util._extend({}, process.env);

          Object.keys(envs).forEach(function(k) {
            new_env[k] = envs[k];
          });
        }
        else {
          new_env = envs;
        }

        opts = {
          id  : id,
          env : new_env
        };
      }
      else {
        opts = id;
      }

      that.Client.executeRemote(action_name, opts, function(err, res) {
        if (err) {
          Common.printError(conf.PREFIX_MSG_ERR + &#x27;Process %s not found&#x27;, id);
          return next(&#x27;Process not found&#x27;);
        }

        if (action_name == &#x27;restartProcessId&#x27;) {
          that.Client.notifyGod(&#x27;restart&#x27;, id);
        } else if (action_name == &#x27;deleteProcessId&#x27;) {
          that.Client.notifyGod(&#x27;delete&#x27;, id);
        } else if (action_name == &#x27;stopProcessId&#x27;) {
          that.Client.notifyGod(&#x27;stop&#x27;, id);
        } else if (action_name == &#x27;reloadProcessId&#x27;) {
          that.Client.notifyGod(&#x27;reload&#x27;, id);
        } else if (action_name == &#x27;softReloadProcessId&#x27;) {
          that.Client.notifyGod(&#x27;graceful reload&#x27;, id);
        }

        if (!Array.isArray(res))
          res = [res];

        // Filter return
        res.forEach(function(proc) {
          Common.printOut(conf.PREFIX_MSG + &#x27;[%s](%d) \u2713&#x27;, proc.pm2_env ? proc.pm2_env.name : process_name, id);

          if (!proc.pm2_env) return false;

          ret.push({
            name         : proc.pm2_env.name,
            pm_id        : proc.pm2_env.pm_id,
            status       : proc.pm2_env.status,
            restart_time : proc.pm2_env.restart_time,
            pm2_env : {
              name         : proc.pm2_env.name,
              pm_id        : proc.pm2_env.pm_id,
              status       : proc.pm2_env.status,
              restart_time : proc.pm2_env.restart_time,
              env          : proc.pm2_env.env
            }
          });
        });

        return next();
      });
    }, function(err) {
      if (err) return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
      return cb ? cb(null, ret) : that.speedList();
    });
  }

  if (process_name == &#x27;all&#x27;) {
    that.Client.getAllProcessId(function(err, ids) {
      if (err) {
        Common.printError(err);
        return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
      }
      if (!ids || ids.length === 0) {
        Common.printError(conf.PREFIX_MSG_WARNING + &#x27;No process found&#x27;);
        return cb ? cb(new Error(&#x27;process name not found&#x27;)) : that.exitCli(conf.ERROR_EXIT);
      }

      return processIds(ids, cb);
    });
  }
  // operate using regex ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype._pre_interact" id="apidoc.element.pm2.custom.prototype._pre_interact">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_pre_interact
        <span class="apidocSignatureSpan">(cmd, public_key, machine, info_node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_pre_interact = function (cmd, public_key, machine, info_node) {
  var that = this;

  if (cmd == &#x27;stop&#x27; || cmd == &#x27;kill&#x27;) {
    console.log(chalk.cyan(&#x27;[Keymetrics.io]&#x27;) + &#x27; Stopping agent...&#x27;);
    that.killInteract(function() {
      console.log(chalk.cyan(&#x27;[Keymetrics.io]&#x27;) + &#x27; Stopped&#x27;);
      return process.exit(cst.SUCCESS_EXIT);
    });
    return false;
  }

  if (cmd == &#x27;info&#x27;) {
    console.log(chalk.cyan(&#x27;[Keymetrics.io]&#x27;) + &#x27; Getting agent information...&#x27;);
    that.interactInfos(function(err, infos) {
      if (err) {
        console.error(err.message);
        return that.exitCli(cst.ERROR_EXIT);
      }
      console.log(infos);
      return that.exitCli(cst.SUCCESS_EXIT);
    });
    return false;
  }

  if (cmd == &#x27;delete&#x27;) {
    that.killInteract(function() {
      try {
        fs.unlinkSync(cst.INTERACTION_CONF);
      } catch(e) {
        console.log(chalk.cyan(&#x27;[Keymetrics.io]&#x27;) + &#x27; No interaction config file found&#x27;);
        return process.exit(cst.SUCCESS_EXIT);
      }
      console.log(chalk.cyan(&#x27;[Keymetrics.io]&#x27;) + &#x27; Agent interaction ended&#x27;);
      return process.exit(cst.SUCCESS_EXIT);
    });
    return false;
  }

  if (cmd == &#x27;start&#x27; || cmd == &#x27;restart&#x27;) {
    KMDaemon.launchAndInteract(that._conf, {
      public_key : null,
      secret_key : null,
      machine_name : null,
      info_node : null
    }, function(err, dt) {
      if (err) {
        Common.printError(err);
        return that.exitCli(cst.ERROR_EXIT);
      }
      return that.exitCli(cst.SUCCESS_EXIT);
    });
  }

  if (cmd &#x26;&#x26; !public_key) {
    console.error(chalk.cyan(&#x27;[Keymetrics.io]&#x27;) + &#x27; Command [%s] unknown or missing public key&#x27;, cmd);
    return process.exit(cst.ERROR_EXIT);
  }

  var infos;

  if (!cmd) {
    infos = null;
  }
  else
    infos = {
      public_key : public_key,
      secret_key : cmd,
      machine_name : machine,
      info_node : info_node.infoNode || null
    }

  KMDaemon.launchAndInteract(that._conf, infos, function(err, dt) {
    if (err)
      return that.exitCli(cst.ERROR_EXIT);
    return that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype._pull" id="apidoc.element.pm2.custom.prototype._pull">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_pull
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_pull = function (opts, cb) {
  var that = this;

  var process_name = opts.process_name;
  var reload_type = opts.action;

  printOut(cst.PREFIX_MSG + &#x27;Updating repository for process name %s&#x27;, process_name);

  that.Client.getProcessByName(process_name, function(err, processes) {

    if (processes.length === 0) {
      printError(&#x27;No processes with this name: %s&#x27;, process_name);
      return cb ? cb({msg:&#x27;Process not found: &#x27;+process_name}) : that.exitCli(cst.ERROR_EXIT);
    }

    var proc = processes[0];
    if (!proc.pm2_env.versioning) {
      printOut(cst.PREFIX_MSG + &#x27;No versioning system found for process %s&#x27;, process_name);
      return cb ? cb({success:false, msg: &#x27;No versioning system found for process&#x27;}) : that.exitCli(cst.SUCCESS_EXIT);
    }
    vizion.update({
      folder: proc.pm2_env.versioning.repo_path
    }, function(err, meta) {
      if (err !== null) {
        return cb ? cb({msg:err}) : that.exitCli(cst.ERROR_EXIT);
      }

      if (meta.success === true) {
        getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function (command_list) {
          execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err, res) {
            if (err !== null) {
              printError(err);
              return cb ? cb({msg: meta.output + err}) : that.exitCli(cst.ERROR_EXIT);
            }
            else {
              printOut(cst.PREFIX_MSG + &#x27;Process successfully updated %s&#x27;, process_name);
              printOut(cst.PREFIX_MSG + &#x27;Current commit %s&#x27;, meta.current_revision);
              return that[reload_type](process_name, function(err, procs) {
                if (err &#x26;&#x26; cb) return cb(err);
                if (err) console.error(err);
                return cb ? cb(null, meta.output + res) : that.exitCli(cst.SUCCESS_EXIT);
              });
            }
          });
        });
      }
      else {
        printOut(cst.PREFIX_MSG + &#x27;Already up-to-date or an error occured for app: %s&#x27;, process_name);
        return cb ? cb({success:false, msg : &#x27;Already up to date&#x27;}) : that.exitCli(cst.SUCCESS_EXIT);
      }
      return false;
    });
    return false;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype._pullCommitId" id="apidoc.element.pm2.custom.prototype._pullCommitId">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_pullCommitId
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_pullCommitId = function (opts, cb) {
  this.pullCommitId(opts.pm2_name, opts.commit_id, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype._startJson" id="apidoc.element.pm2.custom.prototype._startJson">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_startJson
        <span class="apidocSignatureSpan">(file, opts, action, pipe, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_startJson = function (file, opts, action, pipe, cb) {
  var config     = {};
  var appConf    = {};
  var deployConf = {};
  var apps_info  = [];
  var that = this;

  if (typeof(cb) === &#x27;undefined&#x27; &#x26;&#x26; typeof(pipe) === &#x27;function&#x27;)
    cb = pipe;

  if (typeof(file) === &#x27;object&#x27;)
    config = file;
  else if (pipe == &#x27;pipe&#x27;)
    config = Common.parseConfig(file, &#x27;pipe&#x27;);
  else {
    var data = null;

    var file_path = path.isAbsolute(file) ? file : path.join(that.cwd, file);

    debug(&#x27;Resolved filepath %s&#x27;, file_path);

    try {
      data = fs.readFileSync(file_path);
    } catch(e) {
      Common.printError(conf.PREFIX_MSG_ERR + &#x27;File &#x27; + file +&#x27; not found&#x27;);
      return cb ? cb(Common.retErr(e)) : that.exitCli(conf.ERROR_EXIT);
    }

    try {
      config = Common.parseConfig(data, file);
    } catch(e) {
      Common.printError(conf.PREFIX_MSG_ERR + &#x27;File &#x27; + file + &#x27; malformated&#x27;);
      console.error(e);
      return cb ? cb(Common.retErr(e)) : that.exitCli(conf.ERROR_EXIT);
    }
  }

  if (config.deploy)
    deployConf = config.deploy;

  if (config.apps)
    appConf = config.apps;
  else
    appConf = config;

  if (!Array.isArray(appConf))
    appConf = [appConf]; //convert to array

  if ((appConf = Common.verifyConfs(appConf)) instanceof Error)
    return cb ? cb(appConf) : that.exitCli(conf.ERROR_EXIT);

  process.env.PM2_JSON_PROCESSING = true;

  // Get App list
  var apps_name = [];
  var proc_list = {};

  appConf.forEach(function(app) {
    if (opts.only &#x26;&#x26; opts.only != app.name)
      return false;
    if (!app.watch &#x26;&#x26; opts.watch &#x26;&#x26; opts.watch === true)
      app.watch = true;
    if (!app.ignore_watch &#x26;&#x26; opts.ignore_watch)
      app.ignore_watch = opts.ignore_watch;
    if (opts.instances &#x26;&#x26; typeof(opts.instances) === &#x27;number&#x27;)
      app.instances = opts.instances;
    if (app.append_env_to_name &#x26;&#x26; opts.env) {
      app.name += (&#x27;-&#x27; + opts.env);
    }
    apps_name.push(app.name);
  });

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, raw_proc_list) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
    }

<span class="apidocCodeCommentSpan">    /**
     * Uniquify in memory process list
     */
</span>    raw_proc_list.forEach(function(proc) {
      proc_list[proc.name] = proc;
    });

    /**
     * Auto detect application already started
     * and act on them depending on action
     */
    async.eachLimit(Object.keys(proc_list), conf.CONCURRENT_ACTIONS, function(proc_name, next) {
      // Skip app name (--only option)
      if (apps_name.indexOf(proc_name) == -1)
        return next();

      if (!(action == &#x27;reloadProcessId&#x27; ||
            action == &#x27;softReloadProcessId&#x27; ||
            action == &#x27;restartProcessId&#x27;))
        throw new Error(&#x27;Wrong action called&#x27;);


      // Get `env` from appConf by name
      async.filter(appConf, function(app, callback){
        callback(app.name == proc_name);
      }, function(apps){
        var envs = apps.map(function(app){
          // Binds env_diff to env and returns it.
          return Common.mergeEnvironmentVariables(app, opts.env, deployConf);
        });

        // Assigns own enumerable properties of all
        // Notice: if people use the same name in different apps,
        //         duplicated envs will be overrode by the last one
        var env = envs.reduce(function(e1, e2){
          return util._extend(e1, e2);
        });

        // When we are processing JSON, allow to keep the new env by default
        env.updateEnv = true;

        // Pass `env` option
        that._operate(action, proc_name, env, function(err, ret) {
          if (err) Common.printError(err);

          // For return
          apps_info = apps_info.concat(ret);

          that.Client.notifyGod(action, proc_name);
          // And Remove from array to spy
          apps_name.splice(apps_name.indexOf(proc_name), 1);
          return next();
        });
      });

    }, function(err) {
      if (err) return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
      if (apps_name.length &#x3e; 0 &#x26;&#x26; action != &#x27;start&#x27;) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype._startScript" id="apidoc.element.pm2.custom.prototype._startScript">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>_startScript
        <span class="apidocSignatureSpan">(script, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_startScript = function (script, opts, cb) {
  if (typeof opts == &#x22;function&#x22;) {
    cb = opts;
    opts = {};
  }
  var that = this;

  var app_conf = Config.transCMDToConf(opts);
  var appConf = {};

  if (!!opts.executeCommand)
    app_conf.exec_mode = &#x27;fork&#x27;;
  else if (opts.instances !== undefined)
    app_conf.exec_mode = &#x27;cluster&#x27;;
  else
    app_conf.exec_mode = &#x27;fork&#x27;;

  if (typeof app_conf.name == &#x27;function&#x27;){
    delete app_conf.name;
  }

  delete app_conf.args;

  var argsIndex;

  if (opts.rawArgs &#x26;&#x26; (argsIndex = opts.rawArgs.indexOf(&#x27;--&#x27;)) &#x3e;= 0) {
    app_conf.args = opts.rawArgs.slice(argsIndex + 1);
  }
  else if (opts.scriptArgs) {
    app_conf.args = opts.scriptArgs;
  }

  app_conf.script = script;

  if ((appConf = Common.verifyConfs(app_conf)) instanceof Error)
    return cb ? cb(Common.retErr(appConf)) : that.exitCli(conf.ERROR_EXIT);

  app_conf = appConf[0];

<span class="apidocCodeCommentSpan">  /**
   * If -w option, write configuration to configuration.json file
   */
</span>  if (appConf.write) {
    var dst_path = path.join(process.env.PWD || process.cwd(), app_conf.name + &#x27;-pm2.json&#x27;);
    Common.printOut(conf.PREFIX_MSG + &#x27;Writing configuration to&#x27;, chalk.blue(dst_path));
    // pretty JSON
    try {
      fs.writeFileSync(dst_path, JSON.stringify(app_conf, null, 2));
    } catch (e) {
      console.error(e.stack || e);
    }
  }

  /**
   * If start &#x3c;app_name&#x3e; start/restart application
   */
  function restartExistingProcessName(cb) {
    if (!isNaN(script) ||
        (typeof script === &#x27;string&#x27; &#x26;&#x26; script.indexOf(&#x27;/&#x27;) != -1) ||
        (typeof script === &#x27;string&#x27; &#x26;&#x26; path.extname(script) !== &#x27;&#x27;))
      return cb(null);

    if (script !== &#x27;all&#x27;) {
      that.Client.getProcessIdByName(script, function(err, ids) {
        if (err &#x26;&#x26; cb) return cb(err);
        if (ids.length &#x3e; 0) {
          that._operate(&#x27;restartProcessId&#x27;, script, opts, function(err, list) {
            if (err) return cb(err);
            Common.printOut(conf.PREFIX_MSG + &#x27;Process successfully started&#x27;);
            return cb(true, list);
          });
        }
        else return cb(null);
      });
    }
    else {
      that._operate(&#x27;restartProcessId&#x27;, &#x27;all&#x27;, function(err, list) {
        if (err) return cb(err);
        Common.printOut(conf.PREFIX_MSG + &#x27;Process successfully started&#x27;);
        return cb(true, list);
      });
    }
  }

  function restartExistingProcessId(cb) {
    if (isNaN(script)) return cb(null);

    that._operate(&#x27;restartProcessId&#x27;, script, opts, function(err, list) {
      if (err) return cb(err);
      Common.printOut(conf.PREFIX_MSG + &#x27;Process successfully started&#x27;);
      return cb(true, list);
    });
  }

  /**
   * Restart a process with the same full path
   * Or start it
   */
  function restartExistingProcessPath(cb) {
    that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, procs) {
      if (err) return cb ? cb(new Error(err)) : that.exitCli(conf.ERROR_EXIT);

      var full_path = path.resolve(that.cwd, script);
      var managed_script = null;

      procs.forEach(function(proc) {
        if (proc.pm2_env.pm_exec_path == full_path &#x26;&#x26;
            proc.pm2_env.name == app_conf.name)
          managed_script = proc;
      });

      if (managed_script &#x26;&#x26;
          (managed_script.pm2_env.status == conf.STOPPED_STATUS ||
           managed_script.pm2_env.status == conf.STOPPING_STATUS ||
           managed_script.pm2_env.status == conf.ERRORED_STATUS)) {
        // Restart process if stopped
        var app_name = managed_script.pm2_env.name;

        that._operate(&#x27;restartProcessId&#x27;, app_name, opts, function(err, list) {
          if (err) return cb ? cb(new Error(err)) : that.exitCli(conf.ERROR_EXIT);
          Common.printOut(conf.PREFIX_MSG + &#x27;Process successfully started&#x27;);
          return cb(true, list);
        });
        return false;
      }
      else if (managed_script &#x26;&#x26; !opts.force) {
        Common.printError(conf.PREFIX_MSG_ERR + &#x27;Script already launched, add -f option to force re-execution&#x27;);
        return cb(new Error(&#x27;Script already launched&#x27;));
      }

      var resolved_paths = null;

      try {
        res ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.actionFromJson" id="apidoc.element.pm2.custom.prototype.actionFromJson">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>actionFromJson
        <span class="apidocSignatureSpan">(action, file, opts, jsonVia, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">actionFromJson = function (action, file, opts, jsonVia, cb) {
  var appConf = {};
  var ret_processes = [];
  var that = this;

  //accept programmatic calls
  if (typeof file == &#x27;object&#x27;) {
    cb = typeof jsonVia == &#x27;function&#x27; ? jsonVia : cb;
    appConf = file;
  }
  else if (jsonVia == &#x27;file&#x27;) {
    var data = null;

    try {
      data = fs.readFileSync(file);
    } catch(e) {
      Common.printError(conf.PREFIX_MSG_ERR + &#x27;File &#x27; + file +&#x27; not found&#x27;);
      return cb ? cb(Common.retErr(e)) : that.exitCli(conf.ERROR_EXIT);
    }

    try {
      appConf = Common.parseConfig(data, file);
    } catch(e) {
      Common.printError(conf.PREFIX_MSG_ERR + &#x27;File &#x27; + file + &#x27; malformated&#x27;);
      console.error(e);
      return cb ? cb(Common.retErr(e)) : that.exitCli(conf.ERROR_EXIT);
    }
  } else if (jsonVia == &#x27;pipe&#x27;) {
    appConf = Common.parseConfig(file, &#x27;pipe&#x27;);
  } else {
    Common.printError(&#x27;Bad call to actionFromJson, jsonVia should be one of file, pipe&#x27;);
    return that.exitCli(conf.ERROR_EXIT);
  }

  // Backward compatibility
  if (appConf.apps)
    appConf = appConf.apps;

  if (!Array.isArray(appConf))
    appConf = [appConf];

  if ((appConf = Common.verifyConfs(appConf)) instanceof Error)
    return cb ? cb(appConf) : that.exitCli(conf.ERROR_EXIT);

  async.eachLimit(appConf, conf.CONCURRENT_ACTIONS, function(proc, next1) {
    var name = &#x27;&#x27;;
    var new_env;

    if (!proc.name)
      name = path.basename(proc.script);
    else
      name = proc.name;

    if (opts.only &#x26;&#x26; opts.only != name)
      return process.nextTick(next1);

    if (opts &#x26;&#x26; opts.env)
      new_env = Common.mergeEnvironmentVariables(proc, opts.env);
    else
      new_env = Common.mergeEnvironmentVariables(proc);

    that.Client.getProcessIdByName(name, function(err, ids) {
      if (err) {
        Common.printError(err);
        return next1();
      }
      if (!ids) return next1();

      async.eachLimit(ids, conf.CONCURRENT_ACTIONS, function(id, next2) {
        var opts = {};

        //stopProcessId could accept options to?
        if (action == &#x27;restartProcessId&#x27;) {
          opts = {id : id, env : new_env};
        } else {
          opts = id;
        }

        that.Client.executeRemote(action, opts, function(err, res) {
          ret_processes.push(res);
          if (err) {
            Common.printError(err);
            return next2();
          }

          if (action == &#x27;restartProcessId&#x27;) {
            that.Client.notifyGod(&#x27;restart&#x27;, id);
          } else if (action == &#x27;deleteProcessId&#x27;) {
            that.Client.notifyGod(&#x27;delete&#x27;, id);
          } else if (action == &#x27;stopProcessId&#x27;) {
            that.Client.notifyGod(&#x27;stop&#x27;, id);
          }

          Common.printOut(conf.PREFIX_MSG + &#x27;[%s](%d) \u2713&#x27;, name, id);
          return next2();
        });
      }, function(err) {
        return next1(null, ret_processes);
      });
    });
  }, function(err) {
    if (cb) return cb(null, ret_processes);
    else return that.speedList();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.backward" id="apidoc.element.pm2.custom.prototype.backward">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>backward
        <span class="apidocSignatureSpan">(process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function (process_name, cb) {
  var that = this;
  printOut(cst.PREFIX_MSG + &#x27;Downgrading to previous commit repository for process name %s&#x27;, process_name);

  that.Client.getProcessByName(process_name, function(err, processes) {

    if (processes.length === 0) {
      printError(&#x27;No processes with this name: %s&#x27;, process_name);
      return cb ? cb({msg:&#x27;Process not found: &#x27;+process_name}) : that.exitCli(cst.ERROR_EXIT);
    }

    var proc = processes[0];

    if (proc.pm2_env.versioning === undefined ||
        proc.pm2_env.versioning === null)
      return cb({msg : &#x27;Versioning unknown&#x27;});

    vizion.prev({
      folder: proc.pm2_env.versioning.repo_path
    }, function(err, meta) {
      if (err)
        return cb ? cb({msg:err, data : meta}) : that.exitCli(cst.ERROR_EXIT);

      if (meta.success !== true) {
        printOut(cst.PREFIX_MSG + &#x27;No versioning system found for process %s&#x27;, process_name);
        return cb ? cb({msg:err, data : meta}) : that.exitCli(cst.ERROR_EXIT);;
      }

      getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function (command_list) {
        execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err, res) {
          if (err !== null) {
            vizion.next({folder: proc.pm2_env.versioning.repo_path}, function(err2, meta2) {
              printError(err);
              return cb ? cb({msg: meta.output + err}) : that.exitCli(cst.ERROR_EXIT);
            });
            return false;
          }

          printOut(cst.PREFIX_MSG + &#x27;Process successfully updated %s&#x27;, process_name);
          printOut(cst.PREFIX_MSG + &#x27;Current commit %s&#x27;, meta.current_revision);
          that.reload(process_name, function(err, procs) {
            if (err) return cb(err);
            return cb ? cb(null, meta.output + res) : that.exitCli(cst.SUCCESS_EXIT);
          });
        });
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.close" id="apidoc.element.pm2.custom.prototype.close">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  var that = this;

  if (!cb) cb = function() {};

  this.Client.close(function(err, data) {
    debug(&#x27;The session lasted %ds&#x27;, (new Date() - that.start_timer) / 1000);
    return cb(err, data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Client.prototype.pingDaemon = function pingDaemon(cb) {
var req    = axon.socket(&#x27;req&#x27;);
var client = new rpc.Client(req);

debug(&#x27;[PING PM2] Trying to connect to server&#x27;);

client.sock.once(&#x27;reconnect attempt&#x27;, function() {
  client.sock.<span class="apidocCodeKeywordSpan">close</span>();
  debug(&#x27;Daemon not launched&#x27;);
  process.nextTick(function() {
    return cb(false);
  });
});

client.sock.once(&#x27;connect&#x27;, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.conf" id="apidoc.element.pm2.custom.prototype.conf">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>conf
        <span class="apidocSignatureSpan">(key, value, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conf = function (key, value, cb) {
  var that = this;

  if (typeof(value) === &#x27;function&#x27;) {
    cb = value;
    value = null;
  }

  // If key + value = set
  if (key &#x26;&#x26; value) {
    that.set(key, value, function(err) {
      if (err)
        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
      return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
    });
  }
  // If only key = get
  else if (key) {
    that.get(key, function(err, data) {
      if (err)
        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
      return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
    });
  }
  else {
    displayConf(function(err, data) {
      if (err)
        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
      return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.connect" id="apidoc.element.pm2.custom.prototype.connect">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>connect
        <span class="apidocSignatureSpan">(noDaemon, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function (noDaemon, cb) {
  var that = this;
  this.start_timer = new Date();

  if (typeof(cb) == &#x27;undefined&#x27;) {
    cb = noDaemon;
    noDaemon = false;
  } else if (noDaemon === true) {
    // Backward compatibility with PM2 1.x
    this.Client.daemon_mode = false;
    this.daemon_mode = false;
  }

  this.Client.start(function(err, meta) {
    if (err)
      return cb(err);

    if (meta.new_pm2_instance == false &#x26;&#x26; that.daemon_mode === true)
      return cb(err, meta);

    // If new pm2 instance has been popped
    // Lauch all modules
    Modularizer.launchAll(that, function(err_mod) {
      return cb(err, meta);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   client.sock.once(&#x27;close&#x27;, function() {
     return cb(true);
   });
   client.sock.close();
   debug(&#x27;Daemon alive&#x27;);
 });

 req.<span class="apidocCodeKeywordSpan">connect</span>(this.rpc_socket_file);
};

/**
* Methods to interact with the Daemon via RPC
* This method wait to be connected to the Daemon
* Once he&#x27;s connected it trigger the command parsing (on ./bin/pm2 file, at the end)
* @method launchRPC
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.dashboard" id="apidoc.element.pm2.custom.prototype.dashboard">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>dashboard
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dashboard = function (cb) {
  var that = this;

  var Dashboard = require(&#x27;./Dashboard&#x27;);

  if (cb) return cb(new Error(&#x27;Dashboard cant be called programmatically&#x27;));

  Dashboard.init();

  this.Client.launchBus(function (err, bus) {
    if (err) {
        console.error(&#x27;Error launchBus: &#x27; + err);
        that.exitCli(cst.ERROR_EXIT);
    }
    bus.on(&#x27;log:*&#x27;, function(type, data) {
      Dashboard.log(type, data);
    })
  });

  process.on(&#x27;SIGINT&#x27;, function() {
    this.Client.disconnectBus(function() {
      process.exit(cst.SUCCESS_EXIT);
    });
  });

  function launchDashboard() {
    that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
      if (err) {
        console.error(&#x27;Error retrieving process list: &#x27; + err);
        that.exitCli(cst.ERROR_EXIT);
      }

      Dashboard.refresh(list);

      setTimeout(function() {
        launchDashboard();
      }, 800);
    });
  }

  launchDashboard();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.deepUpdate" id="apidoc.element.pm2.custom.prototype.deepUpdate">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>deepUpdate
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deepUpdate = function (cb) {
  var that = this;

  Common.printOut(conf.PREFIX_MSG + &#x27;Updating PM2...&#x27;);

  var exec = require(&#x27;shelljs&#x27;).exec;
  var child = exec(&#x22;npm i -g pm2@latest; pm2 update&#x22;, {async : true});

  child.stdout.on(&#x27;end&#x27;, function() {
    Common.printOut(conf.PREFIX_MSG + &#x27;PM2 successfully updated&#x27;);
    cb ? cb(null, {success:true}) : that.exitCli(conf.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.delete" id="apidoc.element.pm2.custom.prototype.delete">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>delete
        <span class="apidocSignatureSpan">(process_name, jsonVia, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (process_name, jsonVia, cb) {
  var that = this;

  if (typeof(jsonVia) === &#x22;function&#x22;) {
    cb = jsonVia;
    jsonVia = null;
  }
  if (typeof(process_name) === &#x22;number&#x22;) {
    process_name = process_name.toString();
  }

  if (jsonVia == &#x27;pipe&#x27;)
    return that.actionFromJson(&#x27;deleteProcessId&#x27;, process_name, commander, &#x27;pipe&#x27;, cb);
  if (Common.isConfigFile(process_name))
    return that.actionFromJson(&#x27;deleteProcessId&#x27;, process_name, commander, &#x27;file&#x27;, cb);
  else
    that._operate(&#x27;deleteProcessId&#x27;, process_name, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return cb(new Error(&#x27;v8-profiler is not available&#x27;));
  }

  var snapshot1 = profiler.takeSnapshot();
  var path = require(&#x27;path&#x27;);
  snapshot1.export(function(error, result) {
    fs.writeFile(msg.pwd, result, function() {
      snapshot1.<span class="apidocCodeKeywordSpan">delete</span>();
      return cb(null, {file : msg.pwd});
    });
  });
}

function startProfilingPM2(msg, cb) {
  if (profiler == null) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.deleteModule" id="apidoc.element.pm2.custom.prototype.deleteModule">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>deleteModule
        <span class="apidocSignatureSpan">(module_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteModule = function (module_name, cb) {
  var that = this;

  var found_proc = [];

  this.Client.getAllProcess(function(err, procs) {
    if (err) {
      Common.printError(&#x27;Error retrieving process list: &#x27; + err);
      return cb(Common.retErr(err));
    }

    procs.forEach(function(proc) {
      if (proc.pm2_env.name == module_name &#x26;&#x26; proc.pm2_env.pmx_module) {
        found_proc.push(proc.pm_id);
      }
    });

    if (found_proc.length == 0)
      return cb();

    that._operate(&#x27;deleteProcessId&#x27;, found_proc[0], function(err) {
      if (err) return cb(Common.retErr(err));
      Common.printOut(&#x27;In memory process deleted&#x27;);
      return cb();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.deploy" id="apidoc.element.pm2.custom.prototype.deploy">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>deploy
        <span class="apidocSignatureSpan">(file, commands, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deploy = function (file, commands, cb) {
  var that = this;

  if (file == &#x27;help&#x27;) {
    deployHelper();
    return cb ? cb() : that.exitCli(cst.SUCCESS_EXIT);
  }

  var args = commands.rawArgs;
  var env;

  args.splice(0, args.indexOf(&#x27;deploy&#x27;) + 1);

  // Find ecosystem file by default
  if (!Common.isConfigFile(file)) {
    env = args[0];
    file = Utility.whichFileExists([&#x27;ecosystem.config.js&#x27;, &#x27;ecosystem.json&#x27;, &#x27;ecosystem.json5&#x27;, &#x27;package.json&#x27;]);

    if (!file) {
      Common.printError(&#x27;Not any default deployment file exists&#x27;);
      return cb ? cb(&#x27;Not any default ecosystem file present&#x27;) : that.exitCli(cst.ERROR_EXIT);
    }
  }
  else
    env = args[1];

  var json_conf = null;

  try {
    json_conf = Common.parseConfig(fs.readFileSync(file), file);
  } catch (e) {
    Common.printError(e);
    return cb ? cb(e) : that.exitCli(cst.ERROR_EXIT);
  }

  if (!env) {
    deployHelper();
    return cb ? cb() : that.exitCli(cst.SUCCESS_EXIT);
  }

  if (!json_conf.deploy || !json_conf.deploy[env]) {
    Common.printError(&#x27;%s environment is not defined in %s file&#x27;, env, file);
    return cb ? cb(&#x27;%s environment is not defined in %s file&#x27;) : that.exitCli(cst.ERROR_EXIT);
  }

  if (!json_conf.deploy[env][&#x27;post-deploy&#x27;]) {
    json_conf.deploy[env][&#x27;post-deploy&#x27;] = &#x27;pm2 startOrRestart &#x27; + file + &#x27; --env &#x27; + env;
  }

  Deploy.deployForEnv(json_conf.deploy, env, args, function(err, data) {
    if (err) {
      Common.printError(&#x27;Deploy failed&#x27;);
      return cb ? cb(err) : that.exitCli(cst.ERROR_EXIT);
    }
    Common.printOut(&#x27;--&#x3e; Success&#x27;);
    return cb ? cb(null, data) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.describe" id="apidoc.element.pm2.custom.prototype.describe">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>describe
        <span class="apidocSignatureSpan">(pm2_id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">describe = function (pm2_id, cb) {
  var that = this;

  var found_proc = [];

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(&#x27;Error retrieving process list: &#x27; + err);
      that.exitCli(conf.ERROR_EXIT);
    }

    list.forEach(function(proc) {
      if ((!isNaN(pm2_id)    &#x26;&#x26; proc.pm_id == pm2_id) ||
          (typeof(pm2_id) === &#x27;string&#x27; &#x26;&#x26; proc.name  == pm2_id)) {
        found_proc.push(proc);
      }
    });

    if (found_proc.length === 0) {
      Common.printError(conf.PREFIX_MSG_WARNING + &#x27;%s doesn\&#x27;t exist&#x27;, pm2_id);
      return cb ? cb(null, []) : that.exitCli(conf.ERROR_EXIT);
    }

    if (!cb) {
      found_proc.forEach(function(proc) {
        UX.describeTable(proc);
      });
    }

    return cb ? cb(null, found_proc) : that.exitCli(conf.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.destroy" id="apidoc.element.pm2.custom.prototype.destroy">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>destroy
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (cb) {
  var exec = require(&#x27;shelljs&#x27;).exec;
  var that = this;

  debug(&#x27;Killing and deleting current deamon&#x27;);

  this.killDaemon(function() {
    var cmd = &#x27;rm -rf &#x27; + that.pm2_home;
    var test_path = path.join(that.pm2_home, &#x27;module_conf.json&#x27;);
    var test_path_2 = path.join(that.pm2_home, &#x27;pm2.pid&#x27;);

    if (that.pm2_home.indexOf(&#x27;.pm2&#x27;) &#x3e; -1)
      return cb(new Error(&#x27;Destroy is not a allowed method on .pm2&#x27;));

    if (fs.accessSync) {
      fs.access(test_path, fs.R_OK, function(err) {
        if (err) return cb(err);
        debug(&#x27;Deleting temporary folder %s&#x27;, that.pm2_home);
        exec(cmd, cb);
      });
      return false;
    }

    // Support for Node 0.10
    fs.exists(test_path, function(exist) {
      if (exist) {
        debug(&#x27;Deleting temporary folder %s&#x27;, that.pm2_home);
        exec(cmd, cb);
      }
      return cb(null);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    that.client = null;
    debug(&#x27;PM2 RPC cleanly closed&#x27;);
    return cb(null, { msg : &#x27;RPC Successfully closed&#x27; });
  });

  timer = setTimeout(function() {
    if (Client.client_sock.destroy)
      that.client_sock.<span class="apidocCodeKeywordSpan">destroy</span>();
    that.client = null;
    return cb(null, { msg : &#x27;RPC Successfully closed via timeout&#x27; });
  }, 200);

  that.client_sock.close();
} catch(e) {
  debug(&#x27;Error while disconnecting RPC PM2&#x27;, e.stack || e);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.disconnect" id="apidoc.element.pm2.custom.prototype.disconnect">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>disconnect
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function (cb) {
  var that = this;

  if (!cb) cb = function() {};

  this.Client.close(function(err, data) {
    debug(&#x27;The session lasted %ds&#x27;, (new Date() - that.start_timer) / 1000);
    return cb(err, data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  child.once(&#x27;error&#x27;, onError);

  child.unref();

  child.once(&#x27;message&#x27;, function(msg) {
debug(&#x27;PM2 daemon launched with return message: &#x27;, msg);
child.removeListener(&#x27;error&#x27;, onError);
child.<span class="apidocCodeKeywordSpan">disconnect</span>();

if (opts &#x26;&#x26; opts.interactor == false)
  return cb(null, child);

/**
 * Here the Keymetrics agent is launched automaticcaly if
 * it has been already configured before (via pm2 link)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.dockerMode" id="apidoc.element.pm2.custom.prototype.dockerMode">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>dockerMode
        <span class="apidocSignatureSpan">(script, opts, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dockerMode = function (script, opts, mode) {
  var self = this;
  handleExit(self, opts, mode);

  if (mode == &#x27;distribution&#x27; &#x26;&#x26; !opts.imageName) {
    return console.error(chalk.bold.red(&#x27;--image-name [name] option is missing&#x27;));
  }

  var template;
  var app_path, main_script;
  var image_name;

  image_name   = opts.imageName || crypto.randomBytes(6).toString(&#x27;hex&#x27;);

  if (script.indexOf(&#x27;/&#x27;) &#x3e; -1) {
    app_path  = path.join(process.cwd(), path.dirname(script));
    main_script = path.basename(script);
  }
  else {
    app_path  = process.cwd();
    main_script = script;
  }

  checkDockerSetup()
    .then(function() {
      /////////////////////////
      // Generate Dockerfile //
      /////////////////////////
      return new Promise(function(resolve, reject) {
        var docker_filepath = path.join(process.cwd(), &#x27;Dockerfile&#x27;);

        fs.stat(docker_filepath, function(err, stat) {
          if (err) {
            // Dockerfile does not exists, generate one
            console.log(chalk.blue.bold(&#x27;Generating new Dockerfile&#x27;));
            return resolve(generateDockerfile(docker_filepath, main_script, mode));
          }
          return resolve(switchDockerFile(docker_filepath, main_script, mode));
        });
      });
    })
    .then(function(_template) {
      template = _template;
      return Promise.resolve();
    })
    .then(function() {
      //////////////////
      // Docker build //
      //////////////////

      var docker_build = util.format(&#x27;docker build -t %s -f %s&#x27;,
                                     image_name,
                                     template.Dockerfile_path);

      if (opts.fresh == true)
        docker_build += &#x27; --no-cache&#x27;;
      docker_build += &#x27; .&#x27;;

      console.log();
      fmt.sep();
      fmt.title(&#x27;Building Boot System&#x27;);
      fmt.field(&#x27;Type&#x27;, chalk.cyan.bold(&#x27;Docker&#x27;));
      fmt.field(&#x27;Mode&#x27;, mode);
      fmt.field(&#x27;Image name&#x27;, image_name);
      fmt.field(&#x27;Docker build command&#x27;, docker_build);
      fmt.field(&#x27;Dockerfile path&#x27;, template.Dockerfile_path);
      fmt.sep();

      return pspawn(docker_build);
    })
    .then(function() {
      ////////////////
      // Docker run //
      ////////////////

      var docker_run = &#x27;docker run --net host&#x27;;

      if (opts.daemon == true)
        docker_run += &#x27; -d&#x27;;
      if (mode != &#x27;distribution&#x27;)
        docker_run += util.format(&#x27; -v %s:/var/app -v /var/app/node_modules&#x27;, app_path);
      docker_run += &#x27; &#x27; + image_name;

      console.log();
      fmt.sep();
      fmt.title(&#x27;Booting&#x27;);
      fmt.field(&#x27;Type&#x27;, chalk.cyan.bold(&#x27;Docker&#x27;));
      fmt.field(&#x27;Mode&#x27;, mode);
      fmt.field(&#x27;Image name&#x27;, image_name);
      fmt.field(&#x27;Docker run command&#x27;, docker_run);
      fmt.field(&#x27;Docker main CMD&#x27;, template.CMD);
      fmt.field(&#x27;CWD&#x27;, app_path);
      fmt.sep();
      return pspawn(docker_run);
    })
    .then(function() {
      console.log(chalk.blue.bold(&#x27;&#x3e;&#x3e;&#x3e; Leaving Docker instance uuid=%s&#x27;), image_name);
      self.disconnect();
      return Promise.resolve();
    })
    .catch(function(err) {
      console.log();
      console.log(chalk.grey(&#x27;Raw error=&#x27;, err.message));
      self.disconnect();
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.dump" id="apidoc.element.pm2.custom.prototype.dump">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>dump
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dump = function (cb) {
  var env_arr = [];
  var that = this;


  Common.printOut(cst.PREFIX_MSG + &#x27;Saving current process list...&#x27;);

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(&#x27;Error retrieving process list: &#x27; + err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }

<span class="apidocCodeCommentSpan">    /**
     * Description
     * @method fin
     * @param {} err
     * @return
     */
</span>    function fin(err) {
      try {
        fs.writeFileSync(cst.DUMP_FILE_PATH, JSON.stringify(env_arr, &#x27;&#x27;, 2));
      } catch (e) {
        console.error(e.stack || e);
        Common.printOut(cst.PREFIX_MSG_ERR + &#x27;Failed to save dump file in %s&#x27;, cst.DUMP_FILE_PATH);
        return that.exitCli(cst.ERROR_EXIT);
      }
      if (cb) return cb(null, {success:true});

      Common.printOut(cst.PREFIX_MSG + &#x27;Successfully saved in %s&#x27;, cst.DUMP_FILE_PATH);
      return that.exitCli(cst.SUCCESS_EXIT);
    }

    (function ex(apps) {
      if (!apps[0]) return fin(null);
      delete apps[0].pm2_env.instances;
      delete apps[0].pm2_env.pm_id;
      if (!apps[0].pm2_env.pmx_module)
        env_arr.push(apps[0].pm2_env);
      apps.shift();
      return ex(apps);
    })(list);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.exitCli" id="apidoc.element.pm2.custom.prototype.exitCli">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>exitCli
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exitCli = function (code) {
  var that = this;

  // Do nothing if PM2 called programmatically (also in speedlist)
  if (conf.PM2_PROGRAMMATIC &#x26;&#x26; process.env.PM2_USAGE != &#x27;CLI&#x27;) return false;

  KMDaemon.disconnectRPC(function() {
    that.Client.close(function() {
      code = code || 0;
      // Safe exits process after all streams are drained.
      // file descriptor flag.
      var fds = 0;
      // exits process when stdout (1) and sdterr(2) are both drained.
      function tryToExit() {
        if ((fds &#x26; 1) &#x26;&#x26; (fds &#x26; 2)) {
          debug(&#x27;This command took %ds to execute&#x27;, (new Date() - that.start_timer) / 1000);
          process.exit(code);
        }
      }

      [process.stdout, process.stderr].forEach(function(std) {
        var fd = std.fd;
        if (!std.bufferSize) {
          // bufferSize equals 0 means current stream is drained.
          fds = fds | fd;
        } else {
          // Appends nothing to the std queue, but will trigger `tryToExit` event on `drain`.
          std.write &#x26;&#x26; std.write(&#x27;&#x27;, function() {
            fds = fds | fd;
            tryToExit();
          });
        }
        // Does not write anything more.
        delete std.write;
      });
      tryToExit();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.flush" id="apidoc.element.pm2.custom.prototype.flush">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>flush
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function (cb) {
  var that = this;

  Common.printOut(cst.PREFIX_MSG + &#x27;Flushing &#x27; + cst.PM2_LOG_FILE_PATH);
  fs.closeSync(fs.openSync(cst.PM2_LOG_FILE_PATH, &#x27;w&#x27;));

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }
    list.forEach(function(l) {
      Common.printOut(cst.PREFIX_MSG + &#x27;Flushing&#x27;);
      Common.printOut(cst.PREFIX_MSG + l.pm2_env.pm_out_log_path);
      Common.printOut(cst.PREFIX_MSG + l.pm2_env.pm_err_log_path);

      if (l.pm2_env.pm_log_path) {
        Common.printOut(cst.PREFIX_MSG + l.pm2_env.pm_log_path);
        fs.closeSync(fs.openSync(l.pm2_env.pm_log_path, &#x27;w&#x27;));
      }

      fs.closeSync(fs.openSync(l.pm2_env.pm_out_log_path, &#x27;w&#x27;));
      fs.closeSync(fs.openSync(l.pm2_env.pm_err_log_path, &#x27;w&#x27;));
    });
    Common.printOut(cst.PREFIX_MSG + &#x27;Logs flushed&#x27;);
    return cb ? cb(null, list) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.forward" id="apidoc.element.pm2.custom.prototype.forward">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>forward
        <span class="apidocSignatureSpan">(process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (process_name, cb) {
  var that = this;
  printOut(cst.PREFIX_MSG + &#x27;Updating to next commit repository for process name %s&#x27;, process_name);

  that.Client.getProcessByName(process_name, function(err, processes) {

    if (processes.length === 0) {
      printError(&#x27;No processes with this name: %s&#x27;, process_name);
      return cb ? cb({msg:&#x27;Process not found: &#x27;+process_name}) : that.exitCli(cst.ERROR_EXIT);
    }

    var proc = processes[0];
    if (proc.pm2_env.versioning) {
      vizion.next({folder: proc.pm2_env.versioning.repo_path}, function(err, meta) {
        if (err !== null)
          return cb ? cb({msg:err}) : that.exitCli(cst.ERROR_EXIT);
        if (meta.success === true) {
          getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function (command_list) {
            execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err, res) {
              if (err !== null)
              {
                vizion.prev({folder: proc.pm2_env.versioning.repo_path}, function(err2, meta2) {
                  printError(err);
                  return cb ? cb({msg:meta.output + err}) : that.exitCli(cst.ERROR_EXIT);
                });
              }
              else {
                printOut(cst.PREFIX_MSG + &#x27;Process successfully updated %s&#x27;, process_name);
                printOut(cst.PREFIX_MSG + &#x27;Current commit %s&#x27;, meta.current_revision);
                that.reload(process_name, function(err, procs) {
                  if (err) return cb(err);
                  return cb ? cb(null, meta.output + res) : that.exitCli(cst.SUCCESS_EXIT);
                });
              }
            });
          });
        }
        else {
          printOut(cst.PREFIX_MSG + &#x27;Already up-to-date or an error occured: %s&#x27;, process_name);
          return cb ? cb(null, {success:meta.success}) : that.exitCli(cst.SUCCESS_EXIT);
        }
      });
    }
    else {
      printOut(cst.PREFIX_MSG + &#x27;No versioning system found for process %s&#x27;, process_name);
      return cb ? cb({success:false, msg: &#x27;No versioning system found&#x27;}) : that.exitCli(cst.SUCCESS_EXIT);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.generateDockerfile" id="apidoc.element.pm2.custom.prototype.generateDockerfile">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>generateDockerfile
        <span class="apidocSignatureSpan">(script, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateDockerfile = function (script, opts) {
  var docker_filepath = path.join(process.cwd(), &#x27;Dockerfile&#x27;);
  var that = this;

  fs.stat(docker_filepath, function(err, stat) {
    if (err || opts.force == true) {
      generateDockerfile(docker_filepath, script, &#x27;development&#x27;)
        .then(function() {
          console.log(chalk.bold(&#x27;New Dockerfile generated in current folder&#x27;));
          console.log(chalk.bold(&#x27;You can now run\n$ pm2 docker:dev &#x3c;file|config&#x3e;&#x27;));
          return that.exitCli(cst.SUCCESS_EXIT);
        });
      return false;
    }
    console.log(chalk.red.bold(&#x27;Dockerfile already exists in this folder, use --force if you want to replace it&#x27;));
    that.exitCli(cst.ERROR_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.generateModuleSample" id="apidoc.element.pm2.custom.prototype.generateModuleSample">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>generateModuleSample
        <span class="apidocSignatureSpan">(app_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateModuleSample = function (app_name, cb) {
  var that = this;

  Modularizer.generateSample(app_name, function(err, data) {
    if (err)
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    return cb ? cb(null, data) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.generateSample" id="apidoc.element.pm2.custom.prototype.generateSample">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>generateSample
        <span class="apidocSignatureSpan">(mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateSample = function (mode) {
  var that = this;
  var templatePath;

  if (mode == &#x27;simple&#x27;)
    templatePath = path.join(cst.TEMPLATE_FOLDER, cst.APP_CONF_TPL_SIMPLE);
  else
    templatePath = path.join(cst.TEMPLATE_FOLDER, cst.APP_CONF_TPL);

  var sample = fs.readFileSync(templatePath);
  var dt     = sample.toString();
  var f_name = &#x27;ecosystem.config.js&#x27;;
		var pwd = process.env.PWD || process.cwd();

  try {
    fs.writeFileSync(path.join(pwd, f_name), dt);
  } catch (e) {
    console.error(e.stack || e);
    return that.exitCli(cst.ERROR_EXIT);
  }
  Common.printOut(&#x27;File %s generated&#x27;, path.join(pwd, f_name));
  that.exitCli(cst.SUCCESS_EXIT);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.get" id="apidoc.element.pm2.custom.prototype.get">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>get
        <span class="apidocSignatureSpan">(key, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (key, cb) {
  var that = this;

  if (!key || key == &#x27;all&#x27;) {
    that.displayConf(function(err, data) {
      if (err)
        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
      return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
    });
    return false;
  }
  Configuration.get(key, function(err, data) {
    if (err) {
      console.error(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }
    // pm2 conf module-name
    if (key.indexOf(&#x27;:&#x27;) === -1 &#x26;&#x26; key.indexOf(&#x27;.&#x27;) === -1) {
      displayConf(key, function() {
        return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
      });
      return false;
    }
    // pm2 conf module-name:key
    var module_name, key_name;

    if (key.indexOf(&#x27;:&#x27;) &#x3e; -1) {
      module_name = key.split(&#x27;:&#x27;)[0];
      key_name    = key.split(&#x27;:&#x27;)[1];
    } else if (key.indexOf(&#x27;.&#x27;) &#x3e; -1) {
      module_name = key.split(&#x27;.&#x27;)[0];
      key_name    = key.split(&#x27;.&#x27;)[1];
    }

    Common.printOut(&#x27;Value for module &#x27; + chalk.blue(module_name), &#x27;key &#x27; + chalk.blue(key_name) + &#x27;: &#x27; + chalk.bold.green(data));


    return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.getProcessIdByName" id="apidoc.element.pm2.custom.prototype.getProcessIdByName">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>getProcessIdByName
        <span class="apidocSignatureSpan">(name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProcessIdByName = function (name, cb) {
  var that = this;

  this.Client.getProcessIdByName(name, function(err, id) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
    }
    console.log(id);
    return cb ? cb(null, id) : that.exitCli(conf.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.getVersion" id="apidoc.element.pm2.custom.prototype.getVersion">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>getVersion
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getVersion = function (cb) {
  var that = this;

  that.Client.executeRemote(&#x27;getVersion&#x27;, {}, function(err) {
    return cb ? cb.apply(null, arguments) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.gracefulReload" id="apidoc.element.pm2.custom.prototype.gracefulReload">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>gracefulReload
        <span class="apidocSignatureSpan">(process_name, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gracefulReload = function (process_name, opts, cb) {
  var that = this;

  if (typeof(opts) == &#x22;function&#x22;) {
    cb = opts;
    opts = {};
  }

  //Common.printOut(conf.PREFIX_MSG_WARNING + chalk.bold.yellow(&#x27;Warning gracefulReload will be soon deprecated&#x27;));
  //Common.printOut(conf.PREFIX_MSG_WARNING + chalk.bold.yellow(&#x27;Use http://pm2.keymetrics.io/docs/usage/signals-clean-restart/
instead&#x27;));

  if (Common.isConfigFile(process_name))
    that._startJson(process_name, commander, &#x27;softReloadProcessId&#x27;);
  else {
    if (opts &#x26;&#x26; !opts.updateEnv)
      Common.printOut(IMMUTABLE_MSG);
    that._operate(&#x27;softReloadProcessId&#x27;, process_name, opts, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.install" id="apidoc.element.pm2.custom.prototype.install">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>install
        <span class="apidocSignatureSpan">(module_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function (module_name, cb) {
  var that = this;

  Modularizer.install(this, module_name, function(err, data) {
    if (err) {
      Common.printError(cst.PREFIX_MSG_ERR + (err.message || err));
      return cb ? cb(Common.retErr(err)) : that.speedList(cst.ERROR_EXIT);
    }

    // Check if special module with post_install display
    if (data &#x26;&#x26; data[0] &#x26;&#x26; data[0].pm2_env &#x26;&#x26; data[0].pm2_env.PM2_EXTRA_DISPLAY) {
      return postDisplay.call(that, data[0].pm2_env, cb);
    }
    return cb ? cb(null, data) : that.speedList(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.interact" id="apidoc.element.pm2.custom.prototype.interact">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>interact
        <span class="apidocSignatureSpan">(secret_key, public_key, machine_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interact = function (secret_key, public_key, machine_name, cb) {
  var that = this;

  KMDaemon.launchAndInteract(that._conf, {
    secret_key   : secret_key || null,
    public_key   : public_key || null,
    machine_name : machine_name || null
  }, function(err, dt) {
    if (err) {
      return cb ? cb(err) : that.exitCli(cst.ERROR_EXIT);
    }
    return cb ? cb(null, dt) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.interactInfos" id="apidoc.element.pm2.custom.prototype.interactInfos">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>interactInfos
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interactInfos = function (cb) {
  KMDaemon.getInteractInfo(this._conf, function(err, data) {
    if (err)
      return cb(Common.retErr(err));
    return cb(null, data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.jlist" id="apidoc.element.pm2.custom.prototype.jlist">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>jlist
        <span class="apidocSignatureSpan">(debug)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jlist = function (debug) {
  var that = this;

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(err);
      that.exitCli(conf.ERROR_EXIT);
    }

    if (debug) {
      process.stdout.write(util.inspect(list, false, null, false));
    }
    else {
      process.stdout.write(JSON.stringify(list));
    }

    that.exitCli(conf.SUCCESS_EXIT);

  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.kill" id="apidoc.element.pm2.custom.prototype.kill">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>kill
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kill = function (cb) {
  var that = this;

  var semver = require(&#x27;semver&#x27;);
  Common.printOut(conf.PREFIX_MSG + &#x27;Stopping PM2...&#x27;);

  that.Client.executeRemote(&#x27;notifyKillPM2&#x27;, {}, function() {});

  that.getVersion(function(err, data) {
    if (!err &#x26;&#x26; semver.lt(data, &#x27;1.1.0&#x27;)) {
      // Disable action command output if upgrading from &#x3c; 1.1.0 PM2
      // This is in order to avoid duplicated output
      process.env.PM2_SILENT = &#x27;true&#x27;;
      console.log(conf.PREFIX_MSG + &#x27;Killing processes...&#x27;);
    }

    that.killAllModules(function() {
      that._operate(&#x27;deleteProcessId&#x27;, &#x27;all&#x27;, function(err, list) {
        Common.printOut(conf.PREFIX_MSG + &#x27;All processes have been stopped and deleted&#x27;);
        process.env.PM2_SILENT = &#x27;false&#x27;;

        that.killInteract(function(err, data) {
          that.Client.killDaemon(function(err, res) {
            if (err) Common.printError(err);
            Common.printOut(conf.PREFIX_MSG + &#x27;PM2 stopped&#x27;);
            return cb ? cb(err, res) : that.exitCli(conf.SUCCESS_EXIT);
          });
        });
      });
    });

  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    console.log(&#x27;RPC closed&#x27;);
    that.pub_socket.close(function() {
console.log(&#x27;PUB closed&#x27;);

// notify cli that the daemon is shuting down (only under unix since windows doesnt handle signals)
if (cst.IS_WINDOWS === false) {
  try {
    process.<span class="apidocCodeKeywordSpan">kill</span>(parseInt(opts.pid), &#x27;SIGQUIT&#x27;);
  } catch(e) {
    console.error(&#x27;Could not send SIGQUIT to CLI&#x27;);
  }
}

console.log(&#x27;PM2 successfully stopped&#x27;);
setTimeout(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.killAllModules" id="apidoc.element.pm2.custom.prototype.killAllModules">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>killAllModules
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killAllModules = function (cb) {
  var that = this;

  this.Client.getAllModulesId(function(err, modules_id) {
    async.forEachLimit(modules_id, 1, function(id, next) {
      that._operate(&#x27;deleteProcessId&#x27;, id, next);
    }, function() {
      return cb ? cb() : false;
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.killDaemon" id="apidoc.element.pm2.custom.prototype.killDaemon">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>killDaemon
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killDaemon = function (cb) {
  var that = this;

  var semver = require(&#x27;semver&#x27;);
  Common.printOut(conf.PREFIX_MSG + &#x27;Stopping PM2...&#x27;);

  that.Client.executeRemote(&#x27;notifyKillPM2&#x27;, {}, function() {});

  that.getVersion(function(err, data) {
    if (!err &#x26;&#x26; semver.lt(data, &#x27;1.1.0&#x27;)) {
      // Disable action command output if upgrading from &#x3c; 1.1.0 PM2
      // This is in order to avoid duplicated output
      process.env.PM2_SILENT = &#x27;true&#x27;;
      console.log(conf.PREFIX_MSG + &#x27;Killing processes...&#x27;);
    }

    that.killAllModules(function() {
      that._operate(&#x27;deleteProcessId&#x27;, &#x27;all&#x27;, function(err, list) {
        Common.printOut(conf.PREFIX_MSG + &#x27;All processes have been stopped and deleted&#x27;);
        process.env.PM2_SILENT = &#x27;false&#x27;;

        that.killInteract(function(err, data) {
          that.Client.killDaemon(function(err, res) {
            if (err) Common.printError(err);
            Common.printOut(conf.PREFIX_MSG + &#x27;PM2 stopped&#x27;);
            return cb ? cb(err, res) : that.exitCli(conf.SUCCESS_EXIT);
          });
        });
      });
    });

  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.killInteract" id="apidoc.element.pm2.custom.prototype.killInteract">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>killInteract
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killInteract = function (cb) {
  var that = this;
  KMDaemon.killInteractorDaemon(that._conf, function(err) {
    return cb ? cb(Common.retErr(&#x27;Interactor not launched&#x27;)) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.launchBus" id="apidoc.element.pm2.custom.prototype.launchBus">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>launchBus
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">launchBus = function (cb) {
  this.Client.launchBus(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
fmt.field(&#x27;Watch and Restart&#x27;, chalk.green(&#x27;Enabled&#x27;));
fmt.field(&#x27;Ignored folder&#x27;, opts.ignore_watch || &#x27;node_modules&#x27;);
if (opts.postExec)
  fmt.field(&#x27;Post restart cmd&#x27;, opts.postExec);
fmt.sep();

setTimeout(function() {
  pm2.Client.<span class="apidocCodeKeywordSpan">launchBus</span>(function(err, bus) {
    bus.on(&#x27;process:event&#x27;, function(packet) {
      if (packet.event == &#x27;online&#x27;) {
        if (opts.postExec)
          postExecCmd(opts.postExec);
      }
    });
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.launchModules" id="apidoc.element.pm2.custom.prototype.launchModules">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>launchModules
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">launchModules = function (cb) {
  Modularizer.launchAll(this, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.list" id="apidoc.element.pm2.custom.prototype.list">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>list
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">list = function (opts, cb) {
  var that = this;

  if (typeof(opts) == &#x27;function&#x27;) {
    cb = opts;
    opts = null;
  }

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
    }

    if (opts &#x26;&#x26; opts.rawArgs &#x26;&#x26; opts.rawArgs.indexOf(&#x27;--watch&#x27;) &#x3e; -1) {
      var moment = require(&#x27;moment&#x27;);
      function show() {
        process.stdout.write(&#x27;\033[2J&#x27;);
        process.stdout.write(&#x27;\033[0f&#x27;);
        console.log(&#x27;Last refresh: &#x27;, moment().format(&#x27;LTS&#x27;));
        that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
          UX.dispAsTable(list, null);
        });
      }

      show();
      setInterval(show, 900);
      return false;
    }

    return cb ? cb(null, list) : that.speedList();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  else
    process.exit(0);
}

function autoExit(final) {
  setTimeout(function() {
    pm2.<span class="apidocCodeKeywordSpan">list</span>(function(err, apps) {
if (err) console.error(err.stack || err);

var online_count = 0;

apps.forEach(function(app) {
  if (app.pm2_env.status == cst.ONLINE_STATUS ||
      app.pm2_env.status == cst.LAUNCHING_STATUS)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.logrotate" id="apidoc.element.pm2.custom.prototype.logrotate">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>logrotate
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logrotate = function (opts, cb) {
  var that = this;

  if (process.getuid() != 0) {
    return exec(&#x27;whoami&#x27;, function(err, stdout, stderr) {
      Common.printError(cst.PREFIX_MSG + &#x27;You have to run this command as root. Execute the following command:&#x27;);
      Common.printError(cst.PREFIX_MSG + chalk.grey(&#x27;      sudo env PATH=$PATH:&#x27; + path.dirname(process.execPath) + &#x27; pm2 logrotate
 -u &#x27; + stdout.trim()));

      cb ? cb(Common.retErr(&#x27;You have to run this with elevated rights&#x27;)) : that.exitCli(cst.ERROR_EXIT);
    });
  }

  if (!fs.existsSync(&#x27;/etc/logrotate.d&#x27;)) {
    Common.printError(cst.PREFIX_MSG + &#x27;/etc/logrotate.d does not exist we can not copy the default configuration.&#x27;);
    return cb ? cb(Common.retErr(&#x27;/etc/logrotate.d does not exist&#x27;)) : that.exitCli(cst.ERROR_EXIT);
  }

  var templatePath = path.join(cst.TEMPLATE_FOLDER, cst.LOGROTATE_SCRIPT);
  Common.printOut(cst.PREFIX_MSG + &#x27;Getting logrorate template &#x27; + templatePath);
  var script = fs.readFileSync(templatePath, {encoding: &#x27;utf8&#x27;});

  var user = opts.user || &#x27;root&#x27;;

  script = script.replace(/%HOME_PATH%/g, cst.PM2_ROOT_PATH)
    .replace(/%USER%/g, user);

  try {
    fs.writeFileSync(&#x27;/etc/logrotate.d/pm2-&#x27;+user, script);
  } catch (e) {
    console.error(e.stack || e);
  }

  Common.printOut(cst.PREFIX_MSG + &#x27;Logrotate configuration added to /etc/logrotate.d/pm2&#x27;);
  return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.monit" id="apidoc.element.pm2.custom.prototype.monit">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>monit
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">monit = function (cb) {
  var that = this;

  var Monit = require(&#x27;./Monit.js&#x27;);

  if (cb) return cb(new Error(&#x27;Monit cant be called programmatically&#x27;));

  Monit.init();

  function launchMonitor() {
    that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
      if (err) {
        console.error(&#x27;Error retrieving process list: &#x27; + err);
        that.exitCli(conf.ERROR_EXIT);
      }

      Monit.refresh(list);

      setTimeout(function() {
        launchMonitor();
      }, 400);
    });
  }

  launchMonitor();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.msgProcess" id="apidoc.element.pm2.custom.prototype.msgProcess">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>msgProcess
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">msgProcess = function (opts, cb) {
  var that = this;

  that.Client.executeRemote(&#x27;msgProcess&#x27;, opts, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.multiset" id="apidoc.element.pm2.custom.prototype.multiset">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>multiset
        <span class="apidocSignatureSpan">(serial, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiset = function (serial, cb) {
  var that = this;

  Configuration.multiset(serial, function(err, data) {
    if (err)
      return cb ? cb({success:false, err:err}) : that.exitCli(cst.ERROR_EXIT);

    var values = [];
    var key = serial.match(/(?:[^ &#x22;]+|&#x22;[^&#x22;]*&#x22;)+/g)[0];

    if (key.indexOf(&#x27;.&#x27;) &#x3e; -1)
      values = key.split(&#x27;.&#x27;);

    if (key.indexOf(&#x27;:&#x27;) &#x3e; -1)
      values = key.split(&#x27;:&#x27;);

    if (values &#x26;&#x26; values.length &#x3e; 1) {
      // The first element is the app name (module_conf.json)
      var app_name = values[0];

      process.env.PM2_PROGRAMMATIC = &#x27;true&#x27;;
      that.restart(app_name, {
        updateEnv : true
      }, function(err, data) {
        process.env.PM2_PROGRAMMATIC = &#x27;false&#x27;;
        if (!err)
          Common.printOut(cst.PREFIX_MSG + &#x27;Module %s restarted&#x27;, app_name);
        displayConf(app_name, function() {
          return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
        });
      });
      return false;
    }
    displayConf(app_name, function() {
      return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
    });

  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.ping" id="apidoc.element.pm2.custom.prototype.ping">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>ping
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ping = function (cb) {
  var that = this;

  that.Client.executeRemote(&#x27;ping&#x27;, {}, function(err, res) {
    if (err) {
      Common.printError(err);
      return cb ? cb(new Error(err)) : that.exitCli(cst.ERROR_EXIT);
    }
    Common.printOut(res);
    return cb ? cb(null, res) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.printLogs" id="apidoc.element.pm2.custom.prototype.printLogs">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>printLogs
        <span class="apidocSignatureSpan">(id, lines, raw, timestamp, exclusive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">printLogs = function (id, lines, raw, timestamp, exclusive) {
  var that = this;
  var files_list = [];

  // If no argument is given, we stream logs for all running apps
  id = id || &#x27;all&#x27;;
  lines = lines !== undefined ? lines : 20;
  lines = lines &#x3c; 0 ? -(lines) : lines;

  // Avoid duplicates and check if path is different from &#x27;/dev/null&#x27;
  var pushIfUnique = function(entry) {
    var exists = false;

    if (entry.path.toLowerCase
        &#x26;&#x26; entry.path.toLowerCase() !== &#x27;/dev/null&#x27;) {

      files_list.some(function(file) {
        if (file.path === entry.path)
          exists = true;
        return exists;
      });

      if (exists)
        return;

      files_list.push(entry);
    }
  }

  // Get the list of all running apps
  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(err);
      that.exitCli(cst.ERROR_EXIT);
    }

    if (lines &#x3c;= 0) {
      return that.exitCli(cst.SUCCESS_EXIT)
    }

    Common.printOut(chalk.bold.grey(util.format.call(this, &#x27;[TAILING] Tailing last %d lines for [%s] process%s (change the value
 with --lines option)&#x27;, lines, id, id === &#x27;all&#x27; ? &#x27;es&#x27; : &#x27;&#x27;)));

    // Populate the array `files_list` with the paths of all files we need to tail
    list.forEach(function(proc) {
      if (proc.pm2_env &#x26;&#x26; (id === &#x27;all&#x27; ||
                           proc.pm2_env.name == id ||
                           proc.pm2_env.pm_id == id)) {
        if (proc.pm2_env.pm_out_log_path &#x26;&#x26; exclusive !== &#x27;err&#x27;)
          pushIfUnique({
            path     : proc.pm2_env.pm_out_log_path,
            app_name :proc.pm2_env.pm_id + &#x27;|&#x27; + proc.pm2_env.name,
            type     : &#x27;out&#x27;});
        if (proc.pm2_env.pm_err_log_path &#x26;&#x26; exclusive !== &#x27;out&#x27;)
          pushIfUnique({
            path     : proc.pm2_env.pm_err_log_path,
            app_name : proc.pm2_env.pm_id + &#x27;|&#x27; + proc.pm2_env.name,
            type     : &#x27;err&#x27;
          });
      }
    });

    if (!raw &#x26;&#x26; (id === &#x27;all&#x27; || id === &#x27;PM2&#x27;) &#x26;&#x26; exclusive === false) {
      Log.tail([{
        path     : cst.PM2_LOG_FILE_PATH,
        app_name : &#x27;PM2&#x27;,
        type     : &#x27;PM2&#x27;
      }], lines, raw, function() {
        Log.tail(files_list, lines, raw, function() {
          that.exitCli(cst.SUCCESS_EXIT);
        });
      });
    }
    else {
      Log.tail(files_list, lines, raw, function() {
        that.exitCli(cst.SUCCESS_EXIT);
      });
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.profilePM2" id="apidoc.element.pm2.custom.prototype.profilePM2">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>profilePM2
        <span class="apidocSignatureSpan">(command, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">profilePM2 = function (command, cb) {
  var that = this;
  var moment = require(&#x27;moment&#x27;);
  var file = path.join(process.cwd(), moment().format(&#x27;dd-HH:mm:ss&#x27;) + &#x27;.cpuprofile&#x27;);

  if (command == &#x27;start&#x27;) {
    that.Client.executeRemote(&#x27;profileStart&#x27;, {
    }, function(err) {
      if (err) {
        console.error(err);
        return that.exitCli(1);
      }
      console.log(&#x27;CPU profiling started, type pm2 profile stop once finished&#x27;);
      return cb ? cb.apply(null, arguments) : that.exitCli(cst.SUCCESS_EXIT);
    });
  }
  else if (command == &#x27;stop&#x27;) {
    that.Client.executeRemote(&#x27;profileStop&#x27;, {
      pwd : file
    }, function(err) {
      if (err) {
        console.error(err);
        return that.exitCli(1);
      }
      console.log(&#x27;CPU profile in %s&#x27;, file);
      return cb ? cb.apply(null, arguments) : that.exitCli(cst.SUCCESS_EXIT);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.publish" id="apidoc.element.pm2.custom.prototype.publish">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>publish
        <span class="apidocSignatureSpan">(module_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publish = function (module_name, cb) {
  var that = this;

  Modularizer.publish(function(err, data) {
    if (err)
      return cb ? cb(Common.retErr(err)) : that.speedList(cst.ERROR_EXIT);
    return cb ? cb(null, data) : that.speedList(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.pullAndGracefulReload" id="apidoc.element.pm2.custom.prototype.pullAndGracefulReload">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullAndGracefulReload
        <span class="apidocSignatureSpan">(process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pullAndGracefulReload = function (process_name, cb) {
  this._pull({process_name: process_name, action: &#x27;gracefulReload&#x27;}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.pullAndReload" id="apidoc.element.pm2.custom.prototype.pullAndReload">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullAndReload
        <span class="apidocSignatureSpan">(process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pullAndReload = function (process_name, cb) {
  this._pull({process_name: process_name, action: &#x27;reload&#x27;}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.pullAndRestart" id="apidoc.element.pm2.custom.prototype.pullAndRestart">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullAndRestart
        <span class="apidocSignatureSpan">(process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pullAndRestart = function (process_name, cb) {
  this._pull({process_name: process_name, action: &#x27;reload&#x27;}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.pullCommitId" id="apidoc.element.pm2.custom.prototype.pullCommitId">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>pullCommitId
        <span class="apidocSignatureSpan">(process_name, commit_id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pullCommitId = function (process_name, commit_id, cb) {
  var reload_type = &#x27;reload&#x27;;
  var that = this;

  printOut(cst.PREFIX_MSG + &#x27;Updating repository for process name %s&#x27;, process_name);

  that.Client.getProcessByName(process_name, function(err, processes) {

    if (processes.length === 0) {
      printError(&#x27;No processes with this name: %s&#x27;, process_name);
      return cb ? cb({msg:&#x27;Process not found: &#x27; + process_name}) : that.exitCli(cst.ERROR_EXIT);
    }

    var proc = processes[0];
    if (proc.pm2_env.versioning) {
      vizion.isUpToDate({folder: proc.pm2_env.versioning.repo_path}, function(err, meta) {
        if (err !== null)
          return cb ? cb({msg:err}) : that.exitCli(cst.ERROR_EXIT);
        vizion.revertTo(
          {revision: commit_id,
           folder: proc.pm2_env.versioning.repo_path},
          function(err2, meta2) {
            if (!err2 &#x26;&#x26; meta2.success) {
              getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function (command_list) {
                execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err, res) {
                  if (err !== null)
                  {
                    printError(err);
                    return cb ? cb({msg:err}) : that.exitCli(cst.ERROR_EXIT);
                  }
                  else {
                    printOut(cst.PREFIX_MSG + &#x27;Process successfully updated %s&#x27;, process_name);
                    printOut(cst.PREFIX_MSG + &#x27;Current commit %s&#x27;, commit_id);
                    return that[reload_type](process_name, cb);
                  }
                });
              });
            }
            else {
              printOut(cst.PREFIX_MSG + &#x27;Already up-to-date or an error occured: %s&#x27;, process_name);
              return cb ? cb(null, {success:meta.success}) : that.exitCli(cst.SUCCESS_EXIT);
            }
          });
      });
    }
    else {
      printOut(cst.PREFIX_MSG + &#x27;No versioning system found for process %s&#x27;, process_name);
      return cb ? cb(null, {success:false}) : that.exitCli(cst.SUCCESS_EXIT);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.reload" id="apidoc.element.pm2.custom.prototype.reload">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>reload
        <span class="apidocSignatureSpan">(process_name, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reload = function (process_name, opts, cb) {
  var that = this;

  if (typeof(opts) == &#x22;function&#x22;) {
    cb = opts;
    opts = {};
  }

  if (Common.isConfigFile(process_name))
    that._startJson(process_name, opts, &#x27;reloadProcessId&#x27;);
  else {
    if (opts &#x26;&#x26; !opts.updateEnv)
      Common.printOut(IMMUTABLE_MSG);
    that._operate(&#x27;reloadProcessId&#x27;, process_name, opts, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.reloadLogs" id="apidoc.element.pm2.custom.prototype.reloadLogs">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>reloadLogs
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reloadLogs = function (cb) {
  var that = this;

  Common.printOut(&#x27;Reloading all logs...&#x27;);
  that.Client.executeRemote(&#x27;reloadLogs&#x27;, {}, function(err, logs) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }
    Common.printOut(&#x27;All logs reloaded&#x27;);
    return cb ? cb(null, logs) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var that = this;

process.on(&#x27;SIGTERM&#x27;, that.gracefullExit);
process.on(&#x27;SIGINT&#x27;, that.gracefullExit);
process.on(&#x27;SIGHUP&#x27;, function() {});
process.on(&#x27;SIGQUIT&#x27;, that.gracefullExit);
process.on(&#x27;SIGUSR2&#x27;, function() {
  God.<span class="apidocCodeKeywordSpan">reloadLogs</span>({}, function() {});
});
}

Daemon.prototype.sendReady = function(cb) {
// Send ready message to Client
if (this.rpc_socket_ready == true &#x26;&#x26; this.pub_socket_ready == true) {
  cb(null, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.remote" id="apidoc.element.pm2.custom.prototype.remote">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>remote
        <span class="apidocSignatureSpan">(command, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remote = function (command, opts, cb) {
  var that = this;

  that[command](opts.name, function(err_cmd, ret) {
    if (err_cmd)
      console.error(err_cmd);
    console.log(&#x27;Command %s finished&#x27;, command);
    return cb(err_cmd, ret);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.remoteV2" id="apidoc.element.pm2.custom.prototype.remoteV2">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>remoteV2
        <span class="apidocSignatureSpan">(command, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteV2 = function (command, opts, cb) {
  var that = this;

  if (that[command].length == 1)
    return that[command](cb);

  opts.args.push(cb);
  return that[command].apply(this, opts.args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.reset" id="apidoc.element.pm2.custom.prototype.reset">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>reset
        <span class="apidocSignatureSpan">(process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function (process_name, cb) {
  var that = this;

  function processIds(ids, cb) {
    async.eachLimit(ids, conf.CONCURRENT_ACTIONS, function(id, next) {
      that.Client.executeRemote(&#x27;resetMetaProcessId&#x27;, id, function(err, res) {
        if (err) console.error(err);
        Common.printOut(conf.PREFIX_MSG + &#x27;Resetting meta for process id %d&#x27;, id);
        return next();
      });
    }, function(err) {
      if (err) return cb(Common.retErr(err));
      return cb ? cb(null, {success:true}) : that.speedList();
    });
  }

  if (process_name == &#x27;all&#x27;) {
    that.Client.getAllProcessId(function(err, ids) {
      if (err) {
        Common.printError(err);
        return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
      }
      return processIds(ids, cb);
    });
  }
  else if (isNaN(process_name)) {
    that.Client.getProcessIdByName(process_name, function(err, ids) {
      if (err) {
        Common.printError(err);
        return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
      }
      if (ids.length === 0) {
        Common.printError(&#x27;Unknown process name&#x27;);
        return cb ? cb(new Error(&#x27;Unknown process name&#x27;)) : that.exitCli(conf.ERROR_EXIT);
      }
      return processIds(ids, cb);
    });
  } else {
    processIds([process_name], cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.restart" id="apidoc.element.pm2.custom.prototype.restart">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>restart
        <span class="apidocSignatureSpan">(cmd, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restart = function (cmd, opts, cb) {
  if (typeof(opts) == &#x22;function&#x22;) {
    cb = opts;
    opts = {};
  }
  var that = this;

  if (typeof(cmd) === &#x27;number&#x27;)
    cmd = cmd.toString();

  if (cmd == &#x22;-&#x22;) {
    // Restart from PIPED JSON
    process.stdin.resume();
    process.stdin.setEncoding(&#x27;utf8&#x27;);
    process.stdin.on(&#x27;data&#x27;, function (param) {
      process.stdin.pause();
      that.actionFromJson(&#x27;restartProcessId&#x27;, param, opts, &#x27;pipe&#x27;, cb);
    });
  }
  else if (Common.isConfigFile(cmd) || typeof(cmd) === &#x27;object&#x27;)
    that._startJson(cmd, opts, &#x27;restartProcessId&#x27;, cb);
  else {
    if (opts &#x26;&#x26; !opts.updateEnv)
      Common.printOut(IMMUTABLE_MSG);
    that._operate(&#x27;restartProcessId&#x27;, cmd, opts, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.resurrect" id="apidoc.element.pm2.custom.prototype.resurrect">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>resurrect
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resurrect = function (cb) {
  var apps = {};
  var that = this;

  Common.printOut(cst.PREFIX_MSG + &#x27;Restoring processes located in %s&#x27;, cst.DUMP_FILE_PATH);

  try {
    apps = fs.readFileSync(cst.DUMP_FILE_PATH);
  } catch(e) {
    Common.printError(cst.PREFIX_MSG_ERR + &#x27;No processes saved; DUMP file doesn\&#x27;t exist&#x27;);
    // if (cb) return cb(Common.retErr(e));
    // else return that.exitCli(cst.ERROR_EXIT);
    return that.speedList();
  }

  var processes = Common.parseConfig(apps, &#x27;none&#x27;);

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(err);
      return that.exitCli(1);
    }

    var current = [];
    var target = [];

    list.forEach(function(app) {
      if (!current[app.name])
        current[app.name] = 0;
      current[app.name]++;
    });

    processes.forEach(function(app) {
      if (!target[app.name])
        target[app.name] = 0;
      target[app.name]++;
    });

    var tostart = Object.keys(target).filter(function(i) {
      return Object.keys(current).indexOf(i) &#x3c; 0;
    })

    async.eachLimit(processes, cst.CONCURRENT_ACTIONS, function(app, next) {
      if (tostart.indexOf(app.name) == -1)
        return next();
      that.Client.executeRemote(&#x27;prepare&#x27;, app, function(err, dt) {
        if (err)
          Common.printError(err);
        else
          Common.printOut(cst.PREFIX_MSG + &#x27;Process %s restored&#x27;, app.pm_exec_path);
        next();
      });
    }, function(err) {
      return cb ? cb(null, apps) : that.speedList();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.scale" id="apidoc.element.pm2.custom.prototype.scale">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>scale
        <span class="apidocSignatureSpan">(app_name, number, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scale = function (app_name, number, cb) {
  var that = this;

  function addProcs(proc, value, cb) {
    (function ex(proc, number) {
      if (number-- === 0) return cb();
      Common.printOut(conf.PREFIX_MSG + &#x27;Scaling up application&#x27;);
      that.Client.executeRemote(&#x27;duplicateProcessId&#x27;, proc.pm2_env.pm_id, ex.bind(this, proc, number));
    })(proc, number);
  }

  function rmProcs(procs, value, cb) {
    var i = 0;

    (function ex(procs, number) {
      if (number++ === 0) return cb();
      that._operate(&#x27;deleteProcessId&#x27;, procs[i++].pm2_env.pm_id, ex.bind(this, procs, number));
    })(procs, number);
  }

  function end() {
    return cb ? cb(null, {success:true}) : that.speedList();
  }

  this.Client.getProcessByName(app_name, function(err, procs) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);
    }

    if (!procs || procs.length === 0) {
      Common.printError(conf.PREFIX_MSG_ERR + &#x27;Application %s not found&#x27;, app_name);
      return cb ? cb(new Error(&#x27;App not found&#x27;)) : that.exitCli(conf.ERROR_EXIT);
    }

    if (procs[0].pm2_env.exec_mode !== &#x27;cluster_mode&#x27;) {
      Common.printError(conf.PREFIX_MSG_ERR + &#x27;Application %s is not in cluster mode&#x27;, app_name);
      return cb ? cb(new Error(&#x27;App not in cluster mode&#x27;)) : that.exitCli(conf.ERROR_EXIT);
    }

    var proc_number = procs.length;

    if (typeof(number) === &#x27;string&#x27; &#x26;&#x26; number.indexOf(&#x27;+&#x27;) &#x3e;= 0) {
      number = parseInt(number, 10);
      return addProcs(procs[0], number, end);
    }
    else if (typeof(number) === &#x27;string&#x27; &#x26;&#x26; number.indexOf(&#x27;-&#x27;) &#x3e;= 0) {
      number = parseInt(number, 10);
      return rmProcs(procs[0], number, end);
    }
    else {
      number = parseInt(number, 10);
      number = number - proc_number;

      if (number &#x3c; 0)
        return rmProcs(procs, number, end);
      else if (number &#x3e; 0)
        return addProcs(procs[0], number, end);
      else {
        Common.printError(conf.PREFIX_MSG_ERR + &#x27;Nothing to do&#x27;);
        return cb ? cb(new Error(&#x27;Same process number&#x27;)) : that.exitCli(conf.ERROR_EXIT);
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.sendDataToProcessId" id="apidoc.element.pm2.custom.prototype.sendDataToProcessId">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>sendDataToProcessId
        <span class="apidocSignatureSpan">(proc_id, packet, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendDataToProcessId = function (proc_id, packet, cb) {
  var that = this;

  packet.id = proc_id;

  that.Client.executeRemote(&#x27;sendDataToProcessId&#x27;, packet, function(err, res) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }
    Common.printOut(&#x27;successfully sent data to process&#x27;);
    return cb ? cb(null, res) : that.speedList();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.sendSignalToProcessId" id="apidoc.element.pm2.custom.prototype.sendSignalToProcessId">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>sendSignalToProcessId
        <span class="apidocSignatureSpan">(signal, process_id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendSignalToProcessId = function (signal, process_id, cb) {
  var that = this;

  that.Client.executeRemote(&#x27;sendSignalToProcessId&#x27;, {
    signal : signal,
    process_id : process_id
  }, function(err, list) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }
    Common.printOut(&#x27;successfully sent signal %s to process id %s&#x27;, signal, process_id);
    return cb ? cb(null, list) : that.speedList();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.sendSignalToProcessName" id="apidoc.element.pm2.custom.prototype.sendSignalToProcessName">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>sendSignalToProcessName
        <span class="apidocSignatureSpan">(signal, process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendSignalToProcessName = function (signal, process_name, cb) {
  var that = this;

  that.Client.executeRemote(&#x27;sendSignalToProcessName&#x27;, {
    signal : signal,
    process_name : process_name
  }, function(err, list) {
    if (err) {
      Common.printError(err);
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }
    Common.printOut(&#x27;successfully sent signal %s to process name %s&#x27;, signal, process_name);
    return cb ? cb(null, list) : that.speedList();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.serve" id="apidoc.element.pm2.custom.prototype.serve">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>serve
        <span class="apidocSignatureSpan">(target_path, port, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serve = function (target_path, port, opts, cb) {
  var that = this;
  var servePort = process.env.PM2_SERVE_PORT || port || 8080;
  var servePath = path.resolve(process.env.PM2_SERVE_PATH || target_path || &#x27;.&#x27;);

  var filepath = path.resolve(path.dirname(module.filename), &#x27;./Serve.js&#x27;);

  if (!opts.name || typeof(opts.name) == &#x27;function&#x27;)
    opts.name = &#x27;static-page-server-&#x27; + servePort;
  if (!opts.env)
    opts.env = {};
  opts.env.PM2_SERVE_PORT = servePort;
  opts.env.PM2_SERVE_PATH = servePath;
  opts.cwd = servePath;

  this.start(filepath, opts,  function (err, res) {
    if (err) {
      Common.printError(cst.PREFIX_MSG_ERR + &#x27;Error while trying to serve : &#x27; + err.message || err);
      return cb ? cb(err) : that.speedList(cst.ERROR_EXIT);
    }
    Common.printOut(cst.PREFIX_MSG + &#x27;Serving &#x27; + servePath + &#x27; on port &#x27; + servePort);
    return cb ? cb(null, res) : that.speedList();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.set" id="apidoc.element.pm2.custom.prototype.set">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>set
        <span class="apidocSignatureSpan">(key, value, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (key, value, cb) {
  var that = this;

<span class="apidocCodeCommentSpan">  /**
   * Specific when setting pm2 password
   * Used for restricted remote actions
   * Also alert Interactor that password has been set
   */
</span>  if (key.indexOf(&#x27;pm2:passwd&#x27;) &#x3e; -1) {
    value = Password.generate(value);
    Configuration.set(key, value, function(err) {
      if (err)
        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
      InteractorDaemonizer.launchRPC(that._conf, function(err) {
        if (err) {
          displayConf(&#x27;pm2&#x27;, function() {
            return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
          });
          return false;
        }
        InteractorDaemonizer.rpc.passwordSet(function() {
          InteractorDaemonizer.disconnectRPC(function() {
            displayConf(&#x27;pm2&#x27;, function() {
              return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
            });
          });
        });
        return false;
      });
    });
    return false;
  }

  /**
   * Set value
   */
  Configuration.set(key, value, function(err) {
    if (err)
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);

    var values = [];

    if (key.indexOf(&#x27;.&#x27;) &#x3e; -1)
      values = key.split(&#x27;.&#x27;);

    if (key.indexOf(&#x27;:&#x27;) &#x3e; -1)
      values = key.split(&#x27;:&#x27;);

    if (values &#x26;&#x26; values.length &#x3e; 1) {
      // The first element is the app name (module_conf.json)
      var app_name = values[0];

      process.env.PM2_PROGRAMMATIC = &#x27;true&#x27;;
      that.restart(app_name, {
        updateEnv : true
      }, function(err, data) {
        process.env.PM2_PROGRAMMATIC = &#x27;false&#x27;;
        if (!err)
          Common.printOut(cst.PREFIX_MSG + &#x27;Module %s restarted&#x27;, app_name);
        displayConf(app_name, function() {
          return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
        });
      });
      return false;
    }
    displayConf(null, function() {
      return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var arrays = [];
serial = serial.match(/(?:[^ &#x22;]+|&#x22;[^&#x22;]*&#x22;)+/g);

while (serial.length &#x3e; 0)
  arrays.push(serial.splice(0, 2));

async.eachSeries(arrays, function(el, next) {
  Configuration.<span class="apidocCodeKeywordSpan">set</span>(el[0], el[1], next);
}, cb);
};

Configuration.get = function(key, cb) {
Configuration.getAll(function(err, data) {
  var climb = splitKey(key);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.snapshotPM2" id="apidoc.element.pm2.custom.prototype.snapshotPM2">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>snapshotPM2
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">snapshotPM2 = function (cb) {
  var that = this;
  var moment = require(&#x27;moment&#x27;);
  var file = path.join(process.cwd(), moment().format(&#x27;dd-HH:mm:ss&#x27;) + &#x27;.heapsnapshot&#x27;);

  that.Client.executeRemote(&#x27;snapshotPM2&#x27;, {
    pwd : file
  }, function(err) {
    if (err) {
      console.error(err);
      return that.exitCli(1);
    }
    console.log(&#x27;Heapdump in %s&#x27;, file);
    return cb ? cb.apply(null, arguments) : that.exitCli(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.speedList" id="apidoc.element.pm2.custom.prototype.speedList">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>speedList
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">speedList = function (code) {
  var that = this;

  // Do nothing if PM2 called programmatically and not called from CLI (also in exitCli)
  if (conf.PM2_PROGRAMMATIC &#x26;&#x26; process.env.PM2_USAGE != &#x27;CLI&#x27;) return false;

  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      if (gl_retry == 0) {
        gl_retry += 1;
        return setTimeout(that.speedList.bind(that), 1400);
      }
      console.error(&#x27;Error retrieving process list: %s.\nA process seems to be on infinite loop, retry in 5 seconds&#x27;,err);
      return that.exitCli(conf.ERROR_EXIT);
    }
    if (process.stdout.isTTY === false) {
      UX.miniDisplay(list);
    }
    else if (commander.miniList &#x26;&#x26; !commander.silent)
      UX.miniDisplay(list);
    else if (!commander.silent) {
      if (that.gl_interact_infos) {
        Common.printOut(chalk.green.bold(&#x27;●&#x27;) + &#x27; Agent Online | Dashboard Access: &#x27; + chalk.bold(&#x27;https://app.keymetrics.io/#/r
/%s&#x27;) + &#x27; | Server name: %s&#x27;, that.gl_interact_infos.public_key, that.gl_interact_infos.machine_name);
      }
      UX.dispAsTable(list, that.gl_interact_infos);
      Common.printOut(chalk.white.italic(&#x27; Use `pm2 show &#x3c;id|name&#x3e;` to get more details about an app&#x27;));
    }

    if (that.Client.daemon_mode == false) {
      Common.printOut(&#x27;[--no-daemon] Continue to stream logs&#x27;);
      Common.printOut(&#x27;[--no-daemon] Exit on target PM2 exit pid=&#x27; + fs.readFileSync(conf.PM2_PID_FILE_PATH).toString());
      global._auto_exit = true;
      return that.streamLogs(&#x27;all&#x27;, 0, false, &#x27;HH:mm:ss&#x27;, false);
    }
    else if (commander.attach === true) {
      return that.streamLogs(&#x27;all&#x27;, 0, false, null, false);
    }
    else {
      return that.exitCli(code ? code : conf.SUCCESS_EXIT);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.start" id="apidoc.element.pm2.custom.prototype.start">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>start
        <span class="apidocSignatureSpan">(cmd, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (cmd, opts, cb) {
  if (typeof(opts) == &#x22;function&#x22;) {
    cb = opts;
    opts = {};
  }
  if (!opts)
    opts = {};

  var that = this;

  if (util.isArray(opts.watch) &#x26;&#x26; opts.watch.length === 0)
    opts.watch = (opts.rawArgs ? !!~opts.rawArgs.indexOf(&#x27;--watch&#x27;) : !!~process.argv.indexOf(&#x27;--watch&#x27;)) || false;

  if (Common.isConfigFile(cmd) || (typeof(cmd) === &#x27;object&#x27;))
    that._startJson(cmd, opts, &#x27;restartProcessId&#x27;, cb);
  else
    that._startScript(cmd, opts, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
else if (method.indexOf(&#x27;restartProcessId&#x27;) !== -1 &#x26;&#x26; process.argv.indexOf(&#x27;--watch&#x27;) &#x3e; -1) {
  delete app_conf.env.current_conf.watch;
  this.toggleWatch(method, app_conf);
}

if (!this.client || !this.client.call) {
  this.<span class="apidocCodeKeywordSpan">start</span>(function(error) {
    if (error) {
      if (fn)
        return fn(error);
      console.error(error);
      return process.exit(0);
    }
    return self.client.call(method, app_conf, fn);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.startup" id="apidoc.element.pm2.custom.prototype.startup">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>startup
        <span class="apidocSignatureSpan">(platform, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startup = function (platform, opts, cb) {
  var that = this;
  var actual_platform = detectInitSystem();
  var user = (opts.user || process.env.USER);
  var service_name = &#x27;pm2-&#x27; + user;
  var launchd_service_name = &#x27;pm2.&#x27; + user;

  if (!platform)
    platform = actual_platform;
  else if (actual_platform &#x26;&#x26; actual_platform !== platform) {
    console.log(&#x27;-----------------------------------------------------------&#x27;)
    console.log(&#x27; PM2 detected &#x27; + actual_platform + &#x27; but you precised &#x27; + platform)
    console.log(&#x27; Please verify that your choice is indeed your init system&#x27;)
    console.log(&#x27; If you arent sure, just run : pm2 startup&#x27;)
    console.log(&#x27;-----------------------------------------------------------&#x27;)
  }
  if (platform == null)
    throw new Error(&#x27;Init system not found&#x27;);

  if (!cb) {
    cb = function(err, data) {
      if (err)
        return that.exitCli(cst.ERROR_EXIT);
      return that.exitCli(cst.SUCCESS_EXIT);
    }
  }

  if (process.getuid() != 0) {
    return isNotRoot(platform, opts, cb);
  }

  var destination;
  var commands;
  var template;

  function getTemplate(type) {
    return fs.readFileSync(path.join(__dirname, &#x27;..&#x27;, &#x27;templates/init-scripts&#x27;, type + &#x27;.tpl&#x27;), {encoding: &#x27;utf8&#x27;});
  }

  switch(platform) {
  case &#x27;ubuntu&#x27;:
  case &#x27;centos&#x27;:
  case &#x27;arch&#x27;:
  case &#x27;oracle&#x27;:
  case &#x27;systemd&#x27;:
    template = getTemplate(&#x27;systemd&#x27;);
    destination = &#x27;/etc/systemd/system/&#x27; + service_name + &#x27;.service&#x27;;
    commands = [
      &#x27;chmod +x &#x27; + destination,
      &#x27;systemctl enable &#x27; + service_name,
      &#x27;systemctl start &#x27; + service_name,
      &#x27;systemctl daemon-reload&#x27;,
      &#x27;systemctl status &#x27; + service_name
    ];
    break;
  case &#x27;ubuntu14&#x27;:
  case &#x27;ubuntu12&#x27;:
  case &#x27;upstart&#x27;:
    template = getTemplate(&#x27;upstart&#x27;);
    destination = &#x27;/etc/init.d/&#x27; + service_name;
    commands = [
      &#x27;chmod +x &#x27; + destination,
      &#x27;mkdir -p /var/lock/subsys&#x27;,
      &#x27;touch /var/lock/subsys/&#x27; + service_name,
      &#x27;update-rc.d &#x27; + service_name + &#x27; defaults&#x27;
    ];
    break;
  case &#x27;systemv&#x27;:
  case &#x27;amazon&#x27;:
  case &#x27;centos6&#x27;:
    template = getTemplate(&#x27;upstart&#x27;);
    destination = &#x27;/etc/init.d/&#x27; + service_name;
    commands = [
      &#x27;chmod +x &#x27; + destination,
      &#x27;mkdir -p /var/lock/subsys&#x27;,
      &#x27;touch /var/lock/subsys/&#x27; + service_name,
      &#x27;chkconfig --add &#x27; + service_name,
      &#x27;chkconfig &#x27; + service_name + &#x27; on&#x27;,
      &#x27;initctl list&#x27;
    ];
    break;
  case &#x27;macos&#x27;:
  case &#x27;darwin&#x27;:
  case &#x27;launchd&#x27;:
    template = getTemplate(&#x27;launchd&#x27;);
    destination = path.join(process.env.HOME, &#x27;Library/LaunchAgents/&#x27; + launchd_service_name + &#x27;.plist&#x27;);
    commands = [
      &#x27;launchctl load -w &#x27; + destination
    ]
    break;
  case &#x27;freebsd&#x27;:
  case &#x27;rcd&#x27;:
    template = getTemplate(&#x27;rcd&#x27;);
    destination = &#x27;/etc/rc.d/&#x27; + service_name;
    commands = [
      &#x27;chmod +x &#x27; + destination,
      &#x27;echo &#x22;pm2_enable=YES&#x22; &#x3e;&#x3e; /etc/rc.conf&#x27;
    ];
    break;
  case &#x27;openrc&#x27;:
    template = getTemplate(&#x27;openrc&#x27;);
    destination = &#x27;/etc/init.d/&#x27; + service_name;
    commands = [
      &#x27;chmod +x &#x27; + destination,
	      &#x27;rc-update add &#x27; + service_name + &#x27; default&#x27;
    ];
    break;
  default:
    throw new Error(&#x27;Unknown platform / init system name&#x27;);
  }

<span class="apidocCodeCommentSpan">  /**
   * 4# Replace template variable value
   */
</span>  template = template.replace(/%PM2_PATH%/g, process.mainModule.filename)
    .replace(/%NODE_PATH%/g, path.dirname(process.execPath))
    .replace(/%USER%/g, user)
    .replace(/%HOME_PATH%/g, opts.hp ? path.resolve(opts.hp, &#x27;.pm2&#x27;) : cst.PM2_ROOT_PATH);

  console.log(chalk.bold(&#x27;Platform&#x27;), platform);
  console.log(chalk.bold(&#x27;Template&#x27;));
  console.log(template);
  console.log(chalk.bold(&#x27;Target path&#x27;));
  console.log(destination);
  console.log(chalk.bold(&#x27;Command list&#x27;));
  console.log(commands);

  Common.printOut(cst.PREFIX_MSG + &#x27;Writing init configuration in &#x27; + destination);
  try {
    fs.writeFileSync(destination, template);
  } catch (e) {
    console.error(cst.PREFIX_MSG_ERR + &#x27;Failure when trying to write startup script&#x27;);
    console.error(e.message || e);
    return cb(e);
  }

  Common.printOut(cst. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.stop" id="apidoc.element.pm2.custom.prototype.stop">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>stop
        <span class="apidocSignatureSpan">(process_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (process_name, cb) {
  var that = this;

  if (typeof(process_name) === &#x27;number&#x27;)
    process_name = process_name.toString();

  if (process_name == &#x22;-&#x22;) {
    process.stdin.resume();
    process.stdin.setEncoding(&#x27;utf8&#x27;);
    process.stdin.on(&#x27;data&#x27;, function (param) {
      process.stdin.pause();
      that.actionFromJson(&#x27;stopProcessId&#x27;, param, commander, &#x27;pipe&#x27;, cb);
    });
  }
  else if (Common.isConfigFile(process_name))
    that.actionFromJson(&#x27;stopProcessId&#x27;, process_name, commander, &#x27;file&#x27;, cb);
  else
    that._operate(&#x27;stopProcessId&#x27;, process_name, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.streamLogs" id="apidoc.element.pm2.custom.prototype.streamLogs">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>streamLogs
        <span class="apidocSignatureSpan">(id, lines, raw, timestamp, exclusive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">streamLogs = function (id, lines, raw, timestamp, exclusive) {
  var that = this;
  var files_list = [];

  // If no argument is given, we stream logs for all running apps
  id = id || &#x27;all&#x27;;
  lines = lines !== undefined ? lines : 20;
  lines = lines &#x3c; 0 ? -(lines) : lines;

  // Avoid duplicates and check if path is different from &#x27;/dev/null&#x27;
  var pushIfUnique = function(entry) {
    var exists = false;

    if (entry.path.toLowerCase
        &#x26;&#x26; entry.path.toLowerCase() !== &#x27;/dev/null&#x27;) {

      files_list.some(function(file) {
        if (file.path === entry.path)
          exists = true;
        return exists;
      });

      if (exists)
        return;

      files_list.push(entry);
    }
  }

  // Get the list of all running apps
  that.Client.executeRemote(&#x27;getMonitorData&#x27;, {}, function(err, list) {
    if (err) {
      Common.printError(err);
      that.exitCli(cst.ERROR_EXIT);
    }

    if (lines === 0 || raw)
      return Log.stream(that.Client, id, raw, timestamp, exclusive);

    Common.printOut(chalk.bold.grey(util.format.call(this, &#x27;[TAILING] Tailing last %d lines for [%s] process%s (change the value
 with --lines option)&#x27;, lines, id, id === &#x27;all&#x27; ? &#x27;es&#x27; : &#x27;&#x27;)));

    // Populate the array `files_list` with the paths of all files we need to tail
    list.forEach(function(proc) {
      if (proc.pm2_env &#x26;&#x26; (id === &#x27;all&#x27; ||
                           proc.pm2_env.name == id ||
                           proc.pm2_env.pm_id == id)) {
        if (proc.pm2_env.pm_out_log_path &#x26;&#x26; exclusive !== &#x27;err&#x27;)
          pushIfUnique({
            path     : proc.pm2_env.pm_out_log_path,
            app_name :proc.pm2_env.pm_id + &#x27;|&#x27; + proc.pm2_env.name,
            type     : &#x27;out&#x27;});
        if (proc.pm2_env.pm_err_log_path &#x26;&#x26; exclusive !== &#x27;out&#x27;)
          pushIfUnique({
            path     : proc.pm2_env.pm_err_log_path,
            app_name : proc.pm2_env.pm_id + &#x27;|&#x27; + proc.pm2_env.name,
            type     : &#x27;err&#x27;
          });
      }
    });

    if (!raw &#x26;&#x26; (id === &#x27;all&#x27; || id === &#x27;PM2&#x27;) &#x26;&#x26; exclusive === false) {
      Log.tail([{
        path     : cst.PM2_LOG_FILE_PATH,
        app_name : &#x27;PM2&#x27;,
        type     : &#x27;PM2&#x27;
      }], lines, raw, function() {
        Log.tail(files_list, lines, raw, function() {
          Log.stream(that.Client, id, raw, timestamp, exclusive);
        });
      });
    }
    else {
      Log.tail(files_list, lines, raw, function() {
        Log.stream(that.Client, id, raw, timestamp, exclusive);
      });
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.trigger" id="apidoc.element.pm2.custom.prototype.trigger">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>trigger
        <span class="apidocSignatureSpan">(pm_id, action_name, params, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trigger = function (pm_id, action_name, params, cb) {
  if (typeof(params) === &#x27;function&#x27;) {
    cb = params;
    params = null;
  }
  var cmd = {
    msg : action_name
  };
  var counter = 0;
  var process_wait_count = 0;
  var that = this;
  var results = [];

  if (params)
    cmd.opts = params;
  if (isNaN(pm_id))
    cmd.name = pm_id;
  else
    cmd.id = pm_id;

  this.launchBus(function(err, bus) {
    bus.on(&#x27;axm:reply&#x27;, function(ret) {
      if (ret.process.name == pm_id || ret.process.pm_id == pm_id) {
        results.push(ret);
        Common.printOut(&#x27;[%s:%s]=%j&#x27;, ret.process.name, ret.process.pm_id, ret.data.return);
        if (++counter == process_wait_count)
          return cb ? cb(null, results) : that.exitCli(cst.SUCCESS_EXIT);
      }
    });

    that.msgProcess(cmd, function(err, data) {
      if (err) {
        Common.printError(err);
        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
      }
      process_wait_count = data.process_count;
      Common.printOut(chalk.bold(&#x27;%s processes have received command %s&#x27;),
                      data.process_count, action_name);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.uninstall" id="apidoc.element.pm2.custom.prototype.uninstall">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>uninstall
        <span class="apidocSignatureSpan">(module_name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function (module_name, cb) {
  var that = this;

  Modularizer.uninstall(this, module_name, function(err, data) {
    if (err)
      return cb ? cb(Common.retErr(err)) : that.speedList(cst.ERROR_EXIT);
    return cb ? cb(null, data) : that.speedList(cst.SUCCESS_EXIT);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.uninstallStartup" id="apidoc.element.pm2.custom.prototype.uninstallStartup">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>uninstallStartup
        <span class="apidocSignatureSpan">(platform, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstallStartup = function (platform, opts, cb) {
  var commands;
  var that = this;
  var actual_platform = detectInitSystem();
  var user = opts.user || process.env.USER;
  var service_name = &#x27;pm2-&#x27; + user;
  var launchd_service_name = &#x27;pm2.&#x27; + user;

  if (!platform)
    platform = actual_platform;
  else if (actual_platform &#x26;&#x26; actual_platform !== platform) {
    console.log(&#x27;-----------------------------------------------------------&#x27;)
    console.log(&#x27; PM2 detected &#x27; + actual_platform + &#x27; but you precised &#x27; + platform)
    console.log(&#x27; Please verify that your choice is indeed your init system&#x27;)
    console.log(&#x27; If you arent sure, just run : pm2 startup&#x27;)
    console.log(&#x27;-----------------------------------------------------------&#x27;)
  }
  if (platform === null)
    throw new Error(&#x27;Init system not found&#x27;)

  if (!cb) {
    cb = function(err, data) {
      if (err)
        return that.exitCli(cst.ERROR_EXIT);
      return that.exitCli(cst.SUCCESS_EXIT);
    }
  }

  if (process.getuid() != 0) {
    return isNotRoot(platform, opts, cb);
  }

  if (fs.existsSync(&#x27;/etc/init.d/pm2-init.sh&#x27;)) {
    platform = &#x27;oldsystem&#x27;;
  }

  switch(platform) {
  case &#x27;systemd&#x27;:
    commands = [
      &#x27;systemctl stop &#x27; + service_name,
      &#x27;systemctl disable &#x27; + service_name,
      &#x27;rm /etc/systemd/system/&#x27; + service_name + &#x27;.service&#x27;
    ];
    break;
  case &#x27;systemv&#x27;:
    commands = [
      &#x27;chkconfig &#x27; + service_name + &#x27; off&#x27;,
      &#x27;rm /etc/init.d/&#x27; + service_name
    ];
    break;
  case &#x27;oldsystem&#x27;:
    Common.printOut(cst.PREFIX_MSG + &#x27;Disabling and deleting old startup system&#x27;);
    commands = [
      &#x27;update-rc.d pm2-init.sh disable&#x27;,
      &#x27;update-rc.d -f pm2-init.sh remove&#x27;,
      &#x27;rm /etc/init.d/pm2-init.sh&#x27;
    ];
    break;
  case &#x27;openrc&#x27;:
    commands = [
	      &#x27;/etc/init.d/&#x27; + service_name + &#x27; stop&#x27;,
      &#x27;rc-update delete &#x27; + service_name + &#x27; default&#x27;,
      &#x27;rm /etc/init.d/&#x27; + service_name
    ];
    break;
  case &#x27;upstart&#x27;:
    commands = [
      &#x27;update-rc.d &#x27; + service_name + &#x27; disable&#x27;,
      &#x27;update-rc.d -f &#x27; + service_name + &#x27; remove&#x27;,
      &#x27;rm /etc/init.d/&#x27; + service_name
    ];
    break;
  case &#x27;launchd&#x27;:
    var destination = path.join(process.env.HOME, &#x27;Library/LaunchAgents/&#x27; + launchd_service_name + &#x27;.plist&#x27;);
    commands = [
      &#x27;launchctl remove com.&#x27; + launchd_service_name,
      &#x27;rm &#x27; + destination
    ];
  };

  shelljs.exec(commands.join(&#x27;&#x26;&#x26; &#x27;), function(code, stdout, stderr) {
    console.log(stdout);
    console.log(stderr);
    if (code == 0) {
      Common.printOut(cst.PREFIX_MSG + chalk.bold(&#x27;Init file disabled.&#x27;));
    } else {
      Common.printOut(cst.ERROR_MSG + chalk.bold(&#x27;Return code : &#x27; + code));
    }

    cb(null, {
      commands : commands,
      platform : platform
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.unset" id="apidoc.element.pm2.custom.prototype.unset">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>unset
        <span class="apidocSignatureSpan">(key, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unset = function (key, cb) {
  var that = this;

  Configuration.unset(key, function(err) {
    if (err) {
      return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
    }

    displayConf(function() {
      return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.update" id="apidoc.element.pm2.custom.prototype.update">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>update
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (cb) {
  var that = this;

  Common.printOut(&#x27;Be sure to have the latest version by doing `npm install pm2@latest -g` before doing this procedure.&#x27;);

  // Dump PM2 processes
  that.Client.executeRemote(&#x27;notifyKillPM2&#x27;, {}, function() {});

  that.dump(function(err) {
    debug(&#x27;Dumping successfull&#x27;, err);
    that.killDaemon(function() {
      debug(&#x27;------------------ Everything killed&#x27;, arguments);
      that.Client.launchDaemon({interactor:false}, function(err, child) {
        that.Client.launchRPC(function() {
          that.resurrect(function() {
            Common.printOut(chalk.blue.bold(&#x27;&#x3e;&#x3e;&#x3e;&#x3e;&#x3e;&#x3e;&#x3e;&#x3e;&#x3e;&#x3e; PM2 updated&#x27;));
            Modularizer.launchAll(that, function() {
              KMDaemon.launchAndInteract(that._conf, null, function(err, data, interactor_proc) {
                // Interactor error can be skipped here
                return cb ? cb(null, {success:true}) : that.speedList();
              });
            });
          });
        });
      });
    });
  });

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pm2.custom.prototype.web" id="apidoc.element.pm2.custom.prototype.web">
        function <span class="apidocSignatureSpan">pm2.custom.prototype.</span>web
        <span class="apidocSignatureSpan">(port, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">web = function (port, cb) {
  var that = this;

  if (typeof(port) === &#x27;function&#x27;) {
    cb = port;
    port = 9615;
  }

  var filepath = path.resolve(path.dirname(module.filename), &#x27;../HttpInterface.js&#x27;);

  that.start({
    script : filepath,
    name : &#x27;pm2-http-interface&#x27;,
    execMode : &#x27;fork_mode&#x27;,
    env : {
      PM2_WEB_PORT : port
    }
  }, function(err, proc) {
    if (err) {
      Common.printError(cst.PREFIX_MSG_ERR + &#x27;Error while launching application&#x27;, err.stack || err);
      return cb ? cb(Common.retErr(err)) : that.speedList();
    }
    Common.printOut(cst.PREFIX_MSG + &#x27;Process launched&#x27;);
    return cb ? cb(null, proc) : that.speedList();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
